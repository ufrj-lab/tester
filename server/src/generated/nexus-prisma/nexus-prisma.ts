/**
 * This file was automatically generated by nexus-prisma@0.3.7
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
   interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
   objectTypes: {
      fields: {
         Query: QueryObject
         Key: KeyObject
         KeyUserType: KeyUserTypeObject
         KeyTestResultStatus: KeyTestResultStatusObject
         KeyStepResultStatus: KeyStepResultStatusObject
         KeyLanguage: KeyLanguageObject
         KeyConnection: KeyConnectionObject
         PageInfo: PageInfoObject
         KeyEdge: KeyEdgeObject
         AggregateKey: AggregateKeyObject
         KeyUserTypeConnection: KeyUserTypeConnectionObject
         KeyUserTypeEdge: KeyUserTypeEdgeObject
         AggregateKeyUserType: AggregateKeyUserTypeObject
         KeyLanguageConnection: KeyLanguageConnectionObject
         KeyLanguageEdge: KeyLanguageEdgeObject
         AggregateKeyLanguage: AggregateKeyLanguageObject
         KeyTestResultStatusConnection: KeyTestResultStatusConnectionObject
         KeyTestResultStatusEdge: KeyTestResultStatusEdgeObject
         AggregateKeyTestResultStatus: AggregateKeyTestResultStatusObject
         KeyStepResultStatusConnection: KeyStepResultStatusConnectionObject
         KeyStepResultStatusEdge: KeyStepResultStatusEdgeObject
         AggregateKeyStepResultStatus: AggregateKeyStepResultStatusObject
         MultiLanguageContent: MultiLanguageContentObject
         MultiLanguageContentConnection: MultiLanguageContentConnectionObject
         MultiLanguageContentEdge: MultiLanguageContentEdgeObject
         AggregateMultiLanguageContent: AggregateMultiLanguageContentObject
         Message: MessageObject
         MessageConnection: MessageConnectionObject
         MessageEdge: MessageEdgeObject
         AggregateMessage: AggregateMessageObject
         Company: CompanyObject
         Test: TestObject
         Step: StepObject
         Menu: MenuObject
         StepResult: StepResultObject
         TestResult: TestResultObject
         CompanyConnection: CompanyConnectionObject
         CompanyEdge: CompanyEdgeObject
         AggregateCompany: AggregateCompanyObject
         TestConnection: TestConnectionObject
         TestEdge: TestEdgeObject
         AggregateTest: AggregateTestObject
         MenuConnection: MenuConnectionObject
         MenuEdge: MenuEdgeObject
         AggregateMenu: AggregateMenuObject
         StepConnection: StepConnectionObject
         StepEdge: StepEdgeObject
         AggregateStep: AggregateStepObject
         TestResultConnection: TestResultConnectionObject
         TestResultEdge: TestResultEdgeObject
         AggregateTestResult: AggregateTestResultObject
         StepResultConnection: StepResultConnectionObject
         StepResultEdge: StepResultEdgeObject
         AggregateStepResult: AggregateStepResultObject
         Mutation: MutationObject
         BatchPayload: BatchPayloadObject
         Subscription: SubscriptionObject
         KeySubscriptionPayload: KeySubscriptionPayloadObject
         KeyPreviousValues: KeyPreviousValuesObject
         KeyUserTypeSubscriptionPayload: KeyUserTypeSubscriptionPayloadObject
         KeyUserTypePreviousValues: KeyUserTypePreviousValuesObject
         KeyLanguageSubscriptionPayload: KeyLanguageSubscriptionPayloadObject
         KeyLanguagePreviousValues: KeyLanguagePreviousValuesObject
         KeyTestResultStatusSubscriptionPayload: KeyTestResultStatusSubscriptionPayloadObject
         KeyTestResultStatusPreviousValues: KeyTestResultStatusPreviousValuesObject
         KeyStepResultStatusSubscriptionPayload: KeyStepResultStatusSubscriptionPayloadObject
         KeyStepResultStatusPreviousValues: KeyStepResultStatusPreviousValuesObject
         MultiLanguageContentSubscriptionPayload: MultiLanguageContentSubscriptionPayloadObject
         MultiLanguageContentPreviousValues: MultiLanguageContentPreviousValuesObject
         MessageSubscriptionPayload: MessageSubscriptionPayloadObject
         MessagePreviousValues: MessagePreviousValuesObject
         CompanySubscriptionPayload: CompanySubscriptionPayloadObject
         CompanyPreviousValues: CompanyPreviousValuesObject
         TestSubscriptionPayload: TestSubscriptionPayloadObject
         TestPreviousValues: TestPreviousValuesObject
         MenuSubscriptionPayload: MenuSubscriptionPayloadObject
         MenuPreviousValues: MenuPreviousValuesObject
         StepSubscriptionPayload: StepSubscriptionPayloadObject
         StepPreviousValues: StepPreviousValuesObject
         TestResultSubscriptionPayload: TestResultSubscriptionPayloadObject
         TestResultPreviousValues: TestResultPreviousValuesObject
         StepResultSubscriptionPayload: StepResultSubscriptionPayloadObject
         StepResultPreviousValues: StepResultPreviousValuesObject
      }
      fieldsDetails: {
         Query: QueryFieldDetails
         Key: KeyFieldDetails
         KeyUserType: KeyUserTypeFieldDetails
         KeyTestResultStatus: KeyTestResultStatusFieldDetails
         KeyStepResultStatus: KeyStepResultStatusFieldDetails
         KeyLanguage: KeyLanguageFieldDetails
         KeyConnection: KeyConnectionFieldDetails
         PageInfo: PageInfoFieldDetails
         KeyEdge: KeyEdgeFieldDetails
         AggregateKey: AggregateKeyFieldDetails
         KeyUserTypeConnection: KeyUserTypeConnectionFieldDetails
         KeyUserTypeEdge: KeyUserTypeEdgeFieldDetails
         AggregateKeyUserType: AggregateKeyUserTypeFieldDetails
         KeyLanguageConnection: KeyLanguageConnectionFieldDetails
         KeyLanguageEdge: KeyLanguageEdgeFieldDetails
         AggregateKeyLanguage: AggregateKeyLanguageFieldDetails
         KeyTestResultStatusConnection: KeyTestResultStatusConnectionFieldDetails
         KeyTestResultStatusEdge: KeyTestResultStatusEdgeFieldDetails
         AggregateKeyTestResultStatus: AggregateKeyTestResultStatusFieldDetails
         KeyStepResultStatusConnection: KeyStepResultStatusConnectionFieldDetails
         KeyStepResultStatusEdge: KeyStepResultStatusEdgeFieldDetails
         AggregateKeyStepResultStatus: AggregateKeyStepResultStatusFieldDetails
         MultiLanguageContent: MultiLanguageContentFieldDetails
         MultiLanguageContentConnection: MultiLanguageContentConnectionFieldDetails
         MultiLanguageContentEdge: MultiLanguageContentEdgeFieldDetails
         AggregateMultiLanguageContent: AggregateMultiLanguageContentFieldDetails
         Message: MessageFieldDetails
         MessageConnection: MessageConnectionFieldDetails
         MessageEdge: MessageEdgeFieldDetails
         AggregateMessage: AggregateMessageFieldDetails
         Company: CompanyFieldDetails
         Test: TestFieldDetails
         Step: StepFieldDetails
         Menu: MenuFieldDetails
         StepResult: StepResultFieldDetails
         TestResult: TestResultFieldDetails
         CompanyConnection: CompanyConnectionFieldDetails
         CompanyEdge: CompanyEdgeFieldDetails
         AggregateCompany: AggregateCompanyFieldDetails
         TestConnection: TestConnectionFieldDetails
         TestEdge: TestEdgeFieldDetails
         AggregateTest: AggregateTestFieldDetails
         MenuConnection: MenuConnectionFieldDetails
         MenuEdge: MenuEdgeFieldDetails
         AggregateMenu: AggregateMenuFieldDetails
         StepConnection: StepConnectionFieldDetails
         StepEdge: StepEdgeFieldDetails
         AggregateStep: AggregateStepFieldDetails
         TestResultConnection: TestResultConnectionFieldDetails
         TestResultEdge: TestResultEdgeFieldDetails
         AggregateTestResult: AggregateTestResultFieldDetails
         StepResultConnection: StepResultConnectionFieldDetails
         StepResultEdge: StepResultEdgeFieldDetails
         AggregateStepResult: AggregateStepResultFieldDetails
         Mutation: MutationFieldDetails
         BatchPayload: BatchPayloadFieldDetails
         Subscription: SubscriptionFieldDetails
         KeySubscriptionPayload: KeySubscriptionPayloadFieldDetails
         KeyPreviousValues: KeyPreviousValuesFieldDetails
         KeyUserTypeSubscriptionPayload: KeyUserTypeSubscriptionPayloadFieldDetails
         KeyUserTypePreviousValues: KeyUserTypePreviousValuesFieldDetails
         KeyLanguageSubscriptionPayload: KeyLanguageSubscriptionPayloadFieldDetails
         KeyLanguagePreviousValues: KeyLanguagePreviousValuesFieldDetails
         KeyTestResultStatusSubscriptionPayload: KeyTestResultStatusSubscriptionPayloadFieldDetails
         KeyTestResultStatusPreviousValues: KeyTestResultStatusPreviousValuesFieldDetails
         KeyStepResultStatusSubscriptionPayload: KeyStepResultStatusSubscriptionPayloadFieldDetails
         KeyStepResultStatusPreviousValues: KeyStepResultStatusPreviousValuesFieldDetails
         MultiLanguageContentSubscriptionPayload: MultiLanguageContentSubscriptionPayloadFieldDetails
         MultiLanguageContentPreviousValues: MultiLanguageContentPreviousValuesFieldDetails
         MessageSubscriptionPayload: MessageSubscriptionPayloadFieldDetails
         MessagePreviousValues: MessagePreviousValuesFieldDetails
         CompanySubscriptionPayload: CompanySubscriptionPayloadFieldDetails
         CompanyPreviousValues: CompanyPreviousValuesFieldDetails
         TestSubscriptionPayload: TestSubscriptionPayloadFieldDetails
         TestPreviousValues: TestPreviousValuesFieldDetails
         MenuSubscriptionPayload: MenuSubscriptionPayloadFieldDetails
         MenuPreviousValues: MenuPreviousValuesFieldDetails
         StepSubscriptionPayload: StepSubscriptionPayloadFieldDetails
         StepPreviousValues: StepPreviousValuesFieldDetails
         TestResultSubscriptionPayload: TestResultSubscriptionPayloadFieldDetails
         TestResultPreviousValues: TestResultPreviousValuesFieldDetails
         StepResultSubscriptionPayload: StepResultSubscriptionPayloadFieldDetails
         StepResultPreviousValues: StepResultPreviousValuesFieldDetails
      }
   }
   inputTypes: {
      fields: {
         KeyWhereUniqueInput: KeyWhereUniqueInputInputObject
         KeyUserTypeWhereInput: KeyUserTypeWhereInputInputObject
         KeyTestResultStatusWhereInput: KeyTestResultStatusWhereInputInputObject
         KeyStepResultStatusWhereInput: KeyStepResultStatusWhereInputInputObject
         KeyLanguageWhereInput: KeyLanguageWhereInputInputObject
         KeyWhereInput: KeyWhereInputInputObject
         KeyUserTypeWhereUniqueInput: KeyUserTypeWhereUniqueInputInputObject
         KeyLanguageWhereUniqueInput: KeyLanguageWhereUniqueInputInputObject
         KeyTestResultStatusWhereUniqueInput: KeyTestResultStatusWhereUniqueInputInputObject
         KeyStepResultStatusWhereUniqueInput: KeyStepResultStatusWhereUniqueInputInputObject
         MultiLanguageContentWhereUniqueInput: MultiLanguageContentWhereUniqueInputInputObject
         MultiLanguageContentWhereInput: MultiLanguageContentWhereInputInputObject
         MessageWhereUniqueInput: MessageWhereUniqueInputInputObject
         MessageWhereInput: MessageWhereInputInputObject
         CompanyWhereUniqueInput: CompanyWhereUniqueInputInputObject
         TestWhereInput: TestWhereInputInputObject
         CompanyWhereInput: CompanyWhereInputInputObject
         StepWhereInput: StepWhereInputInputObject
         MenuWhereInput: MenuWhereInputInputObject
         StepResultWhereInput: StepResultWhereInputInputObject
         TestResultWhereInput: TestResultWhereInputInputObject
         TestWhereUniqueInput: TestWhereUniqueInputInputObject
         MenuWhereUniqueInput: MenuWhereUniqueInputInputObject
         StepWhereUniqueInput: StepWhereUniqueInputInputObject
         TestResultWhereUniqueInput: TestResultWhereUniqueInputInputObject
         StepResultWhereUniqueInput: StepResultWhereUniqueInputInputObject
         KeyCreateInput: KeyCreateInputInputObject
         KeyUserTypeCreateManyInput: KeyUserTypeCreateManyInputInputObject
         KeyUserTypeCreateInput: KeyUserTypeCreateInputInputObject
         KeyTestResultStatusCreateManyInput: KeyTestResultStatusCreateManyInputInputObject
         KeyTestResultStatusCreateInput: KeyTestResultStatusCreateInputInputObject
         KeyStepResultStatusCreateManyInput: KeyStepResultStatusCreateManyInputInputObject
         KeyStepResultStatusCreateInput: KeyStepResultStatusCreateInputInputObject
         KeyLanguageCreateManyInput: KeyLanguageCreateManyInputInputObject
         KeyLanguageCreateInput: KeyLanguageCreateInputInputObject
         KeyUpdateInput: KeyUpdateInputInputObject
         KeyUserTypeUpdateManyInput: KeyUserTypeUpdateManyInputInputObject
         KeyUserTypeUpdateWithWhereUniqueNestedInput: KeyUserTypeUpdateWithWhereUniqueNestedInputInputObject
         KeyUserTypeUpdateDataInput: KeyUserTypeUpdateDataInputInputObject
         KeyUserTypeUpsertWithWhereUniqueNestedInput: KeyUserTypeUpsertWithWhereUniqueNestedInputInputObject
         KeyUserTypeScalarWhereInput: KeyUserTypeScalarWhereInputInputObject
         KeyUserTypeUpdateManyWithWhereNestedInput: KeyUserTypeUpdateManyWithWhereNestedInputInputObject
         KeyUserTypeUpdateManyDataInput: KeyUserTypeUpdateManyDataInputInputObject
         KeyTestResultStatusUpdateManyInput: KeyTestResultStatusUpdateManyInputInputObject
         KeyTestResultStatusUpdateWithWhereUniqueNestedInput: KeyTestResultStatusUpdateWithWhereUniqueNestedInputInputObject
         KeyTestResultStatusUpdateDataInput: KeyTestResultStatusUpdateDataInputInputObject
         KeyTestResultStatusUpsertWithWhereUniqueNestedInput: KeyTestResultStatusUpsertWithWhereUniqueNestedInputInputObject
         KeyTestResultStatusScalarWhereInput: KeyTestResultStatusScalarWhereInputInputObject
         KeyTestResultStatusUpdateManyWithWhereNestedInput: KeyTestResultStatusUpdateManyWithWhereNestedInputInputObject
         KeyTestResultStatusUpdateManyDataInput: KeyTestResultStatusUpdateManyDataInputInputObject
         KeyStepResultStatusUpdateManyInput: KeyStepResultStatusUpdateManyInputInputObject
         KeyStepResultStatusUpdateWithWhereUniqueNestedInput: KeyStepResultStatusUpdateWithWhereUniqueNestedInputInputObject
         KeyStepResultStatusUpdateDataInput: KeyStepResultStatusUpdateDataInputInputObject
         KeyStepResultStatusUpsertWithWhereUniqueNestedInput: KeyStepResultStatusUpsertWithWhereUniqueNestedInputInputObject
         KeyStepResultStatusScalarWhereInput: KeyStepResultStatusScalarWhereInputInputObject
         KeyStepResultStatusUpdateManyWithWhereNestedInput: KeyStepResultStatusUpdateManyWithWhereNestedInputInputObject
         KeyStepResultStatusUpdateManyDataInput: KeyStepResultStatusUpdateManyDataInputInputObject
         KeyLanguageUpdateManyInput: KeyLanguageUpdateManyInputInputObject
         KeyLanguageUpdateWithWhereUniqueNestedInput: KeyLanguageUpdateWithWhereUniqueNestedInputInputObject
         KeyLanguageUpdateDataInput: KeyLanguageUpdateDataInputInputObject
         KeyLanguageUpsertWithWhereUniqueNestedInput: KeyLanguageUpsertWithWhereUniqueNestedInputInputObject
         KeyLanguageScalarWhereInput: KeyLanguageScalarWhereInputInputObject
         KeyLanguageUpdateManyWithWhereNestedInput: KeyLanguageUpdateManyWithWhereNestedInputInputObject
         KeyLanguageUpdateManyDataInput: KeyLanguageUpdateManyDataInputInputObject
         KeyUserTypeUpdateInput: KeyUserTypeUpdateInputInputObject
         KeyUserTypeUpdateManyMutationInput: KeyUserTypeUpdateManyMutationInputInputObject
         KeyLanguageUpdateInput: KeyLanguageUpdateInputInputObject
         KeyLanguageUpdateManyMutationInput: KeyLanguageUpdateManyMutationInputInputObject
         KeyTestResultStatusUpdateInput: KeyTestResultStatusUpdateInputInputObject
         KeyTestResultStatusUpdateManyMutationInput: KeyTestResultStatusUpdateManyMutationInputInputObject
         KeyStepResultStatusUpdateInput: KeyStepResultStatusUpdateInputInputObject
         KeyStepResultStatusUpdateManyMutationInput: KeyStepResultStatusUpdateManyMutationInputInputObject
         MultiLanguageContentCreateInput: MultiLanguageContentCreateInputInputObject
         MultiLanguageContentUpdateInput: MultiLanguageContentUpdateInputInputObject
         MultiLanguageContentUpdateManyMutationInput: MultiLanguageContentUpdateManyMutationInputInputObject
         MessageCreateInput: MessageCreateInputInputObject
         MultiLanguageContentCreateOneInput: MultiLanguageContentCreateOneInputInputObject
         MessageUpdateInput: MessageUpdateInputInputObject
         MultiLanguageContentUpdateOneRequiredInput: MultiLanguageContentUpdateOneRequiredInputInputObject
         MultiLanguageContentUpdateDataInput: MultiLanguageContentUpdateDataInputInputObject
         MultiLanguageContentUpsertNestedInput: MultiLanguageContentUpsertNestedInputInputObject
         CompanyCreateInput: CompanyCreateInputInputObject
         MessageCreateOneInput: MessageCreateOneInputInputObject
         TestCreateManyWithoutCompanyInput: TestCreateManyWithoutCompanyInputInputObject
         TestCreateWithoutCompanyInput: TestCreateWithoutCompanyInputInputObject
         StepCreateManyInput: StepCreateManyInputInputObject
         StepCreateInput: StepCreateInputInputObject
         MenuCreateManyInput: MenuCreateManyInputInputObject
         MenuCreateInput: MenuCreateInputInputObject
         MenuCreateManyWithoutItemsInput: MenuCreateManyWithoutItemsInputInputObject
         MenuCreateWithoutItemsInput: MenuCreateWithoutItemsInputInputObject
         MenuCreateManyWithoutMenusInput: MenuCreateManyWithoutMenusInputInputObject
         MenuCreateWithoutMenusInput: MenuCreateWithoutMenusInputInputObject
         StepResultCreateManyWithoutParentInput: StepResultCreateManyWithoutParentInputInputObject
         StepResultCreateWithoutParentInput: StepResultCreateWithoutParentInputInputObject
         TestResultCreateOneWithoutStepsInput: TestResultCreateOneWithoutStepsInputInputObject
         TestResultCreateWithoutStepsInput: TestResultCreateWithoutStepsInputInputObject
         TestCreateOneWithoutResultsInput: TestCreateOneWithoutResultsInputInputObject
         TestCreateWithoutResultsInput: TestCreateWithoutResultsInputInputObject
         CompanyCreateOneWithoutTestsInput: CompanyCreateOneWithoutTestsInputInputObject
         CompanyCreateWithoutTestsInput: CompanyCreateWithoutTestsInputInputObject
         KeyCreateOneInput: KeyCreateOneInputInputObject
         KeyTestResultStatusCreateOneInput: KeyTestResultStatusCreateOneInputInputObject
         KeyStepResultStatusCreateOneInput: KeyStepResultStatusCreateOneInputInputObject
         TestResultCreateManyWithoutParentInput: TestResultCreateManyWithoutParentInputInputObject
         TestResultCreateWithoutParentInput: TestResultCreateWithoutParentInputInputObject
         StepResultCreateManyWithoutResultInput: StepResultCreateManyWithoutResultInputInputObject
         StepResultCreateWithoutResultInput: StepResultCreateWithoutResultInputInputObject
         StepCreateOneWithoutResultsInput: StepCreateOneWithoutResultsInputInputObject
         StepCreateWithoutResultsInput: StepCreateWithoutResultsInputInputObject
         CompanyUpdateInput: CompanyUpdateInputInputObject
         MessageUpdateOneRequiredInput: MessageUpdateOneRequiredInputInputObject
         MessageUpdateDataInput: MessageUpdateDataInputInputObject
         MessageUpsertNestedInput: MessageUpsertNestedInputInputObject
         TestUpdateManyWithoutCompanyInput: TestUpdateManyWithoutCompanyInputInputObject
         TestUpdateWithWhereUniqueWithoutCompanyInput: TestUpdateWithWhereUniqueWithoutCompanyInputInputObject
         TestUpdateWithoutCompanyDataInput: TestUpdateWithoutCompanyDataInputInputObject
         StepUpdateManyInput: StepUpdateManyInputInputObject
         StepUpdateWithWhereUniqueNestedInput: StepUpdateWithWhereUniqueNestedInputInputObject
         StepUpdateDataInput: StepUpdateDataInputInputObject
         MenuUpdateManyInput: MenuUpdateManyInputInputObject
         MenuUpdateWithWhereUniqueNestedInput: MenuUpdateWithWhereUniqueNestedInputInputObject
         MenuUpdateDataInput: MenuUpdateDataInputInputObject
         MenuUpdateManyWithoutItemsInput: MenuUpdateManyWithoutItemsInputInputObject
         MenuUpdateWithWhereUniqueWithoutItemsInput: MenuUpdateWithWhereUniqueWithoutItemsInputInputObject
         MenuUpdateWithoutItemsDataInput: MenuUpdateWithoutItemsDataInputInputObject
         MenuUpsertWithWhereUniqueWithoutItemsInput: MenuUpsertWithWhereUniqueWithoutItemsInputInputObject
         MenuScalarWhereInput: MenuScalarWhereInputInputObject
         MenuUpdateManyWithWhereNestedInput: MenuUpdateManyWithWhereNestedInputInputObject
         MenuUpdateManyDataInput: MenuUpdateManyDataInputInputObject
         MenuUpdateManyWithoutMenusInput: MenuUpdateManyWithoutMenusInputInputObject
         MenuUpdateWithWhereUniqueWithoutMenusInput: MenuUpdateWithWhereUniqueWithoutMenusInputInputObject
         MenuUpdateWithoutMenusDataInput: MenuUpdateWithoutMenusDataInputInputObject
         MenuUpsertWithWhereUniqueWithoutMenusInput: MenuUpsertWithWhereUniqueWithoutMenusInputInputObject
         MenuUpsertWithWhereUniqueNestedInput: MenuUpsertWithWhereUniqueNestedInputInputObject
         StepResultUpdateManyWithoutParentInput: StepResultUpdateManyWithoutParentInputInputObject
         StepResultUpdateWithWhereUniqueWithoutParentInput: StepResultUpdateWithWhereUniqueWithoutParentInputInputObject
         StepResultUpdateWithoutParentDataInput: StepResultUpdateWithoutParentDataInputInputObject
         TestResultUpdateOneRequiredWithoutStepsInput: TestResultUpdateOneRequiredWithoutStepsInputInputObject
         TestResultUpdateWithoutStepsDataInput: TestResultUpdateWithoutStepsDataInputInputObject
         TestUpdateOneRequiredWithoutResultsInput: TestUpdateOneRequiredWithoutResultsInputInputObject
         TestUpdateWithoutResultsDataInput: TestUpdateWithoutResultsDataInputInputObject
         CompanyUpdateOneRequiredWithoutTestsInput: CompanyUpdateOneRequiredWithoutTestsInputInputObject
         CompanyUpdateWithoutTestsDataInput: CompanyUpdateWithoutTestsDataInputInputObject
         CompanyUpsertWithoutTestsInput: CompanyUpsertWithoutTestsInputInputObject
         KeyUpdateOneRequiredInput: KeyUpdateOneRequiredInputInputObject
         KeyUpdateDataInput: KeyUpdateDataInputInputObject
         KeyUpsertNestedInput: KeyUpsertNestedInputInputObject
         TestUpsertWithoutResultsInput: TestUpsertWithoutResultsInputInputObject
         KeyTestResultStatusUpdateOneRequiredInput: KeyTestResultStatusUpdateOneRequiredInputInputObject
         KeyTestResultStatusUpsertNestedInput: KeyTestResultStatusUpsertNestedInputInputObject
         TestResultUpsertWithoutStepsInput: TestResultUpsertWithoutStepsInputInputObject
         KeyStepResultStatusUpdateOneRequiredInput: KeyStepResultStatusUpdateOneRequiredInputInputObject
         KeyStepResultStatusUpsertNestedInput: KeyStepResultStatusUpsertNestedInputInputObject
         StepResultUpsertWithWhereUniqueWithoutParentInput: StepResultUpsertWithWhereUniqueWithoutParentInputInputObject
         StepResultScalarWhereInput: StepResultScalarWhereInputInputObject
         StepResultUpdateManyWithWhereNestedInput: StepResultUpdateManyWithWhereNestedInputInputObject
         StepResultUpdateManyDataInput: StepResultUpdateManyDataInputInputObject
         StepUpsertWithWhereUniqueNestedInput: StepUpsertWithWhereUniqueNestedInputInputObject
         StepScalarWhereInput: StepScalarWhereInputInputObject
         TestResultUpdateManyWithoutParentInput: TestResultUpdateManyWithoutParentInputInputObject
         TestResultUpdateWithWhereUniqueWithoutParentInput: TestResultUpdateWithWhereUniqueWithoutParentInputInputObject
         TestResultUpdateWithoutParentDataInput: TestResultUpdateWithoutParentDataInputInputObject
         StepResultUpdateManyWithoutResultInput: StepResultUpdateManyWithoutResultInputInputObject
         StepResultUpdateWithWhereUniqueWithoutResultInput: StepResultUpdateWithWhereUniqueWithoutResultInputInputObject
         StepResultUpdateWithoutResultDataInput: StepResultUpdateWithoutResultDataInputInputObject
         StepUpdateOneRequiredWithoutResultsInput: StepUpdateOneRequiredWithoutResultsInputInputObject
         StepUpdateWithoutResultsDataInput: StepUpdateWithoutResultsDataInputInputObject
         StepUpsertWithoutResultsInput: StepUpsertWithoutResultsInputInputObject
         StepResultUpsertWithWhereUniqueWithoutResultInput: StepResultUpsertWithWhereUniqueWithoutResultInputInputObject
         TestResultUpsertWithWhereUniqueWithoutParentInput: TestResultUpsertWithWhereUniqueWithoutParentInputInputObject
         TestResultScalarWhereInput: TestResultScalarWhereInputInputObject
         TestResultUpdateManyWithWhereNestedInput: TestResultUpdateManyWithWhereNestedInputInputObject
         TestResultUpdateManyDataInput: TestResultUpdateManyDataInputInputObject
         TestUpsertWithWhereUniqueWithoutCompanyInput: TestUpsertWithWhereUniqueWithoutCompanyInputInputObject
         TestScalarWhereInput: TestScalarWhereInputInputObject
         CompanyUpdateManyMutationInput: CompanyUpdateManyMutationInputInputObject
         TestCreateInput: TestCreateInputInputObject
         TestUpdateInput: TestUpdateInputInputObject
         MenuUpdateInput: MenuUpdateInputInputObject
         MenuUpdateManyMutationInput: MenuUpdateManyMutationInputInputObject
         StepUpdateInput: StepUpdateInputInputObject
         TestResultCreateInput: TestResultCreateInputInputObject
         TestResultUpdateInput: TestResultUpdateInputInputObject
         TestResultUpdateManyMutationInput: TestResultUpdateManyMutationInputInputObject
         StepResultCreateInput: StepResultCreateInputInputObject
         StepResultUpdateInput: StepResultUpdateInputInputObject
         StepResultUpdateManyMutationInput: StepResultUpdateManyMutationInputInputObject
         KeySubscriptionWhereInput: KeySubscriptionWhereInputInputObject
         KeyUserTypeSubscriptionWhereInput: KeyUserTypeSubscriptionWhereInputInputObject
         KeyLanguageSubscriptionWhereInput: KeyLanguageSubscriptionWhereInputInputObject
         KeyTestResultStatusSubscriptionWhereInput: KeyTestResultStatusSubscriptionWhereInputInputObject
         KeyStepResultStatusSubscriptionWhereInput: KeyStepResultStatusSubscriptionWhereInputInputObject
         MultiLanguageContentSubscriptionWhereInput: MultiLanguageContentSubscriptionWhereInputInputObject
         MessageSubscriptionWhereInput: MessageSubscriptionWhereInputInputObject
         CompanySubscriptionWhereInput: CompanySubscriptionWhereInputInputObject
         TestSubscriptionWhereInput: TestSubscriptionWhereInputInputObject
         MenuSubscriptionWhereInput: MenuSubscriptionWhereInputInputObject
         StepSubscriptionWhereInput: StepSubscriptionWhereInputInputObject
         TestResultSubscriptionWhereInput: TestResultSubscriptionWhereInputInputObject
         StepResultSubscriptionWhereInput: StepResultSubscriptionWhereInputInputObject
      }
   }
   enumTypes: {
      KeyUserTypeOrderByInput: KeyUserTypeOrderByInputValues
      KeyTestResultStatusOrderByInput: KeyTestResultStatusOrderByInputValues
      KeyStepResultStatusOrderByInput: KeyStepResultStatusOrderByInputValues
      KeyLanguageOrderByInput: KeyLanguageOrderByInputValues
      KeyOrderByInput: KeyOrderByInputValues
      MultiLanguageContentOrderByInput: MultiLanguageContentOrderByInputValues
      MessageOrderByInput: MessageOrderByInputValues
      TestOrderByInput: TestOrderByInputValues
      StepOrderByInput: StepOrderByInputValues
      MenuOrderByInput: MenuOrderByInputValues
      StepResultOrderByInput: StepResultOrderByInputValues
      TestResultOrderByInput: TestResultOrderByInputValues
      CompanyOrderByInput: CompanyOrderByInputValues
      MutationType: MutationTypeValues
   }
}

// Types for Query

type QueryObject =
   | QueryFields
   | { name: 'key'; args?: QueryKeyArgs[] | false; alias?: string }
   | { name: 'keys'; args?: QueryKeysArgs[] | false; alias?: string }
   | {
        name: 'keysConnection'
        args?: QueryKeysConnectionArgs[] | false
        alias?: string
     }
   | {
        name: 'keyUserType'
        args?: QueryKeyUserTypeArgs[] | false
        alias?: string
     }
   | {
        name: 'keyUserTypes'
        args?: QueryKeyUserTypesArgs[] | false
        alias?: string
     }
   | {
        name: 'keyUserTypesConnection'
        args?: QueryKeyUserTypesConnectionArgs[] | false
        alias?: string
     }
   | {
        name: 'keyLanguage'
        args?: QueryKeyLanguageArgs[] | false
        alias?: string
     }
   | {
        name: 'keyLanguages'
        args?: QueryKeyLanguagesArgs[] | false
        alias?: string
     }
   | {
        name: 'keyLanguagesConnection'
        args?: QueryKeyLanguagesConnectionArgs[] | false
        alias?: string
     }
   | {
        name: 'keyTestResultStatus'
        args?: QueryKeyTestResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'keyTestResultStatuses'
        args?: QueryKeyTestResultStatusesArgs[] | false
        alias?: string
     }
   | {
        name: 'keyTestResultStatusesConnection'
        args?: QueryKeyTestResultStatusesConnectionArgs[] | false
        alias?: string
     }
   | {
        name: 'keyStepResultStatus'
        args?: QueryKeyStepResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'keyStepResultStatuses'
        args?: QueryKeyStepResultStatusesArgs[] | false
        alias?: string
     }
   | {
        name: 'keyStepResultStatusesConnection'
        args?: QueryKeyStepResultStatusesConnectionArgs[] | false
        alias?: string
     }
   | {
        name: 'multiLanguageContent'
        args?: QueryMultiLanguageContentArgs[] | false
        alias?: string
     }
   | {
        name: 'multiLanguageContents'
        args?: QueryMultiLanguageContentsArgs[] | false
        alias?: string
     }
   | {
        name: 'multiLanguageContentsConnection'
        args?: QueryMultiLanguageContentsConnectionArgs[] | false
        alias?: string
     }
   | { name: 'message'; args?: QueryMessageArgs[] | false; alias?: string }
   | { name: 'messages'; args?: QueryMessagesArgs[] | false; alias?: string }
   | {
        name: 'messagesConnection'
        args?: QueryMessagesConnectionArgs[] | false
        alias?: string
     }
   | { name: 'company'; args?: QueryCompanyArgs[] | false; alias?: string }
   | { name: 'companies'; args?: QueryCompaniesArgs[] | false; alias?: string }
   | {
        name: 'companiesConnection'
        args?: QueryCompaniesConnectionArgs[] | false
        alias?: string
     }
   | { name: 'test'; args?: QueryTestArgs[] | false; alias?: string }
   | { name: 'tests'; args?: QueryTestsArgs[] | false; alias?: string }
   | {
        name: 'testsConnection'
        args?: QueryTestsConnectionArgs[] | false
        alias?: string
     }
   | { name: 'menu'; args?: QueryMenuArgs[] | false; alias?: string }
   | { name: 'menus'; args?: QueryMenusArgs[] | false; alias?: string }
   | {
        name: 'menusConnection'
        args?: QueryMenusConnectionArgs[] | false
        alias?: string
     }
   | { name: 'step'; args?: QueryStepArgs[] | false; alias?: string }
   | { name: 'steps'; args?: QueryStepsArgs[] | false; alias?: string }
   | {
        name: 'stepsConnection'
        args?: QueryStepsConnectionArgs[] | false
        alias?: string
     }
   | {
        name: 'testResult'
        args?: QueryTestResultArgs[] | false
        alias?: string
     }
   | {
        name: 'testResults'
        args?: QueryTestResultsArgs[] | false
        alias?: string
     }
   | {
        name: 'testResultsConnection'
        args?: QueryTestResultsConnectionArgs[] | false
        alias?: string
     }
   | {
        name: 'stepResult'
        args?: QueryStepResultArgs[] | false
        alias?: string
     }
   | {
        name: 'stepResults'
        args?: QueryStepResultsArgs[] | false
        alias?: string
     }
   | {
        name: 'stepResultsConnection'
        args?: QueryStepResultsConnectionArgs[] | false
        alias?: string
     }

type QueryFields =
   | 'key'
   | 'keys'
   | 'keysConnection'
   | 'keyUserType'
   | 'keyUserTypes'
   | 'keyUserTypesConnection'
   | 'keyLanguage'
   | 'keyLanguages'
   | 'keyLanguagesConnection'
   | 'keyTestResultStatus'
   | 'keyTestResultStatuses'
   | 'keyTestResultStatusesConnection'
   | 'keyStepResultStatus'
   | 'keyStepResultStatuses'
   | 'keyStepResultStatusesConnection'
   | 'multiLanguageContent'
   | 'multiLanguageContents'
   | 'multiLanguageContentsConnection'
   | 'message'
   | 'messages'
   | 'messagesConnection'
   | 'company'
   | 'companies'
   | 'companiesConnection'
   | 'test'
   | 'tests'
   | 'testsConnection'
   | 'menu'
   | 'menus'
   | 'menusConnection'
   | 'step'
   | 'steps'
   | 'stepsConnection'
   | 'testResult'
   | 'testResults'
   | 'testResultsConnection'
   | 'stepResult'
   | 'stepResults'
   | 'stepResultsConnection'

type QueryKeyArgs = 'where'
type QueryKeysArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeysConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeyUserTypeArgs = 'where'
type QueryKeyUserTypesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeyUserTypesConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeyLanguageArgs = 'where'
type QueryKeyLanguagesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeyLanguagesConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeyTestResultStatusArgs = 'where'
type QueryKeyTestResultStatusesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeyTestResultStatusesConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeyStepResultStatusArgs = 'where'
type QueryKeyStepResultStatusesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryKeyStepResultStatusesConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryMultiLanguageContentArgs = 'where'
type QueryMultiLanguageContentsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryMultiLanguageContentsConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryMessageArgs = 'where'
type QueryMessagesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryMessagesConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryCompanyArgs = 'where'
type QueryCompaniesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryCompaniesConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryTestArgs = 'where'
type QueryTestsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryTestsConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryMenuArgs = 'where'
type QueryMenusArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryMenusConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryStepArgs = 'where'
type QueryStepsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryStepsConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryTestResultArgs = 'where'
type QueryTestResultsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryTestResultsConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryStepResultArgs = 'where'
type QueryStepResultsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type QueryStepResultsConnectionArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'

export interface QueryFieldDetails {
   key: {
      type: 'Key'
      args: Record<QueryKeyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: KeyWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key | null> | prisma.Key | null
   }
   keys: {
      type: 'Key'
      args: Record<QueryKeysArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyWhereInput | null
            orderBy?: prisma.KeyOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key[]> | prisma.Key[]
   }
   keysConnection: {
      type: 'KeyConnection'
      args: Record<QueryKeysConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyWhereInput | null
            orderBy?: prisma.KeyOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyConnection> | prisma.KeyConnection
   }
   keyUserType: {
      type: 'KeyUserType'
      args: Record<QueryKeyUserTypeArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: KeyUserTypeWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType | null> | prisma.KeyUserType | null
   }
   keyUserTypes: {
      type: 'KeyUserType'
      args: Record<QueryKeyUserTypesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyUserTypeWhereInput | null
            orderBy?: prisma.KeyUserTypeOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType[]> | prisma.KeyUserType[]
   }
   keyUserTypesConnection: {
      type: 'KeyUserTypeConnection'
      args: Record<QueryKeyUserTypesConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyUserTypeWhereInput | null
            orderBy?: prisma.KeyUserTypeOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserTypeConnection> | prisma.KeyUserTypeConnection
   }
   keyLanguage: {
      type: 'KeyLanguage'
      args: Record<QueryKeyLanguageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: KeyLanguageWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage | null> | prisma.KeyLanguage | null
   }
   keyLanguages: {
      type: 'KeyLanguage'
      args: Record<QueryKeyLanguagesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyLanguageWhereInput | null
            orderBy?: prisma.KeyLanguageOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage[]> | prisma.KeyLanguage[]
   }
   keyLanguagesConnection: {
      type: 'KeyLanguageConnection'
      args: Record<QueryKeyLanguagesConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyLanguageWhereInput | null
            orderBy?: prisma.KeyLanguageOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguageConnection> | prisma.KeyLanguageConnection
   }
   keyTestResultStatus: {
      type: 'KeyTestResultStatus'
      args: Record<QueryKeyTestResultStatusArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: KeyTestResultStatusWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyTestResultStatus | null>
         | prisma.KeyTestResultStatus
         | null
   }
   keyTestResultStatuses: {
      type: 'KeyTestResultStatus'
      args: Record<QueryKeyTestResultStatusesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyTestResultStatusWhereInput | null
            orderBy?: prisma.KeyTestResultStatusOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyTestResultStatus[]> | prisma.KeyTestResultStatus[]
   }
   keyTestResultStatusesConnection: {
      type: 'KeyTestResultStatusConnection'
      args: Record<
         QueryKeyTestResultStatusesConnectionArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyTestResultStatusWhereInput | null
            orderBy?: prisma.KeyTestResultStatusOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyTestResultStatusConnection>
         | prisma.KeyTestResultStatusConnection
   }
   keyStepResultStatus: {
      type: 'KeyStepResultStatus'
      args: Record<QueryKeyStepResultStatusArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: KeyStepResultStatusWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyStepResultStatus | null>
         | prisma.KeyStepResultStatus
         | null
   }
   keyStepResultStatuses: {
      type: 'KeyStepResultStatus'
      args: Record<QueryKeyStepResultStatusesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyStepResultStatusWhereInput | null
            orderBy?: prisma.KeyStepResultStatusOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyStepResultStatus[]> | prisma.KeyStepResultStatus[]
   }
   keyStepResultStatusesConnection: {
      type: 'KeyStepResultStatusConnection'
      args: Record<
         QueryKeyStepResultStatusesConnectionArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: KeyStepResultStatusWhereInput | null
            orderBy?: prisma.KeyStepResultStatusOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyStepResultStatusConnection>
         | prisma.KeyStepResultStatusConnection
   }
   multiLanguageContent: {
      type: 'MultiLanguageContent'
      args: Record<QueryMultiLanguageContentArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: MultiLanguageContentWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContent | null>
         | prisma.MultiLanguageContent
         | null
   }
   multiLanguageContents: {
      type: 'MultiLanguageContent'
      args: Record<QueryMultiLanguageContentsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: MultiLanguageContentWhereInput | null
            orderBy?: prisma.MultiLanguageContentOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContent[]>
         | prisma.MultiLanguageContent[]
   }
   multiLanguageContentsConnection: {
      type: 'MultiLanguageContentConnection'
      args: Record<
         QueryMultiLanguageContentsConnectionArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: MultiLanguageContentWhereInput | null
            orderBy?: prisma.MultiLanguageContentOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContentConnection>
         | prisma.MultiLanguageContentConnection
   }
   message: {
      type: 'Message'
      args: Record<QueryMessageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: MessageWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message | null> | prisma.Message | null
   }
   messages: {
      type: 'Message'
      args: Record<QueryMessagesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: MessageWhereInput | null
            orderBy?: prisma.MessageOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message[]> | prisma.Message[]
   }
   messagesConnection: {
      type: 'MessageConnection'
      args: Record<QueryMessagesConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: MessageWhereInput | null
            orderBy?: prisma.MessageOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MessageConnection> | prisma.MessageConnection
   }
   company: {
      type: 'Company'
      args: Record<QueryCompanyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: CompanyWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company | null> | prisma.Company | null
   }
   companies: {
      type: 'Company'
      args: Record<QueryCompaniesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: CompanyWhereInput | null
            orderBy?: prisma.CompanyOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company[]> | prisma.Company[]
   }
   companiesConnection: {
      type: 'CompanyConnection'
      args: Record<QueryCompaniesConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: CompanyWhereInput | null
            orderBy?: prisma.CompanyOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.CompanyConnection> | prisma.CompanyConnection
   }
   test: {
      type: 'Test'
      args: Record<QueryTestArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: TestWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test | null> | prisma.Test | null
   }
   tests: {
      type: 'Test'
      args: Record<QueryTestsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: TestWhereInput | null
            orderBy?: prisma.TestOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test[]> | prisma.Test[]
   }
   testsConnection: {
      type: 'TestConnection'
      args: Record<QueryTestsConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: TestWhereInput | null
            orderBy?: prisma.TestOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestConnection> | prisma.TestConnection
   }
   menu: {
      type: 'Menu'
      args: Record<QueryMenuArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: MenuWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu | null> | prisma.Menu | null
   }
   menus: {
      type: 'Menu'
      args: Record<QueryMenusArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: MenuWhereInput | null
            orderBy?: prisma.MenuOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu[]> | prisma.Menu[]
   }
   menusConnection: {
      type: 'MenuConnection'
      args: Record<QueryMenusConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: MenuWhereInput | null
            orderBy?: prisma.MenuOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MenuConnection> | prisma.MenuConnection
   }
   step: {
      type: 'Step'
      args: Record<QueryStepArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: StepWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step | null> | prisma.Step | null
   }
   steps: {
      type: 'Step'
      args: Record<QueryStepsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: StepWhereInput | null
            orderBy?: prisma.StepOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step[]> | prisma.Step[]
   }
   stepsConnection: {
      type: 'StepConnection'
      args: Record<QueryStepsConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: StepWhereInput | null
            orderBy?: prisma.StepOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepConnection> | prisma.StepConnection
   }
   testResult: {
      type: 'TestResult'
      args: Record<QueryTestResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: TestResultWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult | null> | prisma.TestResult | null
   }
   testResults: {
      type: 'TestResult'
      args: Record<QueryTestResultsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: TestResultWhereInput | null
            orderBy?: prisma.TestResultOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult[]> | prisma.TestResult[]
   }
   testResultsConnection: {
      type: 'TestResultConnection'
      args: Record<QueryTestResultsConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: TestResultWhereInput | null
            orderBy?: prisma.TestResultOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResultConnection> | prisma.TestResultConnection
   }
   stepResult: {
      type: 'StepResult'
      args: Record<QueryStepResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Query'>,
         args: { where: StepResultWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult | null> | prisma.StepResult | null
   }
   stepResults: {
      type: 'StepResult'
      args: Record<QueryStepResultsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: StepResultWhereInput | null
            orderBy?: prisma.StepResultOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult[]> | prisma.StepResult[]
   }
   stepResultsConnection: {
      type: 'StepResultConnection'
      args: Record<QueryStepResultsConnectionArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Query'>,
         args: {
            where?: StepResultWhereInput | null
            orderBy?: prisma.StepResultOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResultConnection> | prisma.StepResultConnection
   }
}

// Types for Key

type KeyObject =
   | KeyFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'userTypes'; args?: KeyUserTypesArgs[] | false; alias?: string }
   | {
        name: 'testResultStatus'
        args?: KeyTestResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'stepResultStatus'
        args?: KeyStepResultStatusArgs[] | false
        alias?: string
     }
   | { name: 'languages'; args?: KeyLanguagesArgs[] | false; alias?: string }

type KeyFields =
   | 'id'
   | 'userTypes'
   | 'testResultStatus'
   | 'stepResultStatus'
   | 'languages'

type KeyUserTypesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type KeyTestResultStatusArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type KeyStepResultStatusArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type KeyLanguagesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'

export interface KeyFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   userTypes: {
      type: 'KeyUserType'
      args: Record<KeyUserTypesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Key'>,
         args: {
            where?: KeyUserTypeWhereInput | null
            orderBy?: prisma.KeyUserTypeOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType[]> | prisma.KeyUserType[]
   }
   testResultStatus: {
      type: 'KeyTestResultStatus'
      args: Record<KeyTestResultStatusArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Key'>,
         args: {
            where?: KeyTestResultStatusWhereInput | null
            orderBy?: prisma.KeyTestResultStatusOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyTestResultStatus[]> | prisma.KeyTestResultStatus[]
   }
   stepResultStatus: {
      type: 'KeyStepResultStatus'
      args: Record<KeyStepResultStatusArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Key'>,
         args: {
            where?: KeyStepResultStatusWhereInput | null
            orderBy?: prisma.KeyStepResultStatusOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyStepResultStatus[]> | prisma.KeyStepResultStatus[]
   }
   languages: {
      type: 'KeyLanguage'
      args: Record<KeyLanguagesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Key'>,
         args: {
            where?: KeyLanguageWhereInput | null
            orderBy?: prisma.KeyLanguageOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage[]> | prisma.KeyLanguage[]
   }
}

// Types for KeyUserType

type KeyUserTypeObject =
   | KeyUserTypeFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'key'; args?: [] | false; alias?: string }

type KeyUserTypeFields = 'id' | 'key'

export interface KeyUserTypeFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   key: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyTestResultStatus

type KeyTestResultStatusObject =
   | KeyTestResultStatusFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'key'; args?: [] | false; alias?: string }

type KeyTestResultStatusFields = 'id' | 'key'

export interface KeyTestResultStatusFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   key: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyStepResultStatus

type KeyStepResultStatusObject =
   | KeyStepResultStatusFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'key'; args?: [] | false; alias?: string }

type KeyStepResultStatusFields = 'id' | 'key'

export interface KeyStepResultStatusFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   key: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyLanguage

type KeyLanguageObject =
   | KeyLanguageFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'key'; args?: [] | false; alias?: string }

type KeyLanguageFields = 'id' | 'key'

export interface KeyLanguageFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   key: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyConnection

type KeyConnectionObject =
   | KeyConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type KeyConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface KeyConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'KeyEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'KeyConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyEdge[]> | prisma.KeyEdge[]
   }
   aggregate: {
      type: 'AggregateKey'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateKey> | prisma.AggregateKey
   }
}

// Types for PageInfo

type PageInfoObject =
   | PageInfoFields
   | { name: 'hasNextPage'; args?: [] | false; alias?: string }
   | { name: 'hasPreviousPage'; args?: [] | false; alias?: string }
   | { name: 'startCursor'; args?: [] | false; alias?: string }
   | { name: 'endCursor'; args?: [] | false; alias?: string }

type PageInfoFields =
   | 'hasNextPage'
   | 'hasPreviousPage'
   | 'startCursor'
   | 'endCursor'

export interface PageInfoFieldDetails {
   hasNextPage: {
      type: 'Boolean'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   hasPreviousPage: {
      type: 'Boolean'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   startCursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
   endCursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
}

// Types for KeyEdge

type KeyEdgeObject =
   | KeyEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type KeyEdgeFields = 'node' | 'cursor'

export interface KeyEdgeFieldDetails {
   node: {
      type: 'Key'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key> | prisma.Key
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateKey

type AggregateKeyObject =
   | AggregateKeyFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateKeyFields = 'count'

export interface AggregateKeyFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyUserTypeConnection

type KeyUserTypeConnectionObject =
   | KeyUserTypeConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type KeyUserTypeConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface KeyUserTypeConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyUserTypeConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'KeyUserTypeEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'KeyUserTypeConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserTypeEdge[]> | prisma.KeyUserTypeEdge[]
   }
   aggregate: {
      type: 'AggregateKeyUserType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyUserTypeConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateKeyUserType> | prisma.AggregateKeyUserType
   }
}

// Types for KeyUserTypeEdge

type KeyUserTypeEdgeObject =
   | KeyUserTypeEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type KeyUserTypeEdgeFields = 'node' | 'cursor'

export interface KeyUserTypeEdgeFieldDetails {
   node: {
      type: 'KeyUserType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyUserTypeEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType> | prisma.KeyUserType
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateKeyUserType

type AggregateKeyUserTypeObject =
   | AggregateKeyUserTypeFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateKeyUserTypeFields = 'count'

export interface AggregateKeyUserTypeFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyLanguageConnection

type KeyLanguageConnectionObject =
   | KeyLanguageConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type KeyLanguageConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface KeyLanguageConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyLanguageConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'KeyLanguageEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'KeyLanguageConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguageEdge[]> | prisma.KeyLanguageEdge[]
   }
   aggregate: {
      type: 'AggregateKeyLanguage'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyLanguageConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateKeyLanguage> | prisma.AggregateKeyLanguage
   }
}

// Types for KeyLanguageEdge

type KeyLanguageEdgeObject =
   | KeyLanguageEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type KeyLanguageEdgeFields = 'node' | 'cursor'

export interface KeyLanguageEdgeFieldDetails {
   node: {
      type: 'KeyLanguage'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyLanguageEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage> | prisma.KeyLanguage
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateKeyLanguage

type AggregateKeyLanguageObject =
   | AggregateKeyLanguageFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateKeyLanguageFields = 'count'

export interface AggregateKeyLanguageFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyTestResultStatusConnection

type KeyTestResultStatusConnectionObject =
   | KeyTestResultStatusConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type KeyTestResultStatusConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface KeyTestResultStatusConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyTestResultStatusConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'KeyTestResultStatusEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'KeyTestResultStatusConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyTestResultStatusEdge[]>
         | prisma.KeyTestResultStatusEdge[]
   }
   aggregate: {
      type: 'AggregateKeyTestResultStatus'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyTestResultStatusConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.AggregateKeyTestResultStatus>
         | prisma.AggregateKeyTestResultStatus
   }
}

// Types for KeyTestResultStatusEdge

type KeyTestResultStatusEdgeObject =
   | KeyTestResultStatusEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type KeyTestResultStatusEdgeFields = 'node' | 'cursor'

export interface KeyTestResultStatusEdgeFieldDetails {
   node: {
      type: 'KeyTestResultStatus'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyTestResultStatusEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyTestResultStatus> | prisma.KeyTestResultStatus
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateKeyTestResultStatus

type AggregateKeyTestResultStatusObject =
   | AggregateKeyTestResultStatusFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateKeyTestResultStatusFields = 'count'

export interface AggregateKeyTestResultStatusFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyStepResultStatusConnection

type KeyStepResultStatusConnectionObject =
   | KeyStepResultStatusConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type KeyStepResultStatusConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface KeyStepResultStatusConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyStepResultStatusConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'KeyStepResultStatusEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'KeyStepResultStatusConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyStepResultStatusEdge[]>
         | prisma.KeyStepResultStatusEdge[]
   }
   aggregate: {
      type: 'AggregateKeyStepResultStatus'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyStepResultStatusConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.AggregateKeyStepResultStatus>
         | prisma.AggregateKeyStepResultStatus
   }
}

// Types for KeyStepResultStatusEdge

type KeyStepResultStatusEdgeObject =
   | KeyStepResultStatusEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type KeyStepResultStatusEdgeFields = 'node' | 'cursor'

export interface KeyStepResultStatusEdgeFieldDetails {
   node: {
      type: 'KeyStepResultStatus'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyStepResultStatusEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyStepResultStatus> | prisma.KeyStepResultStatus
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateKeyStepResultStatus

type AggregateKeyStepResultStatusObject =
   | AggregateKeyStepResultStatusFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateKeyStepResultStatusFields = 'count'

export interface AggregateKeyStepResultStatusFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for MultiLanguageContent

type MultiLanguageContentObject =
   | MultiLanguageContentFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'pt'; args?: [] | false; alias?: string }
   | { name: 'en'; args?: [] | false; alias?: string }

type MultiLanguageContentFields = 'id' | 'pt' | 'en'

export interface MultiLanguageContentFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   pt: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   en: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
}

// Types for MultiLanguageContentConnection

type MultiLanguageContentConnectionObject =
   | MultiLanguageContentConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type MultiLanguageContentConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface MultiLanguageContentConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MultiLanguageContentConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'MultiLanguageContentEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'MultiLanguageContentConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContentEdge[]>
         | prisma.MultiLanguageContentEdge[]
   }
   aggregate: {
      type: 'AggregateMultiLanguageContent'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MultiLanguageContentConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.AggregateMultiLanguageContent>
         | prisma.AggregateMultiLanguageContent
   }
}

// Types for MultiLanguageContentEdge

type MultiLanguageContentEdgeObject =
   | MultiLanguageContentEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type MultiLanguageContentEdgeFields = 'node' | 'cursor'

export interface MultiLanguageContentEdgeFieldDetails {
   node: {
      type: 'MultiLanguageContent'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MultiLanguageContentEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MultiLanguageContent> | prisma.MultiLanguageContent
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateMultiLanguageContent

type AggregateMultiLanguageContentObject =
   | AggregateMultiLanguageContentFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateMultiLanguageContentFields = 'count'

export interface AggregateMultiLanguageContentFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for Message

type MessageObject =
   | MessageFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'title'; args?: [] | false; alias?: string }
   | { name: 'message'; args?: [] | false; alias?: string }

type MessageFields = 'id' | 'title' | 'message'

export interface MessageFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   title: {
      type: 'MultiLanguageContent'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Message'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MultiLanguageContent> | prisma.MultiLanguageContent
   }
   message: {
      type: 'MultiLanguageContent'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Message'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MultiLanguageContent> | prisma.MultiLanguageContent
   }
}

// Types for MessageConnection

type MessageConnectionObject =
   | MessageConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type MessageConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface MessageConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MessageConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'MessageEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'MessageConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MessageEdge[]> | prisma.MessageEdge[]
   }
   aggregate: {
      type: 'AggregateMessage'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MessageConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateMessage> | prisma.AggregateMessage
   }
}

// Types for MessageEdge

type MessageEdgeObject =
   | MessageEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type MessageEdgeFields = 'node' | 'cursor'

export interface MessageEdgeFieldDetails {
   node: {
      type: 'Message'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MessageEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message> | prisma.Message
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateMessage

type AggregateMessageObject =
   | AggregateMessageFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateMessageFields = 'count'

export interface AggregateMessageFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for Company

type CompanyObject =
   | CompanyFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'name'; args?: [] | false; alias?: string }
   | { name: 'abbr'; args?: [] | false; alias?: string }
   | { name: 'welcome'; args?: [] | false; alias?: string }
   | { name: 'tests'; args?: CompanyTestsArgs[] | false; alias?: string }

type CompanyFields = 'id' | 'name' | 'abbr' | 'welcome' | 'tests'

type CompanyTestsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'

export interface CompanyFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   name: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   abbr: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
   welcome: {
      type: 'Message'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Company'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message> | prisma.Message
   }
   tests: {
      type: 'Test'
      args: Record<CompanyTestsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Company'>,
         args: {
            where?: TestWhereInput | null
            orderBy?: prisma.TestOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test[]> | prisma.Test[]
   }
}

// Types for Test

type TestObject =
   | TestFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'publics'; args?: TestPublicsArgs[] | false; alias?: string }
   | { name: 'languages'; args?: TestLanguagesArgs[] | false; alias?: string }
   | { name: 'instruction'; args?: [] | false; alias?: string }
   | { name: 'company'; args?: [] | false; alias?: string }
   | { name: 'title'; args?: [] | false; alias?: string }
   | { name: 'steps'; args?: TestStepsArgs[] | false; alias?: string }
   | { name: 'menus'; args?: TestMenusArgs[] | false; alias?: string }
   | { name: 'results'; args?: TestResultsArgs[] | false; alias?: string }
   | { name: 'keys'; args?: [] | false; alias?: string }

type TestFields =
   | 'id'
   | 'publics'
   | 'languages'
   | 'instruction'
   | 'company'
   | 'title'
   | 'steps'
   | 'menus'
   | 'results'
   | 'keys'

type TestPublicsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type TestLanguagesArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type TestStepsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type TestMenusArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type TestResultsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'

export interface TestFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   publics: {
      type: 'KeyUserType'
      args: Record<TestPublicsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {
            where?: KeyUserTypeWhereInput | null
            orderBy?: prisma.KeyUserTypeOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType[]> | prisma.KeyUserType[]
   }
   languages: {
      type: 'KeyLanguage'
      args: Record<TestLanguagesArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {
            where?: KeyLanguageWhereInput | null
            orderBy?: prisma.KeyLanguageOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage[]> | prisma.KeyLanguage[]
   }
   instruction: {
      type: 'Message'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message> | prisma.Message
   }
   company: {
      type: 'Company'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company> | prisma.Company
   }
   title: {
      type: 'MultiLanguageContent'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MultiLanguageContent> | prisma.MultiLanguageContent
   }
   steps: {
      type: 'Step'
      args: Record<TestStepsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {
            where?: StepWhereInput | null
            orderBy?: prisma.StepOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step[]> | prisma.Step[]
   }
   menus: {
      type: 'Menu'
      args: Record<TestMenusArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {
            where?: MenuWhereInput | null
            orderBy?: prisma.MenuOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu[]> | prisma.Menu[]
   }
   results: {
      type: 'TestResult'
      args: Record<TestResultsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {
            where?: TestResultWhereInput | null
            orderBy?: prisma.TestResultOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult[]> | prisma.TestResult[]
   }
   keys: {
      type: 'Key'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Test'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key> | prisma.Key
   }
}

// Types for Step

type StepObject =
   | StepFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'type'; args?: StepTypeArgs[] | false; alias?: string }
   | { name: 'question'; args?: [] | false; alias?: string }
   | { name: 'targets'; args?: StepTargetsArgs[] | false; alias?: string }
   | { name: 'paths'; args?: StepPathsArgs[] | false; alias?: string }
   | { name: 'results'; args?: StepResultsArgs[] | false; alias?: string }

type StepFields = 'id' | 'type' | 'question' | 'targets' | 'paths' | 'results'

type StepTypeArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type StepTargetsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type StepPathsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type StepResultsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'

export interface StepFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   type: {
      type: 'KeyUserType'
      args: Record<StepTypeArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Step'>,
         args: {
            where?: KeyUserTypeWhereInput | null
            orderBy?: prisma.KeyUserTypeOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType[]> | prisma.KeyUserType[]
   }
   question: {
      type: 'MultiLanguageContent'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Step'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MultiLanguageContent> | prisma.MultiLanguageContent
   }
   targets: {
      type: 'Menu'
      args: Record<StepTargetsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Step'>,
         args: {
            where?: MenuWhereInput | null
            orderBy?: prisma.MenuOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu[]> | prisma.Menu[]
   }
   paths: {
      type: 'Menu'
      args: Record<StepPathsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Step'>,
         args: {
            where?: MenuWhereInput | null
            orderBy?: prisma.MenuOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu[]> | prisma.Menu[]
   }
   results: {
      type: 'StepResult'
      args: Record<StepResultsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Step'>,
         args: {
            where?: StepResultWhereInput | null
            orderBy?: prisma.StepResultOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult[]> | prisma.StepResult[]
   }
}

// Types for Menu

type MenuObject =
   | MenuFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'root'; args?: [] | false; alias?: string }
   | { name: 'menus'; args?: MenuMenusArgs[] | false; alias?: string }
   | { name: 'name'; args?: [] | false; alias?: string }
   | { name: 'items'; args?: MenuItemsArgs[] | false; alias?: string }

type MenuFields = 'id' | 'root' | 'menus' | 'name' | 'items'

type MenuMenusArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'
type MenuItemsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'

export interface MenuFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   root: {
      type: 'Boolean'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   menus: {
      type: 'Menu'
      args: Record<MenuMenusArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Menu'>,
         args: {
            where?: MenuWhereInput | null
            orderBy?: prisma.MenuOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu[]> | prisma.Menu[]
   }
   name: {
      type: 'MultiLanguageContent'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Menu'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MultiLanguageContent> | prisma.MultiLanguageContent
   }
   items: {
      type: 'Menu'
      args: Record<MenuItemsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'Menu'>,
         args: {
            where?: MenuWhereInput | null
            orderBy?: prisma.MenuOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu[]> | prisma.Menu[]
   }
}

// Types for StepResult

type StepResultObject =
   | StepResultFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'parent'; args?: [] | false; alias?: string }
   | { name: 'result'; args?: [] | false; alias?: string }
   | { name: 'start'; args?: [] | false; alias?: string }
   | { name: 'end'; args?: [] | false; alias?: string }
   | { name: 'time'; args?: [] | false; alias?: string }
   | { name: 'path'; args?: StepResultPathArgs[] | false; alias?: string }
   | { name: 'status'; args?: [] | false; alias?: string }

type StepResultFields =
   | 'id'
   | 'parent'
   | 'result'
   | 'start'
   | 'end'
   | 'time'
   | 'path'
   | 'status'

type StepResultPathArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'

export interface StepResultFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   parent: {
      type: 'Step'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepResult'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step> | prisma.Step
   }
   result: {
      type: 'TestResult'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepResult'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult> | prisma.TestResult
   }
   start: {
      type: 'DateTime'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   end: {
      type: 'DateTime'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
   time: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   path: {
      type: 'Menu'
      args: Record<StepResultPathArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'StepResult'>,
         args: {
            where?: MenuWhereInput | null
            orderBy?: prisma.MenuOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu[]> | prisma.Menu[]
   }
   status: {
      type: 'KeyStepResultStatus'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepResult'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyStepResultStatus> | prisma.KeyStepResultStatus
   }
}

// Types for TestResult

type TestResultObject =
   | TestResultFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'parent'; args?: [] | false; alias?: string }
   | { name: 'start'; args?: [] | false; alias?: string }
   | { name: 'end'; args?: [] | false; alias?: string }
   | { name: 'duration'; args?: [] | false; alias?: string }
   | { name: 'steps'; args?: TestResultStepsArgs[] | false; alias?: string }
   | { name: 'status'; args?: [] | false; alias?: string }

type TestResultFields =
   | 'id'
   | 'parent'
   | 'start'
   | 'end'
   | 'duration'
   | 'steps'
   | 'status'

type TestResultStepsArgs =
   | 'where'
   | 'orderBy'
   | 'skip'
   | 'after'
   | 'before'
   | 'first'
   | 'last'

export interface TestResultFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   parent: {
      type: 'Test'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestResult'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test> | prisma.Test
   }
   start: {
      type: 'DateTime'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   end: {
      type: 'DateTime'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
   duration: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   steps: {
      type: 'StepResult'
      args: Record<TestResultStepsArgs, core.NexusArgDef<string>>
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'TestResult'>,
         args: {
            where?: StepResultWhereInput | null
            orderBy?: prisma.StepResultOrderByInput | null
            skip?: number | null
            after?: string | null
            before?: string | null
            first?: number | null
            last?: number | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult[]> | prisma.StepResult[]
   }
   status: {
      type: 'KeyTestResultStatus'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestResult'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyTestResultStatus> | prisma.KeyTestResultStatus
   }
}

// Types for CompanyConnection

type CompanyConnectionObject =
   | CompanyConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type CompanyConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface CompanyConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'CompanyConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'CompanyEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'CompanyConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.CompanyEdge[]> | prisma.CompanyEdge[]
   }
   aggregate: {
      type: 'AggregateCompany'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'CompanyConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateCompany> | prisma.AggregateCompany
   }
}

// Types for CompanyEdge

type CompanyEdgeObject =
   | CompanyEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type CompanyEdgeFields = 'node' | 'cursor'

export interface CompanyEdgeFieldDetails {
   node: {
      type: 'Company'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'CompanyEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company> | prisma.Company
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateCompany

type AggregateCompanyObject =
   | AggregateCompanyFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateCompanyFields = 'count'

export interface AggregateCompanyFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for TestConnection

type TestConnectionObject =
   | TestConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type TestConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface TestConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'TestEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'TestConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestEdge[]> | prisma.TestEdge[]
   }
   aggregate: {
      type: 'AggregateTest'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateTest> | prisma.AggregateTest
   }
}

// Types for TestEdge

type TestEdgeObject =
   | TestEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type TestEdgeFields = 'node' | 'cursor'

export interface TestEdgeFieldDetails {
   node: {
      type: 'Test'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test> | prisma.Test
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateTest

type AggregateTestObject =
   | AggregateTestFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateTestFields = 'count'

export interface AggregateTestFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for MenuConnection

type MenuConnectionObject =
   | MenuConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type MenuConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface MenuConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MenuConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'MenuEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'MenuConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MenuEdge[]> | prisma.MenuEdge[]
   }
   aggregate: {
      type: 'AggregateMenu'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MenuConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateMenu> | prisma.AggregateMenu
   }
}

// Types for MenuEdge

type MenuEdgeObject =
   | MenuEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type MenuEdgeFields = 'node' | 'cursor'

export interface MenuEdgeFieldDetails {
   node: {
      type: 'Menu'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MenuEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu> | prisma.Menu
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateMenu

type AggregateMenuObject =
   | AggregateMenuFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateMenuFields = 'count'

export interface AggregateMenuFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for StepConnection

type StepConnectionObject =
   | StepConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type StepConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface StepConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'StepEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'StepConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepEdge[]> | prisma.StepEdge[]
   }
   aggregate: {
      type: 'AggregateStep'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateStep> | prisma.AggregateStep
   }
}

// Types for StepEdge

type StepEdgeObject =
   | StepEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type StepEdgeFields = 'node' | 'cursor'

export interface StepEdgeFieldDetails {
   node: {
      type: 'Step'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step> | prisma.Step
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateStep

type AggregateStepObject =
   | AggregateStepFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateStepFields = 'count'

export interface AggregateStepFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for TestResultConnection

type TestResultConnectionObject =
   | TestResultConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type TestResultConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface TestResultConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestResultConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'TestResultEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'TestResultConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResultEdge[]> | prisma.TestResultEdge[]
   }
   aggregate: {
      type: 'AggregateTestResult'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestResultConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateTestResult> | prisma.AggregateTestResult
   }
}

// Types for TestResultEdge

type TestResultEdgeObject =
   | TestResultEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type TestResultEdgeFields = 'node' | 'cursor'

export interface TestResultEdgeFieldDetails {
   node: {
      type: 'TestResult'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestResultEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult> | prisma.TestResult
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateTestResult

type AggregateTestResultObject =
   | AggregateTestResultFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateTestResultFields = 'count'

export interface AggregateTestResultFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for StepResultConnection

type StepResultConnectionObject =
   | StepResultConnectionFields
   | { name: 'pageInfo'; args?: [] | false; alias?: string }
   | { name: 'edges'; args?: [] | false; alias?: string }
   | { name: 'aggregate'; args?: [] | false; alias?: string }

type StepResultConnectionFields = 'pageInfo' | 'edges' | 'aggregate'

export interface StepResultConnectionFieldDetails {
   pageInfo: {
      type: 'PageInfo'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepResultConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.PageInfo> | prisma.PageInfo
   }
   edges: {
      type: 'StepResultEdge'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: (
         root: core.RootValue<'StepResultConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResultEdge[]> | prisma.StepResultEdge[]
   }
   aggregate: {
      type: 'AggregateStepResult'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepResultConnection'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.AggregateStepResult> | prisma.AggregateStepResult
   }
}

// Types for StepResultEdge

type StepResultEdgeObject =
   | StepResultEdgeFields
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'cursor'; args?: [] | false; alias?: string }

type StepResultEdgeFields = 'node' | 'cursor'

export interface StepResultEdgeFieldDetails {
   node: {
      type: 'StepResult'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepResultEdge'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult> | prisma.StepResult
   }
   cursor: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for AggregateStepResult

type AggregateStepResultObject =
   | AggregateStepResultFields
   | { name: 'count'; args?: [] | false; alias?: string }

type AggregateStepResultFields = 'count'

export interface AggregateStepResultFieldDetails {
   count: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for Mutation

type MutationObject =
   | MutationFields
   | {
        name: 'createKey'
        args?: MutationCreateKeyArgs[] | false
        alias?: string
     }
   | {
        name: 'updateKey'
        args?: MutationUpdateKeyArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertKey'
        args?: MutationUpsertKeyArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteKey'
        args?: MutationDeleteKeyArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyKeys'
        args?: MutationDeleteManyKeysArgs[] | false
        alias?: string
     }
   | {
        name: 'createKeyUserType'
        args?: MutationCreateKeyUserTypeArgs[] | false
        alias?: string
     }
   | {
        name: 'updateKeyUserType'
        args?: MutationUpdateKeyUserTypeArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyKeyUserTypes'
        args?: MutationUpdateManyKeyUserTypesArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertKeyUserType'
        args?: MutationUpsertKeyUserTypeArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteKeyUserType'
        args?: MutationDeleteKeyUserTypeArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyKeyUserTypes'
        args?: MutationDeleteManyKeyUserTypesArgs[] | false
        alias?: string
     }
   | {
        name: 'createKeyLanguage'
        args?: MutationCreateKeyLanguageArgs[] | false
        alias?: string
     }
   | {
        name: 'updateKeyLanguage'
        args?: MutationUpdateKeyLanguageArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyKeyLanguages'
        args?: MutationUpdateManyKeyLanguagesArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertKeyLanguage'
        args?: MutationUpsertKeyLanguageArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteKeyLanguage'
        args?: MutationDeleteKeyLanguageArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyKeyLanguages'
        args?: MutationDeleteManyKeyLanguagesArgs[] | false
        alias?: string
     }
   | {
        name: 'createKeyTestResultStatus'
        args?: MutationCreateKeyTestResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'updateKeyTestResultStatus'
        args?: MutationUpdateKeyTestResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyKeyTestResultStatuses'
        args?: MutationUpdateManyKeyTestResultStatusesArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertKeyTestResultStatus'
        args?: MutationUpsertKeyTestResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteKeyTestResultStatus'
        args?: MutationDeleteKeyTestResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyKeyTestResultStatuses'
        args?: MutationDeleteManyKeyTestResultStatusesArgs[] | false
        alias?: string
     }
   | {
        name: 'createKeyStepResultStatus'
        args?: MutationCreateKeyStepResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'updateKeyStepResultStatus'
        args?: MutationUpdateKeyStepResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyKeyStepResultStatuses'
        args?: MutationUpdateManyKeyStepResultStatusesArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertKeyStepResultStatus'
        args?: MutationUpsertKeyStepResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteKeyStepResultStatus'
        args?: MutationDeleteKeyStepResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyKeyStepResultStatuses'
        args?: MutationDeleteManyKeyStepResultStatusesArgs[] | false
        alias?: string
     }
   | {
        name: 'createMultiLanguageContent'
        args?: MutationCreateMultiLanguageContentArgs[] | false
        alias?: string
     }
   | {
        name: 'updateMultiLanguageContent'
        args?: MutationUpdateMultiLanguageContentArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyMultiLanguageContents'
        args?: MutationUpdateManyMultiLanguageContentsArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertMultiLanguageContent'
        args?: MutationUpsertMultiLanguageContentArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteMultiLanguageContent'
        args?: MutationDeleteMultiLanguageContentArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyMultiLanguageContents'
        args?: MutationDeleteManyMultiLanguageContentsArgs[] | false
        alias?: string
     }
   | {
        name: 'createMessage'
        args?: MutationCreateMessageArgs[] | false
        alias?: string
     }
   | {
        name: 'updateMessage'
        args?: MutationUpdateMessageArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertMessage'
        args?: MutationUpsertMessageArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteMessage'
        args?: MutationDeleteMessageArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyMessages'
        args?: MutationDeleteManyMessagesArgs[] | false
        alias?: string
     }
   | {
        name: 'createCompany'
        args?: MutationCreateCompanyArgs[] | false
        alias?: string
     }
   | {
        name: 'updateCompany'
        args?: MutationUpdateCompanyArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyCompanies'
        args?: MutationUpdateManyCompaniesArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertCompany'
        args?: MutationUpsertCompanyArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteCompany'
        args?: MutationDeleteCompanyArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyCompanies'
        args?: MutationDeleteManyCompaniesArgs[] | false
        alias?: string
     }
   | {
        name: 'createTest'
        args?: MutationCreateTestArgs[] | false
        alias?: string
     }
   | {
        name: 'updateTest'
        args?: MutationUpdateTestArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertTest'
        args?: MutationUpsertTestArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteTest'
        args?: MutationDeleteTestArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyTests'
        args?: MutationDeleteManyTestsArgs[] | false
        alias?: string
     }
   | {
        name: 'createMenu'
        args?: MutationCreateMenuArgs[] | false
        alias?: string
     }
   | {
        name: 'updateMenu'
        args?: MutationUpdateMenuArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyMenus'
        args?: MutationUpdateManyMenusArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertMenu'
        args?: MutationUpsertMenuArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteMenu'
        args?: MutationDeleteMenuArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyMenus'
        args?: MutationDeleteManyMenusArgs[] | false
        alias?: string
     }
   | {
        name: 'createStep'
        args?: MutationCreateStepArgs[] | false
        alias?: string
     }
   | {
        name: 'updateStep'
        args?: MutationUpdateStepArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertStep'
        args?: MutationUpsertStepArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteStep'
        args?: MutationDeleteStepArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManySteps'
        args?: MutationDeleteManyStepsArgs[] | false
        alias?: string
     }
   | {
        name: 'createTestResult'
        args?: MutationCreateTestResultArgs[] | false
        alias?: string
     }
   | {
        name: 'updateTestResult'
        args?: MutationUpdateTestResultArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyTestResults'
        args?: MutationUpdateManyTestResultsArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertTestResult'
        args?: MutationUpsertTestResultArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteTestResult'
        args?: MutationDeleteTestResultArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyTestResults'
        args?: MutationDeleteManyTestResultsArgs[] | false
        alias?: string
     }
   | {
        name: 'createStepResult'
        args?: MutationCreateStepResultArgs[] | false
        alias?: string
     }
   | {
        name: 'updateStepResult'
        args?: MutationUpdateStepResultArgs[] | false
        alias?: string
     }
   | {
        name: 'updateManyStepResults'
        args?: MutationUpdateManyStepResultsArgs[] | false
        alias?: string
     }
   | {
        name: 'upsertStepResult'
        args?: MutationUpsertStepResultArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteStepResult'
        args?: MutationDeleteStepResultArgs[] | false
        alias?: string
     }
   | {
        name: 'deleteManyStepResults'
        args?: MutationDeleteManyStepResultsArgs[] | false
        alias?: string
     }

type MutationFields =
   | 'createKey'
   | 'updateKey'
   | 'upsertKey'
   | 'deleteKey'
   | 'deleteManyKeys'
   | 'createKeyUserType'
   | 'updateKeyUserType'
   | 'updateManyKeyUserTypes'
   | 'upsertKeyUserType'
   | 'deleteKeyUserType'
   | 'deleteManyKeyUserTypes'
   | 'createKeyLanguage'
   | 'updateKeyLanguage'
   | 'updateManyKeyLanguages'
   | 'upsertKeyLanguage'
   | 'deleteKeyLanguage'
   | 'deleteManyKeyLanguages'
   | 'createKeyTestResultStatus'
   | 'updateKeyTestResultStatus'
   | 'updateManyKeyTestResultStatuses'
   | 'upsertKeyTestResultStatus'
   | 'deleteKeyTestResultStatus'
   | 'deleteManyKeyTestResultStatuses'
   | 'createKeyStepResultStatus'
   | 'updateKeyStepResultStatus'
   | 'updateManyKeyStepResultStatuses'
   | 'upsertKeyStepResultStatus'
   | 'deleteKeyStepResultStatus'
   | 'deleteManyKeyStepResultStatuses'
   | 'createMultiLanguageContent'
   | 'updateMultiLanguageContent'
   | 'updateManyMultiLanguageContents'
   | 'upsertMultiLanguageContent'
   | 'deleteMultiLanguageContent'
   | 'deleteManyMultiLanguageContents'
   | 'createMessage'
   | 'updateMessage'
   | 'upsertMessage'
   | 'deleteMessage'
   | 'deleteManyMessages'
   | 'createCompany'
   | 'updateCompany'
   | 'updateManyCompanies'
   | 'upsertCompany'
   | 'deleteCompany'
   | 'deleteManyCompanies'
   | 'createTest'
   | 'updateTest'
   | 'upsertTest'
   | 'deleteTest'
   | 'deleteManyTests'
   | 'createMenu'
   | 'updateMenu'
   | 'updateManyMenus'
   | 'upsertMenu'
   | 'deleteMenu'
   | 'deleteManyMenus'
   | 'createStep'
   | 'updateStep'
   | 'upsertStep'
   | 'deleteStep'
   | 'deleteManySteps'
   | 'createTestResult'
   | 'updateTestResult'
   | 'updateManyTestResults'
   | 'upsertTestResult'
   | 'deleteTestResult'
   | 'deleteManyTestResults'
   | 'createStepResult'
   | 'updateStepResult'
   | 'updateManyStepResults'
   | 'upsertStepResult'
   | 'deleteStepResult'
   | 'deleteManyStepResults'

type MutationCreateKeyArgs = 'data'
type MutationUpdateKeyArgs = 'data' | 'where'
type MutationUpsertKeyArgs = 'where' | 'create' | 'update'
type MutationDeleteKeyArgs = 'where'
type MutationDeleteManyKeysArgs = 'where'
type MutationCreateKeyUserTypeArgs = 'data'
type MutationUpdateKeyUserTypeArgs = 'data' | 'where'
type MutationUpdateManyKeyUserTypesArgs = 'data' | 'where'
type MutationUpsertKeyUserTypeArgs = 'where' | 'create' | 'update'
type MutationDeleteKeyUserTypeArgs = 'where'
type MutationDeleteManyKeyUserTypesArgs = 'where'
type MutationCreateKeyLanguageArgs = 'data'
type MutationUpdateKeyLanguageArgs = 'data' | 'where'
type MutationUpdateManyKeyLanguagesArgs = 'data' | 'where'
type MutationUpsertKeyLanguageArgs = 'where' | 'create' | 'update'
type MutationDeleteKeyLanguageArgs = 'where'
type MutationDeleteManyKeyLanguagesArgs = 'where'
type MutationCreateKeyTestResultStatusArgs = 'data'
type MutationUpdateKeyTestResultStatusArgs = 'data' | 'where'
type MutationUpdateManyKeyTestResultStatusesArgs = 'data' | 'where'
type MutationUpsertKeyTestResultStatusArgs = 'where' | 'create' | 'update'
type MutationDeleteKeyTestResultStatusArgs = 'where'
type MutationDeleteManyKeyTestResultStatusesArgs = 'where'
type MutationCreateKeyStepResultStatusArgs = 'data'
type MutationUpdateKeyStepResultStatusArgs = 'data' | 'where'
type MutationUpdateManyKeyStepResultStatusesArgs = 'data' | 'where'
type MutationUpsertKeyStepResultStatusArgs = 'where' | 'create' | 'update'
type MutationDeleteKeyStepResultStatusArgs = 'where'
type MutationDeleteManyKeyStepResultStatusesArgs = 'where'
type MutationCreateMultiLanguageContentArgs = 'data'
type MutationUpdateMultiLanguageContentArgs = 'data' | 'where'
type MutationUpdateManyMultiLanguageContentsArgs = 'data' | 'where'
type MutationUpsertMultiLanguageContentArgs = 'where' | 'create' | 'update'
type MutationDeleteMultiLanguageContentArgs = 'where'
type MutationDeleteManyMultiLanguageContentsArgs = 'where'
type MutationCreateMessageArgs = 'data'
type MutationUpdateMessageArgs = 'data' | 'where'
type MutationUpsertMessageArgs = 'where' | 'create' | 'update'
type MutationDeleteMessageArgs = 'where'
type MutationDeleteManyMessagesArgs = 'where'
type MutationCreateCompanyArgs = 'data'
type MutationUpdateCompanyArgs = 'data' | 'where'
type MutationUpdateManyCompaniesArgs = 'data' | 'where'
type MutationUpsertCompanyArgs = 'where' | 'create' | 'update'
type MutationDeleteCompanyArgs = 'where'
type MutationDeleteManyCompaniesArgs = 'where'
type MutationCreateTestArgs = 'data'
type MutationUpdateTestArgs = 'data' | 'where'
type MutationUpsertTestArgs = 'where' | 'create' | 'update'
type MutationDeleteTestArgs = 'where'
type MutationDeleteManyTestsArgs = 'where'
type MutationCreateMenuArgs = 'data'
type MutationUpdateMenuArgs = 'data' | 'where'
type MutationUpdateManyMenusArgs = 'data' | 'where'
type MutationUpsertMenuArgs = 'where' | 'create' | 'update'
type MutationDeleteMenuArgs = 'where'
type MutationDeleteManyMenusArgs = 'where'
type MutationCreateStepArgs = 'data'
type MutationUpdateStepArgs = 'data' | 'where'
type MutationUpsertStepArgs = 'where' | 'create' | 'update'
type MutationDeleteStepArgs = 'where'
type MutationDeleteManyStepsArgs = 'where'
type MutationCreateTestResultArgs = 'data'
type MutationUpdateTestResultArgs = 'data' | 'where'
type MutationUpdateManyTestResultsArgs = 'data' | 'where'
type MutationUpsertTestResultArgs = 'where' | 'create' | 'update'
type MutationDeleteTestResultArgs = 'where'
type MutationDeleteManyTestResultsArgs = 'where'
type MutationCreateStepResultArgs = 'data'
type MutationUpdateStepResultArgs = 'data' | 'where'
type MutationUpdateManyStepResultsArgs = 'data' | 'where'
type MutationUpsertStepResultArgs = 'where' | 'create' | 'update'
type MutationDeleteStepResultArgs = 'where'
type MutationDeleteManyStepResultsArgs = 'where'

export interface MutationFieldDetails {
   createKey: {
      type: 'Key'
      args: Record<MutationCreateKeyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: KeyCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key> | prisma.Key
   }
   updateKey: {
      type: 'Key'
      args: Record<MutationUpdateKeyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: KeyUpdateInput; where: KeyWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key | null> | prisma.Key | null
   }
   upsertKey: {
      type: 'Key'
      args: Record<MutationUpsertKeyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: KeyWhereUniqueInput
            create: KeyCreateInput
            update: KeyUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key> | prisma.Key
   }
   deleteKey: {
      type: 'Key'
      args: Record<MutationDeleteKeyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: KeyWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key | null> | prisma.Key | null
   }
   deleteManyKeys: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyKeysArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: KeyWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createKeyUserType: {
      type: 'KeyUserType'
      args: Record<MutationCreateKeyUserTypeArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: KeyUserTypeCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType> | prisma.KeyUserType
   }
   updateKeyUserType: {
      type: 'KeyUserType'
      args: Record<MutationUpdateKeyUserTypeArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: KeyUserTypeUpdateInput
            where: KeyUserTypeWhereUniqueInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType | null> | prisma.KeyUserType | null
   }
   updateManyKeyUserTypes: {
      type: 'BatchPayload'
      args: Record<MutationUpdateManyKeyUserTypesArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: KeyUserTypeUpdateManyMutationInput
            where?: KeyUserTypeWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertKeyUserType: {
      type: 'KeyUserType'
      args: Record<MutationUpsertKeyUserTypeArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: KeyUserTypeWhereUniqueInput
            create: KeyUserTypeCreateInput
            update: KeyUserTypeUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType> | prisma.KeyUserType
   }
   deleteKeyUserType: {
      type: 'KeyUserType'
      args: Record<MutationDeleteKeyUserTypeArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: KeyUserTypeWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType | null> | prisma.KeyUserType | null
   }
   deleteManyKeyUserTypes: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyKeyUserTypesArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: KeyUserTypeWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createKeyLanguage: {
      type: 'KeyLanguage'
      args: Record<MutationCreateKeyLanguageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: KeyLanguageCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage> | prisma.KeyLanguage
   }
   updateKeyLanguage: {
      type: 'KeyLanguage'
      args: Record<MutationUpdateKeyLanguageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: KeyLanguageUpdateInput
            where: KeyLanguageWhereUniqueInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage | null> | prisma.KeyLanguage | null
   }
   updateManyKeyLanguages: {
      type: 'BatchPayload'
      args: Record<MutationUpdateManyKeyLanguagesArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: KeyLanguageUpdateManyMutationInput
            where?: KeyLanguageWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertKeyLanguage: {
      type: 'KeyLanguage'
      args: Record<MutationUpsertKeyLanguageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: KeyLanguageWhereUniqueInput
            create: KeyLanguageCreateInput
            update: KeyLanguageUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage> | prisma.KeyLanguage
   }
   deleteKeyLanguage: {
      type: 'KeyLanguage'
      args: Record<MutationDeleteKeyLanguageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: KeyLanguageWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage | null> | prisma.KeyLanguage | null
   }
   deleteManyKeyLanguages: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyKeyLanguagesArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: KeyLanguageWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createKeyTestResultStatus: {
      type: 'KeyTestResultStatus'
      args: Record<
         MutationCreateKeyTestResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: KeyTestResultStatusCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyTestResultStatus> | prisma.KeyTestResultStatus
   }
   updateKeyTestResultStatus: {
      type: 'KeyTestResultStatus'
      args: Record<
         MutationUpdateKeyTestResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: KeyTestResultStatusUpdateInput
            where: KeyTestResultStatusWhereUniqueInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyTestResultStatus | null>
         | prisma.KeyTestResultStatus
         | null
   }
   updateManyKeyTestResultStatuses: {
      type: 'BatchPayload'
      args: Record<
         MutationUpdateManyKeyTestResultStatusesArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: KeyTestResultStatusUpdateManyMutationInput
            where?: KeyTestResultStatusWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertKeyTestResultStatus: {
      type: 'KeyTestResultStatus'
      args: Record<
         MutationUpsertKeyTestResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: KeyTestResultStatusWhereUniqueInput
            create: KeyTestResultStatusCreateInput
            update: KeyTestResultStatusUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyTestResultStatus> | prisma.KeyTestResultStatus
   }
   deleteKeyTestResultStatus: {
      type: 'KeyTestResultStatus'
      args: Record<
         MutationDeleteKeyTestResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: KeyTestResultStatusWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyTestResultStatus | null>
         | prisma.KeyTestResultStatus
         | null
   }
   deleteManyKeyTestResultStatuses: {
      type: 'BatchPayload'
      args: Record<
         MutationDeleteManyKeyTestResultStatusesArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: KeyTestResultStatusWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createKeyStepResultStatus: {
      type: 'KeyStepResultStatus'
      args: Record<
         MutationCreateKeyStepResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: KeyStepResultStatusCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyStepResultStatus> | prisma.KeyStepResultStatus
   }
   updateKeyStepResultStatus: {
      type: 'KeyStepResultStatus'
      args: Record<
         MutationUpdateKeyStepResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: KeyStepResultStatusUpdateInput
            where: KeyStepResultStatusWhereUniqueInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyStepResultStatus | null>
         | prisma.KeyStepResultStatus
         | null
   }
   updateManyKeyStepResultStatuses: {
      type: 'BatchPayload'
      args: Record<
         MutationUpdateManyKeyStepResultStatusesArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: KeyStepResultStatusUpdateManyMutationInput
            where?: KeyStepResultStatusWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertKeyStepResultStatus: {
      type: 'KeyStepResultStatus'
      args: Record<
         MutationUpsertKeyStepResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: KeyStepResultStatusWhereUniqueInput
            create: KeyStepResultStatusCreateInput
            update: KeyStepResultStatusUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyStepResultStatus> | prisma.KeyStepResultStatus
   }
   deleteKeyStepResultStatus: {
      type: 'KeyStepResultStatus'
      args: Record<
         MutationDeleteKeyStepResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: KeyStepResultStatusWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyStepResultStatus | null>
         | prisma.KeyStepResultStatus
         | null
   }
   deleteManyKeyStepResultStatuses: {
      type: 'BatchPayload'
      args: Record<
         MutationDeleteManyKeyStepResultStatusesArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: KeyStepResultStatusWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createMultiLanguageContent: {
      type: 'MultiLanguageContent'
      args: Record<
         MutationCreateMultiLanguageContentArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: MultiLanguageContentCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MultiLanguageContent> | prisma.MultiLanguageContent
   }
   updateMultiLanguageContent: {
      type: 'MultiLanguageContent'
      args: Record<
         MutationUpdateMultiLanguageContentArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: MultiLanguageContentUpdateInput
            where: MultiLanguageContentWhereUniqueInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContent | null>
         | prisma.MultiLanguageContent
         | null
   }
   updateManyMultiLanguageContents: {
      type: 'BatchPayload'
      args: Record<
         MutationUpdateManyMultiLanguageContentsArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: MultiLanguageContentUpdateManyMutationInput
            where?: MultiLanguageContentWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertMultiLanguageContent: {
      type: 'MultiLanguageContent'
      args: Record<
         MutationUpsertMultiLanguageContentArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: MultiLanguageContentWhereUniqueInput
            create: MultiLanguageContentCreateInput
            update: MultiLanguageContentUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MultiLanguageContent> | prisma.MultiLanguageContent
   }
   deleteMultiLanguageContent: {
      type: 'MultiLanguageContent'
      args: Record<
         MutationDeleteMultiLanguageContentArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: MultiLanguageContentWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContent | null>
         | prisma.MultiLanguageContent
         | null
   }
   deleteManyMultiLanguageContents: {
      type: 'BatchPayload'
      args: Record<
         MutationDeleteManyMultiLanguageContentsArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: MultiLanguageContentWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createMessage: {
      type: 'Message'
      args: Record<MutationCreateMessageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: MessageCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message> | prisma.Message
   }
   updateMessage: {
      type: 'Message'
      args: Record<MutationUpdateMessageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: MessageUpdateInput; where: MessageWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message | null> | prisma.Message | null
   }
   upsertMessage: {
      type: 'Message'
      args: Record<MutationUpsertMessageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: MessageWhereUniqueInput
            create: MessageCreateInput
            update: MessageUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message> | prisma.Message
   }
   deleteMessage: {
      type: 'Message'
      args: Record<MutationDeleteMessageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: MessageWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message | null> | prisma.Message | null
   }
   deleteManyMessages: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyMessagesArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: MessageWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createCompany: {
      type: 'Company'
      args: Record<MutationCreateCompanyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: CompanyCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company> | prisma.Company
   }
   updateCompany: {
      type: 'Company'
      args: Record<MutationUpdateCompanyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: CompanyUpdateInput; where: CompanyWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company | null> | prisma.Company | null
   }
   updateManyCompanies: {
      type: 'BatchPayload'
      args: Record<MutationUpdateManyCompaniesArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: CompanyUpdateManyMutationInput
            where?: CompanyWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertCompany: {
      type: 'Company'
      args: Record<MutationUpsertCompanyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: CompanyWhereUniqueInput
            create: CompanyCreateInput
            update: CompanyUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company> | prisma.Company
   }
   deleteCompany: {
      type: 'Company'
      args: Record<MutationDeleteCompanyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: CompanyWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company | null> | prisma.Company | null
   }
   deleteManyCompanies: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyCompaniesArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: CompanyWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createTest: {
      type: 'Test'
      args: Record<MutationCreateTestArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: TestCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test> | prisma.Test
   }
   updateTest: {
      type: 'Test'
      args: Record<MutationUpdateTestArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: TestUpdateInput; where: TestWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test | null> | prisma.Test | null
   }
   upsertTest: {
      type: 'Test'
      args: Record<MutationUpsertTestArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: TestWhereUniqueInput
            create: TestCreateInput
            update: TestUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test> | prisma.Test
   }
   deleteTest: {
      type: 'Test'
      args: Record<MutationDeleteTestArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: TestWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test | null> | prisma.Test | null
   }
   deleteManyTests: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyTestsArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: TestWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createMenu: {
      type: 'Menu'
      args: Record<MutationCreateMenuArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: MenuCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu> | prisma.Menu
   }
   updateMenu: {
      type: 'Menu'
      args: Record<MutationUpdateMenuArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: MenuUpdateInput; where: MenuWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu | null> | prisma.Menu | null
   }
   updateManyMenus: {
      type: 'BatchPayload'
      args: Record<MutationUpdateManyMenusArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: MenuUpdateManyMutationInput
            where?: MenuWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertMenu: {
      type: 'Menu'
      args: Record<MutationUpsertMenuArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: MenuWhereUniqueInput
            create: MenuCreateInput
            update: MenuUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu> | prisma.Menu
   }
   deleteMenu: {
      type: 'Menu'
      args: Record<MutationDeleteMenuArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: MenuWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu | null> | prisma.Menu | null
   }
   deleteManyMenus: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyMenusArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: MenuWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createStep: {
      type: 'Step'
      args: Record<MutationCreateStepArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: StepCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step> | prisma.Step
   }
   updateStep: {
      type: 'Step'
      args: Record<MutationUpdateStepArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: StepUpdateInput; where: StepWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step | null> | prisma.Step | null
   }
   upsertStep: {
      type: 'Step'
      args: Record<MutationUpsertStepArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: StepWhereUniqueInput
            create: StepCreateInput
            update: StepUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step> | prisma.Step
   }
   deleteStep: {
      type: 'Step'
      args: Record<MutationDeleteStepArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: StepWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step | null> | prisma.Step | null
   }
   deleteManySteps: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyStepsArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: StepWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createTestResult: {
      type: 'TestResult'
      args: Record<MutationCreateTestResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: TestResultCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult> | prisma.TestResult
   }
   updateTestResult: {
      type: 'TestResult'
      args: Record<MutationUpdateTestResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: TestResultUpdateInput
            where: TestResultWhereUniqueInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult | null> | prisma.TestResult | null
   }
   updateManyTestResults: {
      type: 'BatchPayload'
      args: Record<MutationUpdateManyTestResultsArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: TestResultUpdateManyMutationInput
            where?: TestResultWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertTestResult: {
      type: 'TestResult'
      args: Record<MutationUpsertTestResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: TestResultWhereUniqueInput
            create: TestResultCreateInput
            update: TestResultUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult> | prisma.TestResult
   }
   deleteTestResult: {
      type: 'TestResult'
      args: Record<MutationDeleteTestResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: TestResultWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult | null> | prisma.TestResult | null
   }
   deleteManyTestResults: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyTestResultsArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: TestResultWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   createStepResult: {
      type: 'StepResult'
      args: Record<MutationCreateStepResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { data: StepResultCreateInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult> | prisma.StepResult
   }
   updateStepResult: {
      type: 'StepResult'
      args: Record<MutationUpdateStepResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: StepResultUpdateInput
            where: StepResultWhereUniqueInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult | null> | prisma.StepResult | null
   }
   updateManyStepResults: {
      type: 'BatchPayload'
      args: Record<MutationUpdateManyStepResultsArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            data: StepResultUpdateManyMutationInput
            where?: StepResultWhereInput | null
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
   upsertStepResult: {
      type: 'StepResult'
      args: Record<MutationUpsertStepResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: {
            where: StepResultWhereUniqueInput
            create: StepResultCreateInput
            update: StepResultUpdateInput
         },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult> | prisma.StepResult
   }
   deleteStepResult: {
      type: 'StepResult'
      args: Record<MutationDeleteStepResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where: StepResultWhereUniqueInput },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult | null> | prisma.StepResult | null
   }
   deleteManyStepResults: {
      type: 'BatchPayload'
      args: Record<MutationDeleteManyStepResultsArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'Mutation'>,
         args: { where?: StepResultWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
   }
}

// Types for BatchPayload

type BatchPayloadObject =
   | BatchPayloadFields
   | { name: 'count'; args?: [] | false; alias?: string }

type BatchPayloadFields = 'count'

export interface BatchPayloadFieldDetails {
   count: {
      type: 'Long'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for Subscription

type SubscriptionObject =
   | SubscriptionFields
   | { name: 'key'; args?: SubscriptionKeyArgs[] | false; alias?: string }
   | {
        name: 'keyUserType'
        args?: SubscriptionKeyUserTypeArgs[] | false
        alias?: string
     }
   | {
        name: 'keyLanguage'
        args?: SubscriptionKeyLanguageArgs[] | false
        alias?: string
     }
   | {
        name: 'keyTestResultStatus'
        args?: SubscriptionKeyTestResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'keyStepResultStatus'
        args?: SubscriptionKeyStepResultStatusArgs[] | false
        alias?: string
     }
   | {
        name: 'multiLanguageContent'
        args?: SubscriptionMultiLanguageContentArgs[] | false
        alias?: string
     }
   | {
        name: 'message'
        args?: SubscriptionMessageArgs[] | false
        alias?: string
     }
   | {
        name: 'company'
        args?: SubscriptionCompanyArgs[] | false
        alias?: string
     }
   | { name: 'test'; args?: SubscriptionTestArgs[] | false; alias?: string }
   | { name: 'menu'; args?: SubscriptionMenuArgs[] | false; alias?: string }
   | { name: 'step'; args?: SubscriptionStepArgs[] | false; alias?: string }
   | {
        name: 'testResult'
        args?: SubscriptionTestResultArgs[] | false
        alias?: string
     }
   | {
        name: 'stepResult'
        args?: SubscriptionStepResultArgs[] | false
        alias?: string
     }

type SubscriptionFields =
   | 'key'
   | 'keyUserType'
   | 'keyLanguage'
   | 'keyTestResultStatus'
   | 'keyStepResultStatus'
   | 'multiLanguageContent'
   | 'message'
   | 'company'
   | 'test'
   | 'menu'
   | 'step'
   | 'testResult'
   | 'stepResult'

type SubscriptionKeyArgs = 'where'
type SubscriptionKeyUserTypeArgs = 'where'
type SubscriptionKeyLanguageArgs = 'where'
type SubscriptionKeyTestResultStatusArgs = 'where'
type SubscriptionKeyStepResultStatusArgs = 'where'
type SubscriptionMultiLanguageContentArgs = 'where'
type SubscriptionMessageArgs = 'where'
type SubscriptionCompanyArgs = 'where'
type SubscriptionTestArgs = 'where'
type SubscriptionMenuArgs = 'where'
type SubscriptionStepArgs = 'where'
type SubscriptionTestResultArgs = 'where'
type SubscriptionStepResultArgs = 'where'

export interface SubscriptionFieldDetails {
   key: {
      type: 'KeySubscriptionPayload'
      args: Record<SubscriptionKeyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: KeySubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeySubscriptionPayload | null>
         | prisma.KeySubscriptionPayload
         | null
   }
   keyUserType: {
      type: 'KeyUserTypeSubscriptionPayload'
      args: Record<SubscriptionKeyUserTypeArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: KeyUserTypeSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyUserTypeSubscriptionPayload | null>
         | prisma.KeyUserTypeSubscriptionPayload
         | null
   }
   keyLanguage: {
      type: 'KeyLanguageSubscriptionPayload'
      args: Record<SubscriptionKeyLanguageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: KeyLanguageSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyLanguageSubscriptionPayload | null>
         | prisma.KeyLanguageSubscriptionPayload
         | null
   }
   keyTestResultStatus: {
      type: 'KeyTestResultStatusSubscriptionPayload'
      args: Record<
         SubscriptionKeyTestResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: KeyTestResultStatusSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyTestResultStatusSubscriptionPayload | null>
         | prisma.KeyTestResultStatusSubscriptionPayload
         | null
   }
   keyStepResultStatus: {
      type: 'KeyStepResultStatusSubscriptionPayload'
      args: Record<
         SubscriptionKeyStepResultStatusArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: KeyStepResultStatusSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyStepResultStatusSubscriptionPayload | null>
         | prisma.KeyStepResultStatusSubscriptionPayload
         | null
   }
   multiLanguageContent: {
      type: 'MultiLanguageContentSubscriptionPayload'
      args: Record<
         SubscriptionMultiLanguageContentArgs,
         core.NexusArgDef<string>
      >
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: MultiLanguageContentSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContentSubscriptionPayload | null>
         | prisma.MultiLanguageContentSubscriptionPayload
         | null
   }
   message: {
      type: 'MessageSubscriptionPayload'
      args: Record<SubscriptionMessageArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: MessageSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MessageSubscriptionPayload | null>
         | prisma.MessageSubscriptionPayload
         | null
   }
   company: {
      type: 'CompanySubscriptionPayload'
      args: Record<SubscriptionCompanyArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: CompanySubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.CompanySubscriptionPayload | null>
         | prisma.CompanySubscriptionPayload
         | null
   }
   test: {
      type: 'TestSubscriptionPayload'
      args: Record<SubscriptionTestArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: TestSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.TestSubscriptionPayload | null>
         | prisma.TestSubscriptionPayload
         | null
   }
   menu: {
      type: 'MenuSubscriptionPayload'
      args: Record<SubscriptionMenuArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: MenuSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MenuSubscriptionPayload | null>
         | prisma.MenuSubscriptionPayload
         | null
   }
   step: {
      type: 'StepSubscriptionPayload'
      args: Record<SubscriptionStepArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: StepSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.StepSubscriptionPayload | null>
         | prisma.StepSubscriptionPayload
         | null
   }
   testResult: {
      type: 'TestResultSubscriptionPayload'
      args: Record<SubscriptionTestResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: TestResultSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.TestResultSubscriptionPayload | null>
         | prisma.TestResultSubscriptionPayload
         | null
   }
   stepResult: {
      type: 'StepResultSubscriptionPayload'
      args: Record<SubscriptionStepResultArgs, core.NexusArgDef<string>>
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'Subscription'>,
         args: { where?: StepResultSubscriptionWhereInput | null },
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.StepResultSubscriptionPayload | null>
         | prisma.StepResultSubscriptionPayload
         | null
   }
}

// Types for KeySubscriptionPayload

type KeySubscriptionPayloadObject =
   | KeySubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type KeySubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface KeySubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeySubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'Key'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeySubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Key | null> | prisma.Key | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'KeyPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeySubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyPreviousValues | null>
         | prisma.KeyPreviousValues
         | null
   }
}

// Types for KeyPreviousValues

type KeyPreviousValuesObject =
   | KeyPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }

type KeyPreviousValuesFields = 'id'

export interface KeyPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyUserTypeSubscriptionPayload

type KeyUserTypeSubscriptionPayloadObject =
   | KeyUserTypeSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type KeyUserTypeSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface KeyUserTypeSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyUserTypeSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'KeyUserType'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeyUserTypeSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyUserType | null> | prisma.KeyUserType | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'KeyUserTypePreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeyUserTypeSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyUserTypePreviousValues | null>
         | prisma.KeyUserTypePreviousValues
         | null
   }
}

// Types for KeyUserTypePreviousValues

type KeyUserTypePreviousValuesObject =
   | KeyUserTypePreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'key'; args?: [] | false; alias?: string }

type KeyUserTypePreviousValuesFields = 'id' | 'key'

export interface KeyUserTypePreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   key: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyLanguageSubscriptionPayload

type KeyLanguageSubscriptionPayloadObject =
   | KeyLanguageSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type KeyLanguageSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface KeyLanguageSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyLanguageSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'KeyLanguage'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeyLanguageSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.KeyLanguage | null> | prisma.KeyLanguage | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'KeyLanguagePreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeyLanguageSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyLanguagePreviousValues | null>
         | prisma.KeyLanguagePreviousValues
         | null
   }
}

// Types for KeyLanguagePreviousValues

type KeyLanguagePreviousValuesObject =
   | KeyLanguagePreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'key'; args?: [] | false; alias?: string }

type KeyLanguagePreviousValuesFields = 'id' | 'key'

export interface KeyLanguagePreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   key: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyTestResultStatusSubscriptionPayload

type KeyTestResultStatusSubscriptionPayloadObject =
   | KeyTestResultStatusSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type KeyTestResultStatusSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface KeyTestResultStatusSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyTestResultStatusSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'KeyTestResultStatus'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeyTestResultStatusSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyTestResultStatus | null>
         | prisma.KeyTestResultStatus
         | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'KeyTestResultStatusPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeyTestResultStatusSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyTestResultStatusPreviousValues | null>
         | prisma.KeyTestResultStatusPreviousValues
         | null
   }
}

// Types for KeyTestResultStatusPreviousValues

type KeyTestResultStatusPreviousValuesObject =
   | KeyTestResultStatusPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'key'; args?: [] | false; alias?: string }

type KeyTestResultStatusPreviousValuesFields = 'id' | 'key'

export interface KeyTestResultStatusPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   key: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for KeyStepResultStatusSubscriptionPayload

type KeyStepResultStatusSubscriptionPayloadObject =
   | KeyStepResultStatusSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type KeyStepResultStatusSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface KeyStepResultStatusSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'KeyStepResultStatusSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'KeyStepResultStatus'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeyStepResultStatusSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyStepResultStatus | null>
         | prisma.KeyStepResultStatus
         | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'KeyStepResultStatusPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'KeyStepResultStatusSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.KeyStepResultStatusPreviousValues | null>
         | prisma.KeyStepResultStatusPreviousValues
         | null
   }
}

// Types for KeyStepResultStatusPreviousValues

type KeyStepResultStatusPreviousValuesObject =
   | KeyStepResultStatusPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'key'; args?: [] | false; alias?: string }

type KeyStepResultStatusPreviousValuesFields = 'id' | 'key'

export interface KeyStepResultStatusPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   key: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for MultiLanguageContentSubscriptionPayload

type MultiLanguageContentSubscriptionPayloadObject =
   | MultiLanguageContentSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type MultiLanguageContentSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface MultiLanguageContentSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MultiLanguageContentSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'MultiLanguageContent'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'MultiLanguageContentSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContent | null>
         | prisma.MultiLanguageContent
         | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'MultiLanguageContentPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'MultiLanguageContentSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MultiLanguageContentPreviousValues | null>
         | prisma.MultiLanguageContentPreviousValues
         | null
   }
}

// Types for MultiLanguageContentPreviousValues

type MultiLanguageContentPreviousValuesObject =
   | MultiLanguageContentPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'pt'; args?: [] | false; alias?: string }
   | { name: 'en'; args?: [] | false; alias?: string }

type MultiLanguageContentPreviousValuesFields = 'id' | 'pt' | 'en'

export interface MultiLanguageContentPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   pt: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   en: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
}

// Types for MessageSubscriptionPayload

type MessageSubscriptionPayloadObject =
   | MessageSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type MessageSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface MessageSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MessageSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'Message'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'MessageSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Message | null> | prisma.Message | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'MessagePreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'MessageSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MessagePreviousValues | null>
         | prisma.MessagePreviousValues
         | null
   }
}

// Types for MessagePreviousValues

type MessagePreviousValuesObject =
   | MessagePreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }

type MessagePreviousValuesFields = 'id'

export interface MessagePreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for CompanySubscriptionPayload

type CompanySubscriptionPayloadObject =
   | CompanySubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type CompanySubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface CompanySubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'CompanySubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'Company'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'CompanySubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Company | null> | prisma.Company | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'CompanyPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'CompanySubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.CompanyPreviousValues | null>
         | prisma.CompanyPreviousValues
         | null
   }
}

// Types for CompanyPreviousValues

type CompanyPreviousValuesObject =
   | CompanyPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'name'; args?: [] | false; alias?: string }
   | { name: 'abbr'; args?: [] | false; alias?: string }

type CompanyPreviousValuesFields = 'id' | 'name' | 'abbr'

export interface CompanyPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   name: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   abbr: {
      type: 'String'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
}

// Types for TestSubscriptionPayload

type TestSubscriptionPayloadObject =
   | TestSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type TestSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface TestSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'Test'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'TestSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Test | null> | prisma.Test | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'TestPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'TestSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.TestPreviousValues | null>
         | prisma.TestPreviousValues
         | null
   }
}

// Types for TestPreviousValues

type TestPreviousValuesObject =
   | TestPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }

type TestPreviousValuesFields = 'id'

export interface TestPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for MenuSubscriptionPayload

type MenuSubscriptionPayloadObject =
   | MenuSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type MenuSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface MenuSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'MenuSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'Menu'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'MenuSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Menu | null> | prisma.Menu | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'MenuPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'MenuSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.MenuPreviousValues | null>
         | prisma.MenuPreviousValues
         | null
   }
}

// Types for MenuPreviousValues

type MenuPreviousValuesObject =
   | MenuPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'root'; args?: [] | false; alias?: string }

type MenuPreviousValuesFields = 'id' | 'root'

export interface MenuPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   root: {
      type: 'Boolean'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for StepSubscriptionPayload

type StepSubscriptionPayloadObject =
   | StepSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type StepSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface StepSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'Step'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'StepSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.Step | null> | prisma.Step | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'StepPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'StepSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.StepPreviousValues | null>
         | prisma.StepPreviousValues
         | null
   }
}

// Types for StepPreviousValues

type StepPreviousValuesObject =
   | StepPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }

type StepPreviousValuesFields = 'id'

export interface StepPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for TestResultSubscriptionPayload

type TestResultSubscriptionPayloadObject =
   | TestResultSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type TestResultSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface TestResultSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'TestResultSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'TestResult'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'TestResultSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.TestResult | null> | prisma.TestResult | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'TestResultPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'TestResultSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.TestResultPreviousValues | null>
         | prisma.TestResultPreviousValues
         | null
   }
}

// Types for TestResultPreviousValues

type TestResultPreviousValuesObject =
   | TestResultPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'start'; args?: [] | false; alias?: string }
   | { name: 'end'; args?: [] | false; alias?: string }
   | { name: 'duration'; args?: [] | false; alias?: string }

type TestResultPreviousValuesFields = 'id' | 'start' | 'end' | 'duration'

export interface TestResultPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   start: {
      type: 'DateTime'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   end: {
      type: 'DateTime'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
   duration: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

// Types for StepResultSubscriptionPayload

type StepResultSubscriptionPayloadObject =
   | StepResultSubscriptionPayloadFields
   | { name: 'mutation'; args?: [] | false; alias?: string }
   | { name: 'node'; args?: [] | false; alias?: string }
   | { name: 'updatedFields'; args?: [] | false; alias?: string }
   | { name: 'previousValues'; args?: [] | false; alias?: string }

type StepResultSubscriptionPayloadFields =
   | 'mutation'
   | 'node'
   | 'updatedFields'
   | 'previousValues'

export interface StepResultSubscriptionPayloadFieldDetails {
   mutation: {
      type: 'MutationType'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: (
         root: core.RootValue<'StepResultSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.MutationType> | prisma.MutationType
   }
   node: {
      type: 'StepResult'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'StepResultSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) => Promise<prisma.StepResult | null> | prisma.StepResult | null
   }
   updatedFields: {
      type: 'String'
      args: {}
      description: string
      list: true
      nullable: false
      resolve: undefined
   }
   previousValues: {
      type: 'StepResultPreviousValues'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: (
         root: core.RootValue<'StepResultSubscriptionPayload'>,
         args: {},
         context: core.GetGen<'context'>,
         info?: GraphQLResolveInfo,
      ) =>
         | Promise<prisma.StepResultPreviousValues | null>
         | prisma.StepResultPreviousValues
         | null
   }
}

// Types for StepResultPreviousValues

type StepResultPreviousValuesObject =
   | StepResultPreviousValuesFields
   | { name: 'id'; args?: [] | false; alias?: string }
   | { name: 'start'; args?: [] | false; alias?: string }
   | { name: 'end'; args?: [] | false; alias?: string }
   | { name: 'time'; args?: [] | false; alias?: string }

type StepResultPreviousValuesFields = 'id' | 'start' | 'end' | 'time'

export interface StepResultPreviousValuesFieldDetails {
   id: {
      type: 'ID'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   start: {
      type: 'DateTime'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
   end: {
      type: 'DateTime'
      args: {}
      description: string
      list: undefined
      nullable: true
      resolve: undefined
   }
   time: {
      type: 'Int'
      args: {}
      description: string
      list: undefined
      nullable: false
      resolve: undefined
   }
}

export interface KeyWhereUniqueInput {
   id?: string | null
}
export type KeyWhereUniqueInputInputObject =
   | Extract<keyof KeyWhereUniqueInput, string>
   | { name: 'id'; alias?: string }

export interface KeyUserTypeWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   key?: string | null
   key_not?: string | null
   key_in?: string[]
   key_not_in?: string[]
   key_lt?: string | null
   key_lte?: string | null
   key_gt?: string | null
   key_gte?: string | null
   key_contains?: string | null
   key_not_contains?: string | null
   key_starts_with?: string | null
   key_not_starts_with?: string | null
   key_ends_with?: string | null
   key_not_ends_with?: string | null
   AND?: KeyUserTypeWhereInput[]
}
export type KeyUserTypeWhereInputInputObject =
   | Extract<keyof KeyUserTypeWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'key'; alias?: string }
   | { name: 'key_not'; alias?: string }
   | { name: 'key_in'; alias?: string }
   | { name: 'key_not_in'; alias?: string }
   | { name: 'key_lt'; alias?: string }
   | { name: 'key_lte'; alias?: string }
   | { name: 'key_gt'; alias?: string }
   | { name: 'key_gte'; alias?: string }
   | { name: 'key_contains'; alias?: string }
   | { name: 'key_not_contains'; alias?: string }
   | { name: 'key_starts_with'; alias?: string }
   | { name: 'key_not_starts_with'; alias?: string }
   | { name: 'key_ends_with'; alias?: string }
   | { name: 'key_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyTestResultStatusWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   key?: string | null
   key_not?: string | null
   key_in?: string[]
   key_not_in?: string[]
   key_lt?: string | null
   key_lte?: string | null
   key_gt?: string | null
   key_gte?: string | null
   key_contains?: string | null
   key_not_contains?: string | null
   key_starts_with?: string | null
   key_not_starts_with?: string | null
   key_ends_with?: string | null
   key_not_ends_with?: string | null
   AND?: KeyTestResultStatusWhereInput[]
}
export type KeyTestResultStatusWhereInputInputObject =
   | Extract<keyof KeyTestResultStatusWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'key'; alias?: string }
   | { name: 'key_not'; alias?: string }
   | { name: 'key_in'; alias?: string }
   | { name: 'key_not_in'; alias?: string }
   | { name: 'key_lt'; alias?: string }
   | { name: 'key_lte'; alias?: string }
   | { name: 'key_gt'; alias?: string }
   | { name: 'key_gte'; alias?: string }
   | { name: 'key_contains'; alias?: string }
   | { name: 'key_not_contains'; alias?: string }
   | { name: 'key_starts_with'; alias?: string }
   | { name: 'key_not_starts_with'; alias?: string }
   | { name: 'key_ends_with'; alias?: string }
   | { name: 'key_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyStepResultStatusWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   key?: string | null
   key_not?: string | null
   key_in?: string[]
   key_not_in?: string[]
   key_lt?: string | null
   key_lte?: string | null
   key_gt?: string | null
   key_gte?: string | null
   key_contains?: string | null
   key_not_contains?: string | null
   key_starts_with?: string | null
   key_not_starts_with?: string | null
   key_ends_with?: string | null
   key_not_ends_with?: string | null
   AND?: KeyStepResultStatusWhereInput[]
}
export type KeyStepResultStatusWhereInputInputObject =
   | Extract<keyof KeyStepResultStatusWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'key'; alias?: string }
   | { name: 'key_not'; alias?: string }
   | { name: 'key_in'; alias?: string }
   | { name: 'key_not_in'; alias?: string }
   | { name: 'key_lt'; alias?: string }
   | { name: 'key_lte'; alias?: string }
   | { name: 'key_gt'; alias?: string }
   | { name: 'key_gte'; alias?: string }
   | { name: 'key_contains'; alias?: string }
   | { name: 'key_not_contains'; alias?: string }
   | { name: 'key_starts_with'; alias?: string }
   | { name: 'key_not_starts_with'; alias?: string }
   | { name: 'key_ends_with'; alias?: string }
   | { name: 'key_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyLanguageWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   key?: string | null
   key_not?: string | null
   key_in?: string[]
   key_not_in?: string[]
   key_lt?: string | null
   key_lte?: string | null
   key_gt?: string | null
   key_gte?: string | null
   key_contains?: string | null
   key_not_contains?: string | null
   key_starts_with?: string | null
   key_not_starts_with?: string | null
   key_ends_with?: string | null
   key_not_ends_with?: string | null
   AND?: KeyLanguageWhereInput[]
}
export type KeyLanguageWhereInputInputObject =
   | Extract<keyof KeyLanguageWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'key'; alias?: string }
   | { name: 'key_not'; alias?: string }
   | { name: 'key_in'; alias?: string }
   | { name: 'key_not_in'; alias?: string }
   | { name: 'key_lt'; alias?: string }
   | { name: 'key_lte'; alias?: string }
   | { name: 'key_gt'; alias?: string }
   | { name: 'key_gte'; alias?: string }
   | { name: 'key_contains'; alias?: string }
   | { name: 'key_not_contains'; alias?: string }
   | { name: 'key_starts_with'; alias?: string }
   | { name: 'key_not_starts_with'; alias?: string }
   | { name: 'key_ends_with'; alias?: string }
   | { name: 'key_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   userTypes_some?: KeyUserTypeWhereInput | null
   testResultStatus_some?: KeyTestResultStatusWhereInput | null
   stepResultStatus_some?: KeyStepResultStatusWhereInput | null
   languages_some?: KeyLanguageWhereInput | null
   AND?: KeyWhereInput[]
}
export type KeyWhereInputInputObject =
   | Extract<keyof KeyWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'userTypes_some'; alias?: string }
   | { name: 'testResultStatus_some'; alias?: string }
   | { name: 'stepResultStatus_some'; alias?: string }
   | { name: 'languages_some'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyUserTypeWhereUniqueInput {
   id?: string | null
   key?: string | null
}
export type KeyUserTypeWhereUniqueInputInputObject =
   | Extract<keyof KeyUserTypeWhereUniqueInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'key'; alias?: string }

export interface KeyLanguageWhereUniqueInput {
   id?: string | null
   key?: string | null
}
export type KeyLanguageWhereUniqueInputInputObject =
   | Extract<keyof KeyLanguageWhereUniqueInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'key'; alias?: string }

export interface KeyTestResultStatusWhereUniqueInput {
   id?: string | null
   key?: string | null
}
export type KeyTestResultStatusWhereUniqueInputInputObject =
   | Extract<keyof KeyTestResultStatusWhereUniqueInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'key'; alias?: string }

export interface KeyStepResultStatusWhereUniqueInput {
   id?: string | null
   key?: string | null
}
export type KeyStepResultStatusWhereUniqueInputInputObject =
   | Extract<keyof KeyStepResultStatusWhereUniqueInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'key'; alias?: string }

export interface MultiLanguageContentWhereUniqueInput {
   id?: string | null
}
export type MultiLanguageContentWhereUniqueInputInputObject =
   | Extract<keyof MultiLanguageContentWhereUniqueInput, string>
   | { name: 'id'; alias?: string }

export interface MultiLanguageContentWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   pt?: string | null
   pt_not?: string | null
   pt_in?: string[]
   pt_not_in?: string[]
   pt_lt?: string | null
   pt_lte?: string | null
   pt_gt?: string | null
   pt_gte?: string | null
   pt_contains?: string | null
   pt_not_contains?: string | null
   pt_starts_with?: string | null
   pt_not_starts_with?: string | null
   pt_ends_with?: string | null
   pt_not_ends_with?: string | null
   en?: string | null
   en_not?: string | null
   en_in?: string[]
   en_not_in?: string[]
   en_lt?: string | null
   en_lte?: string | null
   en_gt?: string | null
   en_gte?: string | null
   en_contains?: string | null
   en_not_contains?: string | null
   en_starts_with?: string | null
   en_not_starts_with?: string | null
   en_ends_with?: string | null
   en_not_ends_with?: string | null
   AND?: MultiLanguageContentWhereInput[]
}
export type MultiLanguageContentWhereInputInputObject =
   | Extract<keyof MultiLanguageContentWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'pt'; alias?: string }
   | { name: 'pt_not'; alias?: string }
   | { name: 'pt_in'; alias?: string }
   | { name: 'pt_not_in'; alias?: string }
   | { name: 'pt_lt'; alias?: string }
   | { name: 'pt_lte'; alias?: string }
   | { name: 'pt_gt'; alias?: string }
   | { name: 'pt_gte'; alias?: string }
   | { name: 'pt_contains'; alias?: string }
   | { name: 'pt_not_contains'; alias?: string }
   | { name: 'pt_starts_with'; alias?: string }
   | { name: 'pt_not_starts_with'; alias?: string }
   | { name: 'pt_ends_with'; alias?: string }
   | { name: 'pt_not_ends_with'; alias?: string }
   | { name: 'en'; alias?: string }
   | { name: 'en_not'; alias?: string }
   | { name: 'en_in'; alias?: string }
   | { name: 'en_not_in'; alias?: string }
   | { name: 'en_lt'; alias?: string }
   | { name: 'en_lte'; alias?: string }
   | { name: 'en_gt'; alias?: string }
   | { name: 'en_gte'; alias?: string }
   | { name: 'en_contains'; alias?: string }
   | { name: 'en_not_contains'; alias?: string }
   | { name: 'en_starts_with'; alias?: string }
   | { name: 'en_not_starts_with'; alias?: string }
   | { name: 'en_ends_with'; alias?: string }
   | { name: 'en_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface MessageWhereUniqueInput {
   id?: string | null
}
export type MessageWhereUniqueInputInputObject =
   | Extract<keyof MessageWhereUniqueInput, string>
   | { name: 'id'; alias?: string }

export interface MessageWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   title?: MultiLanguageContentWhereInput | null
   message?: MultiLanguageContentWhereInput | null
   AND?: MessageWhereInput[]
}
export type MessageWhereInputInputObject =
   | Extract<keyof MessageWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'message'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface CompanyWhereUniqueInput {
   id?: string | null
   name?: string | null
}
export type CompanyWhereUniqueInputInputObject =
   | Extract<keyof CompanyWhereUniqueInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'name'; alias?: string }

export interface TestWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   publics_some?: KeyUserTypeWhereInput | null
   languages_some?: KeyLanguageWhereInput | null
   instruction?: MessageWhereInput | null
   company?: CompanyWhereInput | null
   title?: MultiLanguageContentWhereInput | null
   steps_some?: StepWhereInput | null
   menus_some?: MenuWhereInput | null
   results_some?: TestResultWhereInput | null
   keys?: KeyWhereInput | null
   AND?: TestWhereInput[]
}
export type TestWhereInputInputObject =
   | Extract<keyof TestWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'publics_some'; alias?: string }
   | { name: 'languages_some'; alias?: string }
   | { name: 'instruction'; alias?: string }
   | { name: 'company'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'steps_some'; alias?: string }
   | { name: 'menus_some'; alias?: string }
   | { name: 'results_some'; alias?: string }
   | { name: 'keys'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface CompanyWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   name?: string | null
   name_not?: string | null
   name_in?: string[]
   name_not_in?: string[]
   name_lt?: string | null
   name_lte?: string | null
   name_gt?: string | null
   name_gte?: string | null
   name_contains?: string | null
   name_not_contains?: string | null
   name_starts_with?: string | null
   name_not_starts_with?: string | null
   name_ends_with?: string | null
   name_not_ends_with?: string | null
   abbr?: string | null
   abbr_not?: string | null
   abbr_in?: string[]
   abbr_not_in?: string[]
   abbr_lt?: string | null
   abbr_lte?: string | null
   abbr_gt?: string | null
   abbr_gte?: string | null
   abbr_contains?: string | null
   abbr_not_contains?: string | null
   abbr_starts_with?: string | null
   abbr_not_starts_with?: string | null
   abbr_ends_with?: string | null
   abbr_not_ends_with?: string | null
   welcome?: MessageWhereInput | null
   tests_some?: TestWhereInput | null
   AND?: CompanyWhereInput[]
}
export type CompanyWhereInputInputObject =
   | Extract<keyof CompanyWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'name_not'; alias?: string }
   | { name: 'name_in'; alias?: string }
   | { name: 'name_not_in'; alias?: string }
   | { name: 'name_lt'; alias?: string }
   | { name: 'name_lte'; alias?: string }
   | { name: 'name_gt'; alias?: string }
   | { name: 'name_gte'; alias?: string }
   | { name: 'name_contains'; alias?: string }
   | { name: 'name_not_contains'; alias?: string }
   | { name: 'name_starts_with'; alias?: string }
   | { name: 'name_not_starts_with'; alias?: string }
   | { name: 'name_ends_with'; alias?: string }
   | { name: 'name_not_ends_with'; alias?: string }
   | { name: 'abbr'; alias?: string }
   | { name: 'abbr_not'; alias?: string }
   | { name: 'abbr_in'; alias?: string }
   | { name: 'abbr_not_in'; alias?: string }
   | { name: 'abbr_lt'; alias?: string }
   | { name: 'abbr_lte'; alias?: string }
   | { name: 'abbr_gt'; alias?: string }
   | { name: 'abbr_gte'; alias?: string }
   | { name: 'abbr_contains'; alias?: string }
   | { name: 'abbr_not_contains'; alias?: string }
   | { name: 'abbr_starts_with'; alias?: string }
   | { name: 'abbr_not_starts_with'; alias?: string }
   | { name: 'abbr_ends_with'; alias?: string }
   | { name: 'abbr_not_ends_with'; alias?: string }
   | { name: 'welcome'; alias?: string }
   | { name: 'tests_some'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface StepWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   type_some?: KeyUserTypeWhereInput | null
   question?: MultiLanguageContentWhereInput | null
   targets_some?: MenuWhereInput | null
   paths_some?: MenuWhereInput | null
   results_some?: StepResultWhereInput | null
   AND?: StepWhereInput[]
}
export type StepWhereInputInputObject =
   | Extract<keyof StepWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'type_some'; alias?: string }
   | { name: 'question'; alias?: string }
   | { name: 'targets_some'; alias?: string }
   | { name: 'paths_some'; alias?: string }
   | { name: 'results_some'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface MenuWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   root?: boolean | null
   root_not?: boolean | null
   menus_some?: MenuWhereInput | null
   name?: MultiLanguageContentWhereInput | null
   items_some?: MenuWhereInput | null
   AND?: MenuWhereInput[]
}
export type MenuWhereInputInputObject =
   | Extract<keyof MenuWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'root'; alias?: string }
   | { name: 'root_not'; alias?: string }
   | { name: 'menus_some'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'items_some'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface StepResultWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   parent?: StepWhereInput | null
   result?: TestResultWhereInput | null
   start?: string | null
   start_not?: string | null
   start_in?: string[]
   start_not_in?: string[]
   start_lt?: string | null
   start_lte?: string | null
   start_gt?: string | null
   start_gte?: string | null
   end?: string | null
   end_not?: string | null
   end_in?: string[]
   end_not_in?: string[]
   end_lt?: string | null
   end_lte?: string | null
   end_gt?: string | null
   end_gte?: string | null
   time?: number | null
   time_not?: number | null
   time_in?: number[]
   time_not_in?: number[]
   time_lt?: number | null
   time_lte?: number | null
   time_gt?: number | null
   time_gte?: number | null
   path_some?: MenuWhereInput | null
   status?: KeyStepResultStatusWhereInput | null
   AND?: StepResultWhereInput[]
}
export type StepResultWhereInputInputObject =
   | Extract<keyof StepResultWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'parent'; alias?: string }
   | { name: 'result'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'start_not'; alias?: string }
   | { name: 'start_in'; alias?: string }
   | { name: 'start_not_in'; alias?: string }
   | { name: 'start_lt'; alias?: string }
   | { name: 'start_lte'; alias?: string }
   | { name: 'start_gt'; alias?: string }
   | { name: 'start_gte'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'end_not'; alias?: string }
   | { name: 'end_in'; alias?: string }
   | { name: 'end_not_in'; alias?: string }
   | { name: 'end_lt'; alias?: string }
   | { name: 'end_lte'; alias?: string }
   | { name: 'end_gt'; alias?: string }
   | { name: 'end_gte'; alias?: string }
   | { name: 'time'; alias?: string }
   | { name: 'time_not'; alias?: string }
   | { name: 'time_in'; alias?: string }
   | { name: 'time_not_in'; alias?: string }
   | { name: 'time_lt'; alias?: string }
   | { name: 'time_lte'; alias?: string }
   | { name: 'time_gt'; alias?: string }
   | { name: 'time_gte'; alias?: string }
   | { name: 'path_some'; alias?: string }
   | { name: 'status'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface TestResultWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   parent?: TestWhereInput | null
   start?: string | null
   start_not?: string | null
   start_in?: string[]
   start_not_in?: string[]
   start_lt?: string | null
   start_lte?: string | null
   start_gt?: string | null
   start_gte?: string | null
   end?: string | null
   end_not?: string | null
   end_in?: string[]
   end_not_in?: string[]
   end_lt?: string | null
   end_lte?: string | null
   end_gt?: string | null
   end_gte?: string | null
   duration?: number | null
   duration_not?: number | null
   duration_in?: number[]
   duration_not_in?: number[]
   duration_lt?: number | null
   duration_lte?: number | null
   duration_gt?: number | null
   duration_gte?: number | null
   steps_some?: StepResultWhereInput | null
   status?: KeyTestResultStatusWhereInput | null
   AND?: TestResultWhereInput[]
}
export type TestResultWhereInputInputObject =
   | Extract<keyof TestResultWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'parent'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'start_not'; alias?: string }
   | { name: 'start_in'; alias?: string }
   | { name: 'start_not_in'; alias?: string }
   | { name: 'start_lt'; alias?: string }
   | { name: 'start_lte'; alias?: string }
   | { name: 'start_gt'; alias?: string }
   | { name: 'start_gte'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'end_not'; alias?: string }
   | { name: 'end_in'; alias?: string }
   | { name: 'end_not_in'; alias?: string }
   | { name: 'end_lt'; alias?: string }
   | { name: 'end_lte'; alias?: string }
   | { name: 'end_gt'; alias?: string }
   | { name: 'end_gte'; alias?: string }
   | { name: 'duration'; alias?: string }
   | { name: 'duration_not'; alias?: string }
   | { name: 'duration_in'; alias?: string }
   | { name: 'duration_not_in'; alias?: string }
   | { name: 'duration_lt'; alias?: string }
   | { name: 'duration_lte'; alias?: string }
   | { name: 'duration_gt'; alias?: string }
   | { name: 'duration_gte'; alias?: string }
   | { name: 'steps_some'; alias?: string }
   | { name: 'status'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface TestWhereUniqueInput {
   id?: string | null
}
export type TestWhereUniqueInputInputObject =
   | Extract<keyof TestWhereUniqueInput, string>
   | { name: 'id'; alias?: string }

export interface MenuWhereUniqueInput {
   id?: string | null
}
export type MenuWhereUniqueInputInputObject =
   | Extract<keyof MenuWhereUniqueInput, string>
   | { name: 'id'; alias?: string }

export interface StepWhereUniqueInput {
   id?: string | null
}
export type StepWhereUniqueInputInputObject =
   | Extract<keyof StepWhereUniqueInput, string>
   | { name: 'id'; alias?: string }

export interface TestResultWhereUniqueInput {
   id?: string | null
}
export type TestResultWhereUniqueInputInputObject =
   | Extract<keyof TestResultWhereUniqueInput, string>
   | { name: 'id'; alias?: string }

export interface StepResultWhereUniqueInput {
   id?: string | null
}
export type StepResultWhereUniqueInputInputObject =
   | Extract<keyof StepResultWhereUniqueInput, string>
   | { name: 'id'; alias?: string }

export interface KeyCreateInput {
   id?: string | null
   userTypes?: KeyUserTypeCreateManyInput | null
   testResultStatus?: KeyTestResultStatusCreateManyInput | null
   stepResultStatus?: KeyStepResultStatusCreateManyInput | null
   languages?: KeyLanguageCreateManyInput | null
}
export type KeyCreateInputInputObject =
   | Extract<keyof KeyCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'userTypes'; alias?: string }
   | { name: 'testResultStatus'; alias?: string }
   | { name: 'stepResultStatus'; alias?: string }
   | { name: 'languages'; alias?: string }

export interface KeyUserTypeCreateManyInput {
   create?: KeyUserTypeCreateInput[]
   connect?: KeyUserTypeWhereUniqueInput[]
}
export type KeyUserTypeCreateManyInputInputObject =
   | Extract<keyof KeyUserTypeCreateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyUserTypeCreateInput {
   id?: string | null
   key?: string
}
export type KeyUserTypeCreateInputInputObject =
   | Extract<keyof KeyUserTypeCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'key'; alias?: string }

export interface KeyTestResultStatusCreateManyInput {
   create?: KeyTestResultStatusCreateInput[]
   connect?: KeyTestResultStatusWhereUniqueInput[]
}
export type KeyTestResultStatusCreateManyInputInputObject =
   | Extract<keyof KeyTestResultStatusCreateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyTestResultStatusCreateInput {
   id?: string | null
   key?: string
}
export type KeyTestResultStatusCreateInputInputObject =
   | Extract<keyof KeyTestResultStatusCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'key'; alias?: string }

export interface KeyStepResultStatusCreateManyInput {
   create?: KeyStepResultStatusCreateInput[]
   connect?: KeyStepResultStatusWhereUniqueInput[]
}
export type KeyStepResultStatusCreateManyInputInputObject =
   | Extract<keyof KeyStepResultStatusCreateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyStepResultStatusCreateInput {
   id?: string | null
   key?: string
}
export type KeyStepResultStatusCreateInputInputObject =
   | Extract<keyof KeyStepResultStatusCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'key'; alias?: string }

export interface KeyLanguageCreateManyInput {
   create?: KeyLanguageCreateInput[]
   connect?: KeyLanguageWhereUniqueInput[]
}
export type KeyLanguageCreateManyInputInputObject =
   | Extract<keyof KeyLanguageCreateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyLanguageCreateInput {
   id?: string | null
   key?: string
}
export type KeyLanguageCreateInputInputObject =
   | Extract<keyof KeyLanguageCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'key'; alias?: string }

export interface KeyUpdateInput {
   userTypes?: KeyUserTypeUpdateManyInput | null
   testResultStatus?: KeyTestResultStatusUpdateManyInput | null
   stepResultStatus?: KeyStepResultStatusUpdateManyInput | null
   languages?: KeyLanguageUpdateManyInput | null
}
export type KeyUpdateInputInputObject =
   | Extract<keyof KeyUpdateInput, string>
   | { name: 'userTypes'; alias?: string }
   | { name: 'testResultStatus'; alias?: string }
   | { name: 'stepResultStatus'; alias?: string }
   | { name: 'languages'; alias?: string }

export interface KeyUserTypeUpdateManyInput {
   create?: KeyUserTypeCreateInput[]
   update?: KeyUserTypeUpdateWithWhereUniqueNestedInput[]
   upsert?: KeyUserTypeUpsertWithWhereUniqueNestedInput[]
   delete?: KeyUserTypeWhereUniqueInput[]
   connect?: KeyUserTypeWhereUniqueInput[]
   set?: KeyUserTypeWhereUniqueInput[]
   disconnect?: KeyUserTypeWhereUniqueInput[]
   deleteMany?: KeyUserTypeScalarWhereInput[]
   updateMany?: KeyUserTypeUpdateManyWithWhereNestedInput[]
}
export type KeyUserTypeUpdateManyInputInputObject =
   | Extract<keyof KeyUserTypeUpdateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface KeyUserTypeUpdateWithWhereUniqueNestedInput {
   where?: KeyUserTypeWhereUniqueInput
   data?: KeyUserTypeUpdateDataInput
}
export type KeyUserTypeUpdateWithWhereUniqueNestedInputInputObject =
   | Extract<keyof KeyUserTypeUpdateWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface KeyUserTypeUpdateDataInput {
   key?: string | null
}
export type KeyUserTypeUpdateDataInputInputObject =
   | Extract<keyof KeyUserTypeUpdateDataInput, string>
   | { name: 'key'; alias?: string }

export interface KeyUserTypeUpsertWithWhereUniqueNestedInput {
   where?: KeyUserTypeWhereUniqueInput
   update?: KeyUserTypeUpdateDataInput
   create?: KeyUserTypeCreateInput
}
export type KeyUserTypeUpsertWithWhereUniqueNestedInputInputObject =
   | Extract<keyof KeyUserTypeUpsertWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface KeyUserTypeScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   key?: string | null
   key_not?: string | null
   key_in?: string[]
   key_not_in?: string[]
   key_lt?: string | null
   key_lte?: string | null
   key_gt?: string | null
   key_gte?: string | null
   key_contains?: string | null
   key_not_contains?: string | null
   key_starts_with?: string | null
   key_not_starts_with?: string | null
   key_ends_with?: string | null
   key_not_ends_with?: string | null
   AND?: KeyUserTypeScalarWhereInput[]
   OR?: KeyUserTypeScalarWhereInput[]
   NOT?: KeyUserTypeScalarWhereInput[]
}
export type KeyUserTypeScalarWhereInputInputObject =
   | Extract<keyof KeyUserTypeScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'key'; alias?: string }
   | { name: 'key_not'; alias?: string }
   | { name: 'key_in'; alias?: string }
   | { name: 'key_not_in'; alias?: string }
   | { name: 'key_lt'; alias?: string }
   | { name: 'key_lte'; alias?: string }
   | { name: 'key_gt'; alias?: string }
   | { name: 'key_gte'; alias?: string }
   | { name: 'key_contains'; alias?: string }
   | { name: 'key_not_contains'; alias?: string }
   | { name: 'key_starts_with'; alias?: string }
   | { name: 'key_not_starts_with'; alias?: string }
   | { name: 'key_ends_with'; alias?: string }
   | { name: 'key_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface KeyUserTypeUpdateManyWithWhereNestedInput {
   where?: KeyUserTypeScalarWhereInput
   data?: KeyUserTypeUpdateManyDataInput
}
export type KeyUserTypeUpdateManyWithWhereNestedInputInputObject =
   | Extract<keyof KeyUserTypeUpdateManyWithWhereNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface KeyUserTypeUpdateManyDataInput {
   key?: string | null
}
export type KeyUserTypeUpdateManyDataInputInputObject =
   | Extract<keyof KeyUserTypeUpdateManyDataInput, string>
   | { name: 'key'; alias?: string }

export interface KeyTestResultStatusUpdateManyInput {
   create?: KeyTestResultStatusCreateInput[]
   update?: KeyTestResultStatusUpdateWithWhereUniqueNestedInput[]
   upsert?: KeyTestResultStatusUpsertWithWhereUniqueNestedInput[]
   delete?: KeyTestResultStatusWhereUniqueInput[]
   connect?: KeyTestResultStatusWhereUniqueInput[]
   set?: KeyTestResultStatusWhereUniqueInput[]
   disconnect?: KeyTestResultStatusWhereUniqueInput[]
   deleteMany?: KeyTestResultStatusScalarWhereInput[]
   updateMany?: KeyTestResultStatusUpdateManyWithWhereNestedInput[]
}
export type KeyTestResultStatusUpdateManyInputInputObject =
   | Extract<keyof KeyTestResultStatusUpdateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface KeyTestResultStatusUpdateWithWhereUniqueNestedInput {
   where?: KeyTestResultStatusWhereUniqueInput
   data?: KeyTestResultStatusUpdateDataInput
}
export type KeyTestResultStatusUpdateWithWhereUniqueNestedInputInputObject =
   | Extract<keyof KeyTestResultStatusUpdateWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface KeyTestResultStatusUpdateDataInput {
   key?: string | null
}
export type KeyTestResultStatusUpdateDataInputInputObject =
   | Extract<keyof KeyTestResultStatusUpdateDataInput, string>
   | { name: 'key'; alias?: string }

export interface KeyTestResultStatusUpsertWithWhereUniqueNestedInput {
   where?: KeyTestResultStatusWhereUniqueInput
   update?: KeyTestResultStatusUpdateDataInput
   create?: KeyTestResultStatusCreateInput
}
export type KeyTestResultStatusUpsertWithWhereUniqueNestedInputInputObject =
   | Extract<keyof KeyTestResultStatusUpsertWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface KeyTestResultStatusScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   key?: string | null
   key_not?: string | null
   key_in?: string[]
   key_not_in?: string[]
   key_lt?: string | null
   key_lte?: string | null
   key_gt?: string | null
   key_gte?: string | null
   key_contains?: string | null
   key_not_contains?: string | null
   key_starts_with?: string | null
   key_not_starts_with?: string | null
   key_ends_with?: string | null
   key_not_ends_with?: string | null
   AND?: KeyTestResultStatusScalarWhereInput[]
   OR?: KeyTestResultStatusScalarWhereInput[]
   NOT?: KeyTestResultStatusScalarWhereInput[]
}
export type KeyTestResultStatusScalarWhereInputInputObject =
   | Extract<keyof KeyTestResultStatusScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'key'; alias?: string }
   | { name: 'key_not'; alias?: string }
   | { name: 'key_in'; alias?: string }
   | { name: 'key_not_in'; alias?: string }
   | { name: 'key_lt'; alias?: string }
   | { name: 'key_lte'; alias?: string }
   | { name: 'key_gt'; alias?: string }
   | { name: 'key_gte'; alias?: string }
   | { name: 'key_contains'; alias?: string }
   | { name: 'key_not_contains'; alias?: string }
   | { name: 'key_starts_with'; alias?: string }
   | { name: 'key_not_starts_with'; alias?: string }
   | { name: 'key_ends_with'; alias?: string }
   | { name: 'key_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface KeyTestResultStatusUpdateManyWithWhereNestedInput {
   where?: KeyTestResultStatusScalarWhereInput
   data?: KeyTestResultStatusUpdateManyDataInput
}
export type KeyTestResultStatusUpdateManyWithWhereNestedInputInputObject =
   | Extract<keyof KeyTestResultStatusUpdateManyWithWhereNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface KeyTestResultStatusUpdateManyDataInput {
   key?: string | null
}
export type KeyTestResultStatusUpdateManyDataInputInputObject =
   | Extract<keyof KeyTestResultStatusUpdateManyDataInput, string>
   | { name: 'key'; alias?: string }

export interface KeyStepResultStatusUpdateManyInput {
   create?: KeyStepResultStatusCreateInput[]
   update?: KeyStepResultStatusUpdateWithWhereUniqueNestedInput[]
   upsert?: KeyStepResultStatusUpsertWithWhereUniqueNestedInput[]
   delete?: KeyStepResultStatusWhereUniqueInput[]
   connect?: KeyStepResultStatusWhereUniqueInput[]
   set?: KeyStepResultStatusWhereUniqueInput[]
   disconnect?: KeyStepResultStatusWhereUniqueInput[]
   deleteMany?: KeyStepResultStatusScalarWhereInput[]
   updateMany?: KeyStepResultStatusUpdateManyWithWhereNestedInput[]
}
export type KeyStepResultStatusUpdateManyInputInputObject =
   | Extract<keyof KeyStepResultStatusUpdateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface KeyStepResultStatusUpdateWithWhereUniqueNestedInput {
   where?: KeyStepResultStatusWhereUniqueInput
   data?: KeyStepResultStatusUpdateDataInput
}
export type KeyStepResultStatusUpdateWithWhereUniqueNestedInputInputObject =
   | Extract<keyof KeyStepResultStatusUpdateWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface KeyStepResultStatusUpdateDataInput {
   key?: string | null
}
export type KeyStepResultStatusUpdateDataInputInputObject =
   | Extract<keyof KeyStepResultStatusUpdateDataInput, string>
   | { name: 'key'; alias?: string }

export interface KeyStepResultStatusUpsertWithWhereUniqueNestedInput {
   where?: KeyStepResultStatusWhereUniqueInput
   update?: KeyStepResultStatusUpdateDataInput
   create?: KeyStepResultStatusCreateInput
}
export type KeyStepResultStatusUpsertWithWhereUniqueNestedInputInputObject =
   | Extract<keyof KeyStepResultStatusUpsertWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface KeyStepResultStatusScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   key?: string | null
   key_not?: string | null
   key_in?: string[]
   key_not_in?: string[]
   key_lt?: string | null
   key_lte?: string | null
   key_gt?: string | null
   key_gte?: string | null
   key_contains?: string | null
   key_not_contains?: string | null
   key_starts_with?: string | null
   key_not_starts_with?: string | null
   key_ends_with?: string | null
   key_not_ends_with?: string | null
   AND?: KeyStepResultStatusScalarWhereInput[]
   OR?: KeyStepResultStatusScalarWhereInput[]
   NOT?: KeyStepResultStatusScalarWhereInput[]
}
export type KeyStepResultStatusScalarWhereInputInputObject =
   | Extract<keyof KeyStepResultStatusScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'key'; alias?: string }
   | { name: 'key_not'; alias?: string }
   | { name: 'key_in'; alias?: string }
   | { name: 'key_not_in'; alias?: string }
   | { name: 'key_lt'; alias?: string }
   | { name: 'key_lte'; alias?: string }
   | { name: 'key_gt'; alias?: string }
   | { name: 'key_gte'; alias?: string }
   | { name: 'key_contains'; alias?: string }
   | { name: 'key_not_contains'; alias?: string }
   | { name: 'key_starts_with'; alias?: string }
   | { name: 'key_not_starts_with'; alias?: string }
   | { name: 'key_ends_with'; alias?: string }
   | { name: 'key_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface KeyStepResultStatusUpdateManyWithWhereNestedInput {
   where?: KeyStepResultStatusScalarWhereInput
   data?: KeyStepResultStatusUpdateManyDataInput
}
export type KeyStepResultStatusUpdateManyWithWhereNestedInputInputObject =
   | Extract<keyof KeyStepResultStatusUpdateManyWithWhereNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface KeyStepResultStatusUpdateManyDataInput {
   key?: string | null
}
export type KeyStepResultStatusUpdateManyDataInputInputObject =
   | Extract<keyof KeyStepResultStatusUpdateManyDataInput, string>
   | { name: 'key'; alias?: string }

export interface KeyLanguageUpdateManyInput {
   create?: KeyLanguageCreateInput[]
   update?: KeyLanguageUpdateWithWhereUniqueNestedInput[]
   upsert?: KeyLanguageUpsertWithWhereUniqueNestedInput[]
   delete?: KeyLanguageWhereUniqueInput[]
   connect?: KeyLanguageWhereUniqueInput[]
   set?: KeyLanguageWhereUniqueInput[]
   disconnect?: KeyLanguageWhereUniqueInput[]
   deleteMany?: KeyLanguageScalarWhereInput[]
   updateMany?: KeyLanguageUpdateManyWithWhereNestedInput[]
}
export type KeyLanguageUpdateManyInputInputObject =
   | Extract<keyof KeyLanguageUpdateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface KeyLanguageUpdateWithWhereUniqueNestedInput {
   where?: KeyLanguageWhereUniqueInput
   data?: KeyLanguageUpdateDataInput
}
export type KeyLanguageUpdateWithWhereUniqueNestedInputInputObject =
   | Extract<keyof KeyLanguageUpdateWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface KeyLanguageUpdateDataInput {
   key?: string | null
}
export type KeyLanguageUpdateDataInputInputObject =
   | Extract<keyof KeyLanguageUpdateDataInput, string>
   | { name: 'key'; alias?: string }

export interface KeyLanguageUpsertWithWhereUniqueNestedInput {
   where?: KeyLanguageWhereUniqueInput
   update?: KeyLanguageUpdateDataInput
   create?: KeyLanguageCreateInput
}
export type KeyLanguageUpsertWithWhereUniqueNestedInputInputObject =
   | Extract<keyof KeyLanguageUpsertWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface KeyLanguageScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   key?: string | null
   key_not?: string | null
   key_in?: string[]
   key_not_in?: string[]
   key_lt?: string | null
   key_lte?: string | null
   key_gt?: string | null
   key_gte?: string | null
   key_contains?: string | null
   key_not_contains?: string | null
   key_starts_with?: string | null
   key_not_starts_with?: string | null
   key_ends_with?: string | null
   key_not_ends_with?: string | null
   AND?: KeyLanguageScalarWhereInput[]
   OR?: KeyLanguageScalarWhereInput[]
   NOT?: KeyLanguageScalarWhereInput[]
}
export type KeyLanguageScalarWhereInputInputObject =
   | Extract<keyof KeyLanguageScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'key'; alias?: string }
   | { name: 'key_not'; alias?: string }
   | { name: 'key_in'; alias?: string }
   | { name: 'key_not_in'; alias?: string }
   | { name: 'key_lt'; alias?: string }
   | { name: 'key_lte'; alias?: string }
   | { name: 'key_gt'; alias?: string }
   | { name: 'key_gte'; alias?: string }
   | { name: 'key_contains'; alias?: string }
   | { name: 'key_not_contains'; alias?: string }
   | { name: 'key_starts_with'; alias?: string }
   | { name: 'key_not_starts_with'; alias?: string }
   | { name: 'key_ends_with'; alias?: string }
   | { name: 'key_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface KeyLanguageUpdateManyWithWhereNestedInput {
   where?: KeyLanguageScalarWhereInput
   data?: KeyLanguageUpdateManyDataInput
}
export type KeyLanguageUpdateManyWithWhereNestedInputInputObject =
   | Extract<keyof KeyLanguageUpdateManyWithWhereNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface KeyLanguageUpdateManyDataInput {
   key?: string | null
}
export type KeyLanguageUpdateManyDataInputInputObject =
   | Extract<keyof KeyLanguageUpdateManyDataInput, string>
   | { name: 'key'; alias?: string }

export interface KeyUserTypeUpdateInput {
   key?: string | null
}
export type KeyUserTypeUpdateInputInputObject =
   | Extract<keyof KeyUserTypeUpdateInput, string>
   | { name: 'key'; alias?: string }

export interface KeyUserTypeUpdateManyMutationInput {
   key?: string | null
}
export type KeyUserTypeUpdateManyMutationInputInputObject =
   | Extract<keyof KeyUserTypeUpdateManyMutationInput, string>
   | { name: 'key'; alias?: string }

export interface KeyLanguageUpdateInput {
   key?: string | null
}
export type KeyLanguageUpdateInputInputObject =
   | Extract<keyof KeyLanguageUpdateInput, string>
   | { name: 'key'; alias?: string }

export interface KeyLanguageUpdateManyMutationInput {
   key?: string | null
}
export type KeyLanguageUpdateManyMutationInputInputObject =
   | Extract<keyof KeyLanguageUpdateManyMutationInput, string>
   | { name: 'key'; alias?: string }

export interface KeyTestResultStatusUpdateInput {
   key?: string | null
}
export type KeyTestResultStatusUpdateInputInputObject =
   | Extract<keyof KeyTestResultStatusUpdateInput, string>
   | { name: 'key'; alias?: string }

export interface KeyTestResultStatusUpdateManyMutationInput {
   key?: string | null
}
export type KeyTestResultStatusUpdateManyMutationInputInputObject =
   | Extract<keyof KeyTestResultStatusUpdateManyMutationInput, string>
   | { name: 'key'; alias?: string }

export interface KeyStepResultStatusUpdateInput {
   key?: string | null
}
export type KeyStepResultStatusUpdateInputInputObject =
   | Extract<keyof KeyStepResultStatusUpdateInput, string>
   | { name: 'key'; alias?: string }

export interface KeyStepResultStatusUpdateManyMutationInput {
   key?: string | null
}
export type KeyStepResultStatusUpdateManyMutationInputInputObject =
   | Extract<keyof KeyStepResultStatusUpdateManyMutationInput, string>
   | { name: 'key'; alias?: string }

export interface MultiLanguageContentCreateInput {
   id?: string | null
   pt?: string
   en?: string | null
}
export type MultiLanguageContentCreateInputInputObject =
   | Extract<keyof MultiLanguageContentCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'pt'; alias?: string }
   | { name: 'en'; alias?: string }

export interface MultiLanguageContentUpdateInput {
   pt?: string | null
   en?: string | null
}
export type MultiLanguageContentUpdateInputInputObject =
   | Extract<keyof MultiLanguageContentUpdateInput, string>
   | { name: 'pt'; alias?: string }
   | { name: 'en'; alias?: string }

export interface MultiLanguageContentUpdateManyMutationInput {
   pt?: string | null
   en?: string | null
}
export type MultiLanguageContentUpdateManyMutationInputInputObject =
   | Extract<keyof MultiLanguageContentUpdateManyMutationInput, string>
   | { name: 'pt'; alias?: string }
   | { name: 'en'; alias?: string }

export interface MessageCreateInput {
   id?: string | null
   title?: MultiLanguageContentCreateOneInput
   message?: MultiLanguageContentCreateOneInput
}
export type MessageCreateInputInputObject =
   | Extract<keyof MessageCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'message'; alias?: string }

export interface MultiLanguageContentCreateOneInput {
   create?: MultiLanguageContentCreateInput | null
   connect?: MultiLanguageContentWhereUniqueInput | null
}
export type MultiLanguageContentCreateOneInputInputObject =
   | Extract<keyof MultiLanguageContentCreateOneInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface MessageUpdateInput {
   title?: MultiLanguageContentUpdateOneRequiredInput | null
   message?: MultiLanguageContentUpdateOneRequiredInput | null
}
export type MessageUpdateInputInputObject =
   | Extract<keyof MessageUpdateInput, string>
   | { name: 'title'; alias?: string }
   | { name: 'message'; alias?: string }

export interface MultiLanguageContentUpdateOneRequiredInput {
   create?: MultiLanguageContentCreateInput | null
   update?: MultiLanguageContentUpdateDataInput | null
   upsert?: MultiLanguageContentUpsertNestedInput | null
   connect?: MultiLanguageContentWhereUniqueInput | null
}
export type MultiLanguageContentUpdateOneRequiredInputInputObject =
   | Extract<keyof MultiLanguageContentUpdateOneRequiredInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface MultiLanguageContentUpdateDataInput {
   pt?: string | null
   en?: string | null
}
export type MultiLanguageContentUpdateDataInputInputObject =
   | Extract<keyof MultiLanguageContentUpdateDataInput, string>
   | { name: 'pt'; alias?: string }
   | { name: 'en'; alias?: string }

export interface MultiLanguageContentUpsertNestedInput {
   update?: MultiLanguageContentUpdateDataInput
   create?: MultiLanguageContentCreateInput
}
export type MultiLanguageContentUpsertNestedInputInputObject =
   | Extract<keyof MultiLanguageContentUpsertNestedInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface CompanyCreateInput {
   id?: string | null
   name?: string
   abbr?: string | null
   welcome?: MessageCreateOneInput
   tests?: TestCreateManyWithoutCompanyInput | null
}
export type CompanyCreateInputInputObject =
   | Extract<keyof CompanyCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'abbr'; alias?: string }
   | { name: 'welcome'; alias?: string }
   | { name: 'tests'; alias?: string }

export interface MessageCreateOneInput {
   create?: MessageCreateInput | null
   connect?: MessageWhereUniqueInput | null
}
export type MessageCreateOneInputInputObject =
   | Extract<keyof MessageCreateOneInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface TestCreateManyWithoutCompanyInput {
   create?: TestCreateWithoutCompanyInput[]
   connect?: TestWhereUniqueInput[]
}
export type TestCreateManyWithoutCompanyInputInputObject =
   | Extract<keyof TestCreateManyWithoutCompanyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface TestCreateWithoutCompanyInput {
   id?: string | null
   publics?: KeyUserTypeCreateManyInput | null
   languages?: KeyLanguageCreateManyInput | null
   instruction?: MessageCreateOneInput
   title?: MultiLanguageContentCreateOneInput
   steps?: StepCreateManyInput | null
   menus?: MenuCreateManyInput | null
   results?: TestResultCreateManyWithoutParentInput | null
   keys?: KeyCreateOneInput
}
export type TestCreateWithoutCompanyInputInputObject =
   | Extract<keyof TestCreateWithoutCompanyInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'publics'; alias?: string }
   | { name: 'languages'; alias?: string }
   | { name: 'instruction'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'results'; alias?: string }
   | { name: 'keys'; alias?: string }

export interface StepCreateManyInput {
   create?: StepCreateInput[]
   connect?: StepWhereUniqueInput[]
}
export type StepCreateManyInputInputObject =
   | Extract<keyof StepCreateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface StepCreateInput {
   id?: string | null
   type?: KeyUserTypeCreateManyInput | null
   question?: MultiLanguageContentCreateOneInput
   targets?: MenuCreateManyInput | null
   paths?: MenuCreateManyInput | null
   results?: StepResultCreateManyWithoutParentInput | null
}
export type StepCreateInputInputObject =
   | Extract<keyof StepCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'type'; alias?: string }
   | { name: 'question'; alias?: string }
   | { name: 'targets'; alias?: string }
   | { name: 'paths'; alias?: string }
   | { name: 'results'; alias?: string }

export interface MenuCreateManyInput {
   create?: MenuCreateInput[]
   connect?: MenuWhereUniqueInput[]
}
export type MenuCreateManyInputInputObject =
   | Extract<keyof MenuCreateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface MenuCreateInput {
   id?: string | null
   root?: boolean | null
   menus?: MenuCreateManyWithoutItemsInput | null
   name?: MultiLanguageContentCreateOneInput
   items?: MenuCreateManyWithoutMenusInput | null
}
export type MenuCreateInputInputObject =
   | Extract<keyof MenuCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'root'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'items'; alias?: string }

export interface MenuCreateManyWithoutItemsInput {
   create?: MenuCreateWithoutItemsInput[]
   connect?: MenuWhereUniqueInput[]
}
export type MenuCreateManyWithoutItemsInputInputObject =
   | Extract<keyof MenuCreateManyWithoutItemsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface MenuCreateWithoutItemsInput {
   id?: string | null
   root?: boolean | null
   menus?: MenuCreateManyWithoutItemsInput | null
   name?: MultiLanguageContentCreateOneInput
}
export type MenuCreateWithoutItemsInputInputObject =
   | Extract<keyof MenuCreateWithoutItemsInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'root'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'name'; alias?: string }

export interface MenuCreateManyWithoutMenusInput {
   create?: MenuCreateWithoutMenusInput[]
   connect?: MenuWhereUniqueInput[]
}
export type MenuCreateManyWithoutMenusInputInputObject =
   | Extract<keyof MenuCreateManyWithoutMenusInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface MenuCreateWithoutMenusInput {
   id?: string | null
   root?: boolean | null
   name?: MultiLanguageContentCreateOneInput
   items?: MenuCreateManyWithoutMenusInput | null
}
export type MenuCreateWithoutMenusInputInputObject =
   | Extract<keyof MenuCreateWithoutMenusInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'root'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'items'; alias?: string }

export interface StepResultCreateManyWithoutParentInput {
   create?: StepResultCreateWithoutParentInput[]
   connect?: StepResultWhereUniqueInput[]
}
export type StepResultCreateManyWithoutParentInputInputObject =
   | Extract<keyof StepResultCreateManyWithoutParentInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface StepResultCreateWithoutParentInput {
   id?: string | null
   result?: TestResultCreateOneWithoutStepsInput
   start?: string
   end?: string | null
   time?: number
   path?: MenuCreateManyInput | null
   status?: KeyStepResultStatusCreateOneInput
}
export type StepResultCreateWithoutParentInputInputObject =
   | Extract<keyof StepResultCreateWithoutParentInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'result'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'time'; alias?: string }
   | { name: 'path'; alias?: string }
   | { name: 'status'; alias?: string }

export interface TestResultCreateOneWithoutStepsInput {
   create?: TestResultCreateWithoutStepsInput | null
   connect?: TestResultWhereUniqueInput | null
}
export type TestResultCreateOneWithoutStepsInputInputObject =
   | Extract<keyof TestResultCreateOneWithoutStepsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface TestResultCreateWithoutStepsInput {
   id?: string | null
   parent?: TestCreateOneWithoutResultsInput
   start?: string
   end?: string | null
   duration?: number
   status?: KeyTestResultStatusCreateOneInput
}
export type TestResultCreateWithoutStepsInputInputObject =
   | Extract<keyof TestResultCreateWithoutStepsInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'parent'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'duration'; alias?: string }
   | { name: 'status'; alias?: string }

export interface TestCreateOneWithoutResultsInput {
   create?: TestCreateWithoutResultsInput | null
   connect?: TestWhereUniqueInput | null
}
export type TestCreateOneWithoutResultsInputInputObject =
   | Extract<keyof TestCreateOneWithoutResultsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface TestCreateWithoutResultsInput {
   id?: string | null
   publics?: KeyUserTypeCreateManyInput | null
   languages?: KeyLanguageCreateManyInput | null
   instruction?: MessageCreateOneInput
   company?: CompanyCreateOneWithoutTestsInput
   title?: MultiLanguageContentCreateOneInput
   steps?: StepCreateManyInput | null
   menus?: MenuCreateManyInput | null
   keys?: KeyCreateOneInput
}
export type TestCreateWithoutResultsInputInputObject =
   | Extract<keyof TestCreateWithoutResultsInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'publics'; alias?: string }
   | { name: 'languages'; alias?: string }
   | { name: 'instruction'; alias?: string }
   | { name: 'company'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'keys'; alias?: string }

export interface CompanyCreateOneWithoutTestsInput {
   create?: CompanyCreateWithoutTestsInput | null
   connect?: CompanyWhereUniqueInput | null
}
export type CompanyCreateOneWithoutTestsInputInputObject =
   | Extract<keyof CompanyCreateOneWithoutTestsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface CompanyCreateWithoutTestsInput {
   id?: string | null
   name?: string
   abbr?: string | null
   welcome?: MessageCreateOneInput
}
export type CompanyCreateWithoutTestsInputInputObject =
   | Extract<keyof CompanyCreateWithoutTestsInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'abbr'; alias?: string }
   | { name: 'welcome'; alias?: string }

export interface KeyCreateOneInput {
   create?: KeyCreateInput | null
   connect?: KeyWhereUniqueInput | null
}
export type KeyCreateOneInputInputObject =
   | Extract<keyof KeyCreateOneInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyTestResultStatusCreateOneInput {
   create?: KeyTestResultStatusCreateInput | null
   connect?: KeyTestResultStatusWhereUniqueInput | null
}
export type KeyTestResultStatusCreateOneInputInputObject =
   | Extract<keyof KeyTestResultStatusCreateOneInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyStepResultStatusCreateOneInput {
   create?: KeyStepResultStatusCreateInput | null
   connect?: KeyStepResultStatusWhereUniqueInput | null
}
export type KeyStepResultStatusCreateOneInputInputObject =
   | Extract<keyof KeyStepResultStatusCreateOneInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface TestResultCreateManyWithoutParentInput {
   create?: TestResultCreateWithoutParentInput[]
   connect?: TestResultWhereUniqueInput[]
}
export type TestResultCreateManyWithoutParentInputInputObject =
   | Extract<keyof TestResultCreateManyWithoutParentInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface TestResultCreateWithoutParentInput {
   id?: string | null
   start?: string
   end?: string | null
   duration?: number
   steps?: StepResultCreateManyWithoutResultInput | null
   status?: KeyTestResultStatusCreateOneInput
}
export type TestResultCreateWithoutParentInputInputObject =
   | Extract<keyof TestResultCreateWithoutParentInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'duration'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'status'; alias?: string }

export interface StepResultCreateManyWithoutResultInput {
   create?: StepResultCreateWithoutResultInput[]
   connect?: StepResultWhereUniqueInput[]
}
export type StepResultCreateManyWithoutResultInputInputObject =
   | Extract<keyof StepResultCreateManyWithoutResultInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface StepResultCreateWithoutResultInput {
   id?: string | null
   parent?: StepCreateOneWithoutResultsInput
   start?: string
   end?: string | null
   time?: number
   path?: MenuCreateManyInput | null
   status?: KeyStepResultStatusCreateOneInput
}
export type StepResultCreateWithoutResultInputInputObject =
   | Extract<keyof StepResultCreateWithoutResultInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'parent'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'time'; alias?: string }
   | { name: 'path'; alias?: string }
   | { name: 'status'; alias?: string }

export interface StepCreateOneWithoutResultsInput {
   create?: StepCreateWithoutResultsInput | null
   connect?: StepWhereUniqueInput | null
}
export type StepCreateOneWithoutResultsInputInputObject =
   | Extract<keyof StepCreateOneWithoutResultsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface StepCreateWithoutResultsInput {
   id?: string | null
   type?: KeyUserTypeCreateManyInput | null
   question?: MultiLanguageContentCreateOneInput
   targets?: MenuCreateManyInput | null
   paths?: MenuCreateManyInput | null
}
export type StepCreateWithoutResultsInputInputObject =
   | Extract<keyof StepCreateWithoutResultsInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'type'; alias?: string }
   | { name: 'question'; alias?: string }
   | { name: 'targets'; alias?: string }
   | { name: 'paths'; alias?: string }

export interface CompanyUpdateInput {
   name?: string | null
   abbr?: string | null
   welcome?: MessageUpdateOneRequiredInput | null
   tests?: TestUpdateManyWithoutCompanyInput | null
}
export type CompanyUpdateInputInputObject =
   | Extract<keyof CompanyUpdateInput, string>
   | { name: 'name'; alias?: string }
   | { name: 'abbr'; alias?: string }
   | { name: 'welcome'; alias?: string }
   | { name: 'tests'; alias?: string }

export interface MessageUpdateOneRequiredInput {
   create?: MessageCreateInput | null
   update?: MessageUpdateDataInput | null
   upsert?: MessageUpsertNestedInput | null
   connect?: MessageWhereUniqueInput | null
}
export type MessageUpdateOneRequiredInputInputObject =
   | Extract<keyof MessageUpdateOneRequiredInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface MessageUpdateDataInput {
   title?: MultiLanguageContentUpdateOneRequiredInput | null
   message?: MultiLanguageContentUpdateOneRequiredInput | null
}
export type MessageUpdateDataInputInputObject =
   | Extract<keyof MessageUpdateDataInput, string>
   | { name: 'title'; alias?: string }
   | { name: 'message'; alias?: string }

export interface MessageUpsertNestedInput {
   update?: MessageUpdateDataInput
   create?: MessageCreateInput
}
export type MessageUpsertNestedInputInputObject =
   | Extract<keyof MessageUpsertNestedInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface TestUpdateManyWithoutCompanyInput {
   create?: TestCreateWithoutCompanyInput[]
   delete?: TestWhereUniqueInput[]
   connect?: TestWhereUniqueInput[]
   set?: TestWhereUniqueInput[]
   disconnect?: TestWhereUniqueInput[]
   update?: TestUpdateWithWhereUniqueWithoutCompanyInput[]
   upsert?: TestUpsertWithWhereUniqueWithoutCompanyInput[]
   deleteMany?: TestScalarWhereInput[]
}
export type TestUpdateManyWithoutCompanyInputInputObject =
   | Extract<keyof TestUpdateManyWithoutCompanyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'deleteMany'; alias?: string }

export interface TestUpdateWithWhereUniqueWithoutCompanyInput {
   where?: TestWhereUniqueInput
   data?: TestUpdateWithoutCompanyDataInput
}
export type TestUpdateWithWhereUniqueWithoutCompanyInputInputObject =
   | Extract<keyof TestUpdateWithWhereUniqueWithoutCompanyInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface TestUpdateWithoutCompanyDataInput {
   publics?: KeyUserTypeUpdateManyInput | null
   languages?: KeyLanguageUpdateManyInput | null
   instruction?: MessageUpdateOneRequiredInput | null
   title?: MultiLanguageContentUpdateOneRequiredInput | null
   steps?: StepUpdateManyInput | null
   menus?: MenuUpdateManyInput | null
   results?: TestResultUpdateManyWithoutParentInput | null
   keys?: KeyUpdateOneRequiredInput | null
}
export type TestUpdateWithoutCompanyDataInputInputObject =
   | Extract<keyof TestUpdateWithoutCompanyDataInput, string>
   | { name: 'publics'; alias?: string }
   | { name: 'languages'; alias?: string }
   | { name: 'instruction'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'results'; alias?: string }
   | { name: 'keys'; alias?: string }

export interface StepUpdateManyInput {
   create?: StepCreateInput[]
   update?: StepUpdateWithWhereUniqueNestedInput[]
   upsert?: StepUpsertWithWhereUniqueNestedInput[]
   delete?: StepWhereUniqueInput[]
   connect?: StepWhereUniqueInput[]
   set?: StepWhereUniqueInput[]
   disconnect?: StepWhereUniqueInput[]
   deleteMany?: StepScalarWhereInput[]
}
export type StepUpdateManyInputInputObject =
   | Extract<keyof StepUpdateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'deleteMany'; alias?: string }

export interface StepUpdateWithWhereUniqueNestedInput {
   where?: StepWhereUniqueInput
   data?: StepUpdateDataInput
}
export type StepUpdateWithWhereUniqueNestedInputInputObject =
   | Extract<keyof StepUpdateWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface StepUpdateDataInput {
   type?: KeyUserTypeUpdateManyInput | null
   question?: MultiLanguageContentUpdateOneRequiredInput | null
   targets?: MenuUpdateManyInput | null
   paths?: MenuUpdateManyInput | null
   results?: StepResultUpdateManyWithoutParentInput | null
}
export type StepUpdateDataInputInputObject =
   | Extract<keyof StepUpdateDataInput, string>
   | { name: 'type'; alias?: string }
   | { name: 'question'; alias?: string }
   | { name: 'targets'; alias?: string }
   | { name: 'paths'; alias?: string }
   | { name: 'results'; alias?: string }

export interface MenuUpdateManyInput {
   create?: MenuCreateInput[]
   update?: MenuUpdateWithWhereUniqueNestedInput[]
   upsert?: MenuUpsertWithWhereUniqueNestedInput[]
   delete?: MenuWhereUniqueInput[]
   connect?: MenuWhereUniqueInput[]
   set?: MenuWhereUniqueInput[]
   disconnect?: MenuWhereUniqueInput[]
   deleteMany?: MenuScalarWhereInput[]
   updateMany?: MenuUpdateManyWithWhereNestedInput[]
}
export type MenuUpdateManyInputInputObject =
   | Extract<keyof MenuUpdateManyInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface MenuUpdateWithWhereUniqueNestedInput {
   where?: MenuWhereUniqueInput
   data?: MenuUpdateDataInput
}
export type MenuUpdateWithWhereUniqueNestedInputInputObject =
   | Extract<keyof MenuUpdateWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface MenuUpdateDataInput {
   root?: boolean | null
   menus?: MenuUpdateManyWithoutItemsInput | null
   name?: MultiLanguageContentUpdateOneRequiredInput | null
   items?: MenuUpdateManyWithoutMenusInput | null
}
export type MenuUpdateDataInputInputObject =
   | Extract<keyof MenuUpdateDataInput, string>
   | { name: 'root'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'items'; alias?: string }

export interface MenuUpdateManyWithoutItemsInput {
   create?: MenuCreateWithoutItemsInput[]
   delete?: MenuWhereUniqueInput[]
   connect?: MenuWhereUniqueInput[]
   set?: MenuWhereUniqueInput[]
   disconnect?: MenuWhereUniqueInput[]
   update?: MenuUpdateWithWhereUniqueWithoutItemsInput[]
   upsert?: MenuUpsertWithWhereUniqueWithoutItemsInput[]
   deleteMany?: MenuScalarWhereInput[]
   updateMany?: MenuUpdateManyWithWhereNestedInput[]
}
export type MenuUpdateManyWithoutItemsInputInputObject =
   | Extract<keyof MenuUpdateManyWithoutItemsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface MenuUpdateWithWhereUniqueWithoutItemsInput {
   where?: MenuWhereUniqueInput
   data?: MenuUpdateWithoutItemsDataInput
}
export type MenuUpdateWithWhereUniqueWithoutItemsInputInputObject =
   | Extract<keyof MenuUpdateWithWhereUniqueWithoutItemsInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface MenuUpdateWithoutItemsDataInput {
   root?: boolean | null
   menus?: MenuUpdateManyWithoutItemsInput | null
   name?: MultiLanguageContentUpdateOneRequiredInput | null
}
export type MenuUpdateWithoutItemsDataInputInputObject =
   | Extract<keyof MenuUpdateWithoutItemsDataInput, string>
   | { name: 'root'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'name'; alias?: string }

export interface MenuUpsertWithWhereUniqueWithoutItemsInput {
   where?: MenuWhereUniqueInput
   update?: MenuUpdateWithoutItemsDataInput
   create?: MenuCreateWithoutItemsInput
}
export type MenuUpsertWithWhereUniqueWithoutItemsInputInputObject =
   | Extract<keyof MenuUpsertWithWhereUniqueWithoutItemsInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface MenuScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   root?: boolean | null
   root_not?: boolean | null
   AND?: MenuScalarWhereInput[]
   OR?: MenuScalarWhereInput[]
   NOT?: MenuScalarWhereInput[]
}
export type MenuScalarWhereInputInputObject =
   | Extract<keyof MenuScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'root'; alias?: string }
   | { name: 'root_not'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface MenuUpdateManyWithWhereNestedInput {
   where?: MenuScalarWhereInput
   data?: MenuUpdateManyDataInput
}
export type MenuUpdateManyWithWhereNestedInputInputObject =
   | Extract<keyof MenuUpdateManyWithWhereNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface MenuUpdateManyDataInput {
   root?: boolean | null
}
export type MenuUpdateManyDataInputInputObject =
   | Extract<keyof MenuUpdateManyDataInput, string>
   | { name: 'root'; alias?: string }

export interface MenuUpdateManyWithoutMenusInput {
   create?: MenuCreateWithoutMenusInput[]
   delete?: MenuWhereUniqueInput[]
   connect?: MenuWhereUniqueInput[]
   set?: MenuWhereUniqueInput[]
   disconnect?: MenuWhereUniqueInput[]
   update?: MenuUpdateWithWhereUniqueWithoutMenusInput[]
   upsert?: MenuUpsertWithWhereUniqueWithoutMenusInput[]
   deleteMany?: MenuScalarWhereInput[]
   updateMany?: MenuUpdateManyWithWhereNestedInput[]
}
export type MenuUpdateManyWithoutMenusInputInputObject =
   | Extract<keyof MenuUpdateManyWithoutMenusInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface MenuUpdateWithWhereUniqueWithoutMenusInput {
   where?: MenuWhereUniqueInput
   data?: MenuUpdateWithoutMenusDataInput
}
export type MenuUpdateWithWhereUniqueWithoutMenusInputInputObject =
   | Extract<keyof MenuUpdateWithWhereUniqueWithoutMenusInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface MenuUpdateWithoutMenusDataInput {
   root?: boolean | null
   name?: MultiLanguageContentUpdateOneRequiredInput | null
   items?: MenuUpdateManyWithoutMenusInput | null
}
export type MenuUpdateWithoutMenusDataInputInputObject =
   | Extract<keyof MenuUpdateWithoutMenusDataInput, string>
   | { name: 'root'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'items'; alias?: string }

export interface MenuUpsertWithWhereUniqueWithoutMenusInput {
   where?: MenuWhereUniqueInput
   update?: MenuUpdateWithoutMenusDataInput
   create?: MenuCreateWithoutMenusInput
}
export type MenuUpsertWithWhereUniqueWithoutMenusInputInputObject =
   | Extract<keyof MenuUpsertWithWhereUniqueWithoutMenusInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface MenuUpsertWithWhereUniqueNestedInput {
   where?: MenuWhereUniqueInput
   update?: MenuUpdateDataInput
   create?: MenuCreateInput
}
export type MenuUpsertWithWhereUniqueNestedInputInputObject =
   | Extract<keyof MenuUpsertWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface StepResultUpdateManyWithoutParentInput {
   create?: StepResultCreateWithoutParentInput[]
   delete?: StepResultWhereUniqueInput[]
   connect?: StepResultWhereUniqueInput[]
   set?: StepResultWhereUniqueInput[]
   disconnect?: StepResultWhereUniqueInput[]
   update?: StepResultUpdateWithWhereUniqueWithoutParentInput[]
   upsert?: StepResultUpsertWithWhereUniqueWithoutParentInput[]
   deleteMany?: StepResultScalarWhereInput[]
   updateMany?: StepResultUpdateManyWithWhereNestedInput[]
}
export type StepResultUpdateManyWithoutParentInputInputObject =
   | Extract<keyof StepResultUpdateManyWithoutParentInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface StepResultUpdateWithWhereUniqueWithoutParentInput {
   where?: StepResultWhereUniqueInput
   data?: StepResultUpdateWithoutParentDataInput
}
export type StepResultUpdateWithWhereUniqueWithoutParentInputInputObject =
   | Extract<keyof StepResultUpdateWithWhereUniqueWithoutParentInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface StepResultUpdateWithoutParentDataInput {
   result?: TestResultUpdateOneRequiredWithoutStepsInput | null
   start?: string | null
   end?: string | null
   time?: number | null
   path?: MenuUpdateManyInput | null
   status?: KeyStepResultStatusUpdateOneRequiredInput | null
}
export type StepResultUpdateWithoutParentDataInputInputObject =
   | Extract<keyof StepResultUpdateWithoutParentDataInput, string>
   | { name: 'result'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'time'; alias?: string }
   | { name: 'path'; alias?: string }
   | { name: 'status'; alias?: string }

export interface TestResultUpdateOneRequiredWithoutStepsInput {
   create?: TestResultCreateWithoutStepsInput | null
   update?: TestResultUpdateWithoutStepsDataInput | null
   upsert?: TestResultUpsertWithoutStepsInput | null
   connect?: TestResultWhereUniqueInput | null
}
export type TestResultUpdateOneRequiredWithoutStepsInputInputObject =
   | Extract<keyof TestResultUpdateOneRequiredWithoutStepsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface TestResultUpdateWithoutStepsDataInput {
   parent?: TestUpdateOneRequiredWithoutResultsInput | null
   start?: string | null
   end?: string | null
   duration?: number | null
   status?: KeyTestResultStatusUpdateOneRequiredInput | null
}
export type TestResultUpdateWithoutStepsDataInputInputObject =
   | Extract<keyof TestResultUpdateWithoutStepsDataInput, string>
   | { name: 'parent'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'duration'; alias?: string }
   | { name: 'status'; alias?: string }

export interface TestUpdateOneRequiredWithoutResultsInput {
   create?: TestCreateWithoutResultsInput | null
   update?: TestUpdateWithoutResultsDataInput | null
   upsert?: TestUpsertWithoutResultsInput | null
   connect?: TestWhereUniqueInput | null
}
export type TestUpdateOneRequiredWithoutResultsInputInputObject =
   | Extract<keyof TestUpdateOneRequiredWithoutResultsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface TestUpdateWithoutResultsDataInput {
   publics?: KeyUserTypeUpdateManyInput | null
   languages?: KeyLanguageUpdateManyInput | null
   instruction?: MessageUpdateOneRequiredInput | null
   company?: CompanyUpdateOneRequiredWithoutTestsInput | null
   title?: MultiLanguageContentUpdateOneRequiredInput | null
   steps?: StepUpdateManyInput | null
   menus?: MenuUpdateManyInput | null
   keys?: KeyUpdateOneRequiredInput | null
}
export type TestUpdateWithoutResultsDataInputInputObject =
   | Extract<keyof TestUpdateWithoutResultsDataInput, string>
   | { name: 'publics'; alias?: string }
   | { name: 'languages'; alias?: string }
   | { name: 'instruction'; alias?: string }
   | { name: 'company'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'keys'; alias?: string }

export interface CompanyUpdateOneRequiredWithoutTestsInput {
   create?: CompanyCreateWithoutTestsInput | null
   update?: CompanyUpdateWithoutTestsDataInput | null
   upsert?: CompanyUpsertWithoutTestsInput | null
   connect?: CompanyWhereUniqueInput | null
}
export type CompanyUpdateOneRequiredWithoutTestsInputInputObject =
   | Extract<keyof CompanyUpdateOneRequiredWithoutTestsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface CompanyUpdateWithoutTestsDataInput {
   name?: string | null
   abbr?: string | null
   welcome?: MessageUpdateOneRequiredInput | null
}
export type CompanyUpdateWithoutTestsDataInputInputObject =
   | Extract<keyof CompanyUpdateWithoutTestsDataInput, string>
   | { name: 'name'; alias?: string }
   | { name: 'abbr'; alias?: string }
   | { name: 'welcome'; alias?: string }

export interface CompanyUpsertWithoutTestsInput {
   update?: CompanyUpdateWithoutTestsDataInput
   create?: CompanyCreateWithoutTestsInput
}
export type CompanyUpsertWithoutTestsInputInputObject =
   | Extract<keyof CompanyUpsertWithoutTestsInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface KeyUpdateOneRequiredInput {
   create?: KeyCreateInput | null
   update?: KeyUpdateDataInput | null
   upsert?: KeyUpsertNestedInput | null
   connect?: KeyWhereUniqueInput | null
}
export type KeyUpdateOneRequiredInputInputObject =
   | Extract<keyof KeyUpdateOneRequiredInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyUpdateDataInput {
   userTypes?: KeyUserTypeUpdateManyInput | null
   testResultStatus?: KeyTestResultStatusUpdateManyInput | null
   stepResultStatus?: KeyStepResultStatusUpdateManyInput | null
   languages?: KeyLanguageUpdateManyInput | null
}
export type KeyUpdateDataInputInputObject =
   | Extract<keyof KeyUpdateDataInput, string>
   | { name: 'userTypes'; alias?: string }
   | { name: 'testResultStatus'; alias?: string }
   | { name: 'stepResultStatus'; alias?: string }
   | { name: 'languages'; alias?: string }

export interface KeyUpsertNestedInput {
   update?: KeyUpdateDataInput
   create?: KeyCreateInput
}
export type KeyUpsertNestedInputInputObject =
   | Extract<keyof KeyUpsertNestedInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface TestUpsertWithoutResultsInput {
   update?: TestUpdateWithoutResultsDataInput
   create?: TestCreateWithoutResultsInput
}
export type TestUpsertWithoutResultsInputInputObject =
   | Extract<keyof TestUpsertWithoutResultsInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface KeyTestResultStatusUpdateOneRequiredInput {
   create?: KeyTestResultStatusCreateInput | null
   update?: KeyTestResultStatusUpdateDataInput | null
   upsert?: KeyTestResultStatusUpsertNestedInput | null
   connect?: KeyTestResultStatusWhereUniqueInput | null
}
export type KeyTestResultStatusUpdateOneRequiredInputInputObject =
   | Extract<keyof KeyTestResultStatusUpdateOneRequiredInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyTestResultStatusUpsertNestedInput {
   update?: KeyTestResultStatusUpdateDataInput
   create?: KeyTestResultStatusCreateInput
}
export type KeyTestResultStatusUpsertNestedInputInputObject =
   | Extract<keyof KeyTestResultStatusUpsertNestedInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface TestResultUpsertWithoutStepsInput {
   update?: TestResultUpdateWithoutStepsDataInput
   create?: TestResultCreateWithoutStepsInput
}
export type TestResultUpsertWithoutStepsInputInputObject =
   | Extract<keyof TestResultUpsertWithoutStepsInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface KeyStepResultStatusUpdateOneRequiredInput {
   create?: KeyStepResultStatusCreateInput | null
   update?: KeyStepResultStatusUpdateDataInput | null
   upsert?: KeyStepResultStatusUpsertNestedInput | null
   connect?: KeyStepResultStatusWhereUniqueInput | null
}
export type KeyStepResultStatusUpdateOneRequiredInputInputObject =
   | Extract<keyof KeyStepResultStatusUpdateOneRequiredInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface KeyStepResultStatusUpsertNestedInput {
   update?: KeyStepResultStatusUpdateDataInput
   create?: KeyStepResultStatusCreateInput
}
export type KeyStepResultStatusUpsertNestedInputInputObject =
   | Extract<keyof KeyStepResultStatusUpsertNestedInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface StepResultUpsertWithWhereUniqueWithoutParentInput {
   where?: StepResultWhereUniqueInput
   update?: StepResultUpdateWithoutParentDataInput
   create?: StepResultCreateWithoutParentInput
}
export type StepResultUpsertWithWhereUniqueWithoutParentInputInputObject =
   | Extract<keyof StepResultUpsertWithWhereUniqueWithoutParentInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface StepResultScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   start?: string | null
   start_not?: string | null
   start_in?: string[]
   start_not_in?: string[]
   start_lt?: string | null
   start_lte?: string | null
   start_gt?: string | null
   start_gte?: string | null
   end?: string | null
   end_not?: string | null
   end_in?: string[]
   end_not_in?: string[]
   end_lt?: string | null
   end_lte?: string | null
   end_gt?: string | null
   end_gte?: string | null
   time?: number | null
   time_not?: number | null
   time_in?: number[]
   time_not_in?: number[]
   time_lt?: number | null
   time_lte?: number | null
   time_gt?: number | null
   time_gte?: number | null
   AND?: StepResultScalarWhereInput[]
   OR?: StepResultScalarWhereInput[]
   NOT?: StepResultScalarWhereInput[]
}
export type StepResultScalarWhereInputInputObject =
   | Extract<keyof StepResultScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'start_not'; alias?: string }
   | { name: 'start_in'; alias?: string }
   | { name: 'start_not_in'; alias?: string }
   | { name: 'start_lt'; alias?: string }
   | { name: 'start_lte'; alias?: string }
   | { name: 'start_gt'; alias?: string }
   | { name: 'start_gte'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'end_not'; alias?: string }
   | { name: 'end_in'; alias?: string }
   | { name: 'end_not_in'; alias?: string }
   | { name: 'end_lt'; alias?: string }
   | { name: 'end_lte'; alias?: string }
   | { name: 'end_gt'; alias?: string }
   | { name: 'end_gte'; alias?: string }
   | { name: 'time'; alias?: string }
   | { name: 'time_not'; alias?: string }
   | { name: 'time_in'; alias?: string }
   | { name: 'time_not_in'; alias?: string }
   | { name: 'time_lt'; alias?: string }
   | { name: 'time_lte'; alias?: string }
   | { name: 'time_gt'; alias?: string }
   | { name: 'time_gte'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface StepResultUpdateManyWithWhereNestedInput {
   where?: StepResultScalarWhereInput
   data?: StepResultUpdateManyDataInput
}
export type StepResultUpdateManyWithWhereNestedInputInputObject =
   | Extract<keyof StepResultUpdateManyWithWhereNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface StepResultUpdateManyDataInput {
   start?: string | null
   end?: string | null
   time?: number | null
}
export type StepResultUpdateManyDataInputInputObject =
   | Extract<keyof StepResultUpdateManyDataInput, string>
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'time'; alias?: string }

export interface StepUpsertWithWhereUniqueNestedInput {
   where?: StepWhereUniqueInput
   update?: StepUpdateDataInput
   create?: StepCreateInput
}
export type StepUpsertWithWhereUniqueNestedInputInputObject =
   | Extract<keyof StepUpsertWithWhereUniqueNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface StepScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   AND?: StepScalarWhereInput[]
   OR?: StepScalarWhereInput[]
   NOT?: StepScalarWhereInput[]
}
export type StepScalarWhereInputInputObject =
   | Extract<keyof StepScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface TestResultUpdateManyWithoutParentInput {
   create?: TestResultCreateWithoutParentInput[]
   delete?: TestResultWhereUniqueInput[]
   connect?: TestResultWhereUniqueInput[]
   set?: TestResultWhereUniqueInput[]
   disconnect?: TestResultWhereUniqueInput[]
   update?: TestResultUpdateWithWhereUniqueWithoutParentInput[]
   upsert?: TestResultUpsertWithWhereUniqueWithoutParentInput[]
   deleteMany?: TestResultScalarWhereInput[]
   updateMany?: TestResultUpdateManyWithWhereNestedInput[]
}
export type TestResultUpdateManyWithoutParentInputInputObject =
   | Extract<keyof TestResultUpdateManyWithoutParentInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface TestResultUpdateWithWhereUniqueWithoutParentInput {
   where?: TestResultWhereUniqueInput
   data?: TestResultUpdateWithoutParentDataInput
}
export type TestResultUpdateWithWhereUniqueWithoutParentInputInputObject =
   | Extract<keyof TestResultUpdateWithWhereUniqueWithoutParentInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface TestResultUpdateWithoutParentDataInput {
   start?: string | null
   end?: string | null
   duration?: number | null
   steps?: StepResultUpdateManyWithoutResultInput | null
   status?: KeyTestResultStatusUpdateOneRequiredInput | null
}
export type TestResultUpdateWithoutParentDataInputInputObject =
   | Extract<keyof TestResultUpdateWithoutParentDataInput, string>
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'duration'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'status'; alias?: string }

export interface StepResultUpdateManyWithoutResultInput {
   create?: StepResultCreateWithoutResultInput[]
   delete?: StepResultWhereUniqueInput[]
   connect?: StepResultWhereUniqueInput[]
   set?: StepResultWhereUniqueInput[]
   disconnect?: StepResultWhereUniqueInput[]
   update?: StepResultUpdateWithWhereUniqueWithoutResultInput[]
   upsert?: StepResultUpsertWithWhereUniqueWithoutResultInput[]
   deleteMany?: StepResultScalarWhereInput[]
   updateMany?: StepResultUpdateManyWithWhereNestedInput[]
}
export type StepResultUpdateManyWithoutResultInputInputObject =
   | Extract<keyof StepResultUpdateManyWithoutResultInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'delete'; alias?: string }
   | { name: 'connect'; alias?: string }
   | { name: 'set'; alias?: string }
   | { name: 'disconnect'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'deleteMany'; alias?: string }
   | { name: 'updateMany'; alias?: string }

export interface StepResultUpdateWithWhereUniqueWithoutResultInput {
   where?: StepResultWhereUniqueInput
   data?: StepResultUpdateWithoutResultDataInput
}
export type StepResultUpdateWithWhereUniqueWithoutResultInputInputObject =
   | Extract<keyof StepResultUpdateWithWhereUniqueWithoutResultInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface StepResultUpdateWithoutResultDataInput {
   parent?: StepUpdateOneRequiredWithoutResultsInput | null
   start?: string | null
   end?: string | null
   time?: number | null
   path?: MenuUpdateManyInput | null
   status?: KeyStepResultStatusUpdateOneRequiredInput | null
}
export type StepResultUpdateWithoutResultDataInputInputObject =
   | Extract<keyof StepResultUpdateWithoutResultDataInput, string>
   | { name: 'parent'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'time'; alias?: string }
   | { name: 'path'; alias?: string }
   | { name: 'status'; alias?: string }

export interface StepUpdateOneRequiredWithoutResultsInput {
   create?: StepCreateWithoutResultsInput | null
   update?: StepUpdateWithoutResultsDataInput | null
   upsert?: StepUpsertWithoutResultsInput | null
   connect?: StepWhereUniqueInput | null
}
export type StepUpdateOneRequiredWithoutResultsInputInputObject =
   | Extract<keyof StepUpdateOneRequiredWithoutResultsInput, string>
   | { name: 'create'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'upsert'; alias?: string }
   | { name: 'connect'; alias?: string }

export interface StepUpdateWithoutResultsDataInput {
   type?: KeyUserTypeUpdateManyInput | null
   question?: MultiLanguageContentUpdateOneRequiredInput | null
   targets?: MenuUpdateManyInput | null
   paths?: MenuUpdateManyInput | null
}
export type StepUpdateWithoutResultsDataInputInputObject =
   | Extract<keyof StepUpdateWithoutResultsDataInput, string>
   | { name: 'type'; alias?: string }
   | { name: 'question'; alias?: string }
   | { name: 'targets'; alias?: string }
   | { name: 'paths'; alias?: string }

export interface StepUpsertWithoutResultsInput {
   update?: StepUpdateWithoutResultsDataInput
   create?: StepCreateWithoutResultsInput
}
export type StepUpsertWithoutResultsInputInputObject =
   | Extract<keyof StepUpsertWithoutResultsInput, string>
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface StepResultUpsertWithWhereUniqueWithoutResultInput {
   where?: StepResultWhereUniqueInput
   update?: StepResultUpdateWithoutResultDataInput
   create?: StepResultCreateWithoutResultInput
}
export type StepResultUpsertWithWhereUniqueWithoutResultInputInputObject =
   | Extract<keyof StepResultUpsertWithWhereUniqueWithoutResultInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface TestResultUpsertWithWhereUniqueWithoutParentInput {
   where?: TestResultWhereUniqueInput
   update?: TestResultUpdateWithoutParentDataInput
   create?: TestResultCreateWithoutParentInput
}
export type TestResultUpsertWithWhereUniqueWithoutParentInputInputObject =
   | Extract<keyof TestResultUpsertWithWhereUniqueWithoutParentInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface TestResultScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   start?: string | null
   start_not?: string | null
   start_in?: string[]
   start_not_in?: string[]
   start_lt?: string | null
   start_lte?: string | null
   start_gt?: string | null
   start_gte?: string | null
   end?: string | null
   end_not?: string | null
   end_in?: string[]
   end_not_in?: string[]
   end_lt?: string | null
   end_lte?: string | null
   end_gt?: string | null
   end_gte?: string | null
   duration?: number | null
   duration_not?: number | null
   duration_in?: number[]
   duration_not_in?: number[]
   duration_lt?: number | null
   duration_lte?: number | null
   duration_gt?: number | null
   duration_gte?: number | null
   AND?: TestResultScalarWhereInput[]
   OR?: TestResultScalarWhereInput[]
   NOT?: TestResultScalarWhereInput[]
}
export type TestResultScalarWhereInputInputObject =
   | Extract<keyof TestResultScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'start_not'; alias?: string }
   | { name: 'start_in'; alias?: string }
   | { name: 'start_not_in'; alias?: string }
   | { name: 'start_lt'; alias?: string }
   | { name: 'start_lte'; alias?: string }
   | { name: 'start_gt'; alias?: string }
   | { name: 'start_gte'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'end_not'; alias?: string }
   | { name: 'end_in'; alias?: string }
   | { name: 'end_not_in'; alias?: string }
   | { name: 'end_lt'; alias?: string }
   | { name: 'end_lte'; alias?: string }
   | { name: 'end_gt'; alias?: string }
   | { name: 'end_gte'; alias?: string }
   | { name: 'duration'; alias?: string }
   | { name: 'duration_not'; alias?: string }
   | { name: 'duration_in'; alias?: string }
   | { name: 'duration_not_in'; alias?: string }
   | { name: 'duration_lt'; alias?: string }
   | { name: 'duration_lte'; alias?: string }
   | { name: 'duration_gt'; alias?: string }
   | { name: 'duration_gte'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface TestResultUpdateManyWithWhereNestedInput {
   where?: TestResultScalarWhereInput
   data?: TestResultUpdateManyDataInput
}
export type TestResultUpdateManyWithWhereNestedInputInputObject =
   | Extract<keyof TestResultUpdateManyWithWhereNestedInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'data'; alias?: string }

export interface TestResultUpdateManyDataInput {
   start?: string | null
   end?: string | null
   duration?: number | null
}
export type TestResultUpdateManyDataInputInputObject =
   | Extract<keyof TestResultUpdateManyDataInput, string>
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'duration'; alias?: string }

export interface TestUpsertWithWhereUniqueWithoutCompanyInput {
   where?: TestWhereUniqueInput
   update?: TestUpdateWithoutCompanyDataInput
   create?: TestCreateWithoutCompanyInput
}
export type TestUpsertWithWhereUniqueWithoutCompanyInputInputObject =
   | Extract<keyof TestUpsertWithWhereUniqueWithoutCompanyInput, string>
   | { name: 'where'; alias?: string }
   | { name: 'update'; alias?: string }
   | { name: 'create'; alias?: string }

export interface TestScalarWhereInput {
   id?: string | null
   id_not?: string | null
   id_in?: string[]
   id_not_in?: string[]
   id_lt?: string | null
   id_lte?: string | null
   id_gt?: string | null
   id_gte?: string | null
   id_contains?: string | null
   id_not_contains?: string | null
   id_starts_with?: string | null
   id_not_starts_with?: string | null
   id_ends_with?: string | null
   id_not_ends_with?: string | null
   AND?: TestScalarWhereInput[]
   OR?: TestScalarWhereInput[]
   NOT?: TestScalarWhereInput[]
}
export type TestScalarWhereInputInputObject =
   | Extract<keyof TestScalarWhereInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'id_not'; alias?: string }
   | { name: 'id_in'; alias?: string }
   | { name: 'id_not_in'; alias?: string }
   | { name: 'id_lt'; alias?: string }
   | { name: 'id_lte'; alias?: string }
   | { name: 'id_gt'; alias?: string }
   | { name: 'id_gte'; alias?: string }
   | { name: 'id_contains'; alias?: string }
   | { name: 'id_not_contains'; alias?: string }
   | { name: 'id_starts_with'; alias?: string }
   | { name: 'id_not_starts_with'; alias?: string }
   | { name: 'id_ends_with'; alias?: string }
   | { name: 'id_not_ends_with'; alias?: string }
   | { name: 'AND'; alias?: string }
   | { name: 'OR'; alias?: string }
   | { name: 'NOT'; alias?: string }

export interface CompanyUpdateManyMutationInput {
   name?: string | null
   abbr?: string | null
}
export type CompanyUpdateManyMutationInputInputObject =
   | Extract<keyof CompanyUpdateManyMutationInput, string>
   | { name: 'name'; alias?: string }
   | { name: 'abbr'; alias?: string }

export interface TestCreateInput {
   id?: string | null
   publics?: KeyUserTypeCreateManyInput | null
   languages?: KeyLanguageCreateManyInput | null
   instruction?: MessageCreateOneInput
   company?: CompanyCreateOneWithoutTestsInput
   title?: MultiLanguageContentCreateOneInput
   steps?: StepCreateManyInput | null
   menus?: MenuCreateManyInput | null
   results?: TestResultCreateManyWithoutParentInput | null
   keys?: KeyCreateOneInput
}
export type TestCreateInputInputObject =
   | Extract<keyof TestCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'publics'; alias?: string }
   | { name: 'languages'; alias?: string }
   | { name: 'instruction'; alias?: string }
   | { name: 'company'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'results'; alias?: string }
   | { name: 'keys'; alias?: string }

export interface TestUpdateInput {
   publics?: KeyUserTypeUpdateManyInput | null
   languages?: KeyLanguageUpdateManyInput | null
   instruction?: MessageUpdateOneRequiredInput | null
   company?: CompanyUpdateOneRequiredWithoutTestsInput | null
   title?: MultiLanguageContentUpdateOneRequiredInput | null
   steps?: StepUpdateManyInput | null
   menus?: MenuUpdateManyInput | null
   results?: TestResultUpdateManyWithoutParentInput | null
   keys?: KeyUpdateOneRequiredInput | null
}
export type TestUpdateInputInputObject =
   | Extract<keyof TestUpdateInput, string>
   | { name: 'publics'; alias?: string }
   | { name: 'languages'; alias?: string }
   | { name: 'instruction'; alias?: string }
   | { name: 'company'; alias?: string }
   | { name: 'title'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'results'; alias?: string }
   | { name: 'keys'; alias?: string }

export interface MenuUpdateInput {
   root?: boolean | null
   menus?: MenuUpdateManyWithoutItemsInput | null
   name?: MultiLanguageContentUpdateOneRequiredInput | null
   items?: MenuUpdateManyWithoutMenusInput | null
}
export type MenuUpdateInputInputObject =
   | Extract<keyof MenuUpdateInput, string>
   | { name: 'root'; alias?: string }
   | { name: 'menus'; alias?: string }
   | { name: 'name'; alias?: string }
   | { name: 'items'; alias?: string }

export interface MenuUpdateManyMutationInput {
   root?: boolean | null
}
export type MenuUpdateManyMutationInputInputObject =
   | Extract<keyof MenuUpdateManyMutationInput, string>
   | { name: 'root'; alias?: string }

export interface StepUpdateInput {
   type?: KeyUserTypeUpdateManyInput | null
   question?: MultiLanguageContentUpdateOneRequiredInput | null
   targets?: MenuUpdateManyInput | null
   paths?: MenuUpdateManyInput | null
   results?: StepResultUpdateManyWithoutParentInput | null
}
export type StepUpdateInputInputObject =
   | Extract<keyof StepUpdateInput, string>
   | { name: 'type'; alias?: string }
   | { name: 'question'; alias?: string }
   | { name: 'targets'; alias?: string }
   | { name: 'paths'; alias?: string }
   | { name: 'results'; alias?: string }

export interface TestResultCreateInput {
   id?: string | null
   parent?: TestCreateOneWithoutResultsInput
   start?: string
   end?: string | null
   duration?: number
   steps?: StepResultCreateManyWithoutResultInput | null
   status?: KeyTestResultStatusCreateOneInput
}
export type TestResultCreateInputInputObject =
   | Extract<keyof TestResultCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'parent'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'duration'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'status'; alias?: string }

export interface TestResultUpdateInput {
   parent?: TestUpdateOneRequiredWithoutResultsInput | null
   start?: string | null
   end?: string | null
   duration?: number | null
   steps?: StepResultUpdateManyWithoutResultInput | null
   status?: KeyTestResultStatusUpdateOneRequiredInput | null
}
export type TestResultUpdateInputInputObject =
   | Extract<keyof TestResultUpdateInput, string>
   | { name: 'parent'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'duration'; alias?: string }
   | { name: 'steps'; alias?: string }
   | { name: 'status'; alias?: string }

export interface TestResultUpdateManyMutationInput {
   start?: string | null
   end?: string | null
   duration?: number | null
}
export type TestResultUpdateManyMutationInputInputObject =
   | Extract<keyof TestResultUpdateManyMutationInput, string>
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'duration'; alias?: string }

export interface StepResultCreateInput {
   id?: string | null
   parent?: StepCreateOneWithoutResultsInput
   result?: TestResultCreateOneWithoutStepsInput
   start?: string
   end?: string | null
   time?: number
   path?: MenuCreateManyInput | null
   status?: KeyStepResultStatusCreateOneInput
}
export type StepResultCreateInputInputObject =
   | Extract<keyof StepResultCreateInput, string>
   | { name: 'id'; alias?: string }
   | { name: 'parent'; alias?: string }
   | { name: 'result'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'time'; alias?: string }
   | { name: 'path'; alias?: string }
   | { name: 'status'; alias?: string }

export interface StepResultUpdateInput {
   parent?: StepUpdateOneRequiredWithoutResultsInput | null
   result?: TestResultUpdateOneRequiredWithoutStepsInput | null
   start?: string | null
   end?: string | null
   time?: number | null
   path?: MenuUpdateManyInput | null
   status?: KeyStepResultStatusUpdateOneRequiredInput | null
}
export type StepResultUpdateInputInputObject =
   | Extract<keyof StepResultUpdateInput, string>
   | { name: 'parent'; alias?: string }
   | { name: 'result'; alias?: string }
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'time'; alias?: string }
   | { name: 'path'; alias?: string }
   | { name: 'status'; alias?: string }

export interface StepResultUpdateManyMutationInput {
   start?: string | null
   end?: string | null
   time?: number | null
}
export type StepResultUpdateManyMutationInputInputObject =
   | Extract<keyof StepResultUpdateManyMutationInput, string>
   | { name: 'start'; alias?: string }
   | { name: 'end'; alias?: string }
   | { name: 'time'; alias?: string }

export interface KeySubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: KeyWhereInput | null
   AND?: KeySubscriptionWhereInput[]
}
export type KeySubscriptionWhereInputInputObject =
   | Extract<keyof KeySubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyUserTypeSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: KeyUserTypeWhereInput | null
   AND?: KeyUserTypeSubscriptionWhereInput[]
}
export type KeyUserTypeSubscriptionWhereInputInputObject =
   | Extract<keyof KeyUserTypeSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyLanguageSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: KeyLanguageWhereInput | null
   AND?: KeyLanguageSubscriptionWhereInput[]
}
export type KeyLanguageSubscriptionWhereInputInputObject =
   | Extract<keyof KeyLanguageSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyTestResultStatusSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: KeyTestResultStatusWhereInput | null
   AND?: KeyTestResultStatusSubscriptionWhereInput[]
}
export type KeyTestResultStatusSubscriptionWhereInputInputObject =
   | Extract<keyof KeyTestResultStatusSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface KeyStepResultStatusSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: KeyStepResultStatusWhereInput | null
   AND?: KeyStepResultStatusSubscriptionWhereInput[]
}
export type KeyStepResultStatusSubscriptionWhereInputInputObject =
   | Extract<keyof KeyStepResultStatusSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface MultiLanguageContentSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: MultiLanguageContentWhereInput | null
   AND?: MultiLanguageContentSubscriptionWhereInput[]
}
export type MultiLanguageContentSubscriptionWhereInputInputObject =
   | Extract<keyof MultiLanguageContentSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface MessageSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: MessageWhereInput | null
   AND?: MessageSubscriptionWhereInput[]
}
export type MessageSubscriptionWhereInputInputObject =
   | Extract<keyof MessageSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface CompanySubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: CompanyWhereInput | null
   AND?: CompanySubscriptionWhereInput[]
}
export type CompanySubscriptionWhereInputInputObject =
   | Extract<keyof CompanySubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface TestSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: TestWhereInput | null
   AND?: TestSubscriptionWhereInput[]
}
export type TestSubscriptionWhereInputInputObject =
   | Extract<keyof TestSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface MenuSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: MenuWhereInput | null
   AND?: MenuSubscriptionWhereInput[]
}
export type MenuSubscriptionWhereInputInputObject =
   | Extract<keyof MenuSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface StepSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: StepWhereInput | null
   AND?: StepSubscriptionWhereInput[]
}
export type StepSubscriptionWhereInputInputObject =
   | Extract<keyof StepSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface TestResultSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: TestResultWhereInput | null
   AND?: TestResultSubscriptionWhereInput[]
}
export type TestResultSubscriptionWhereInputInputObject =
   | Extract<keyof TestResultSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export interface StepResultSubscriptionWhereInput {
   mutation_in?: prisma.MutationType[]
   updatedFields_contains?: string | null
   updatedFields_contains_every?: string[]
   updatedFields_contains_some?: string[]
   node?: StepResultWhereInput | null
   AND?: StepResultSubscriptionWhereInput[]
}
export type StepResultSubscriptionWhereInputInputObject =
   | Extract<keyof StepResultSubscriptionWhereInput, string>
   | { name: 'mutation_in'; alias?: string }
   | { name: 'updatedFields_contains'; alias?: string }
   | { name: 'updatedFields_contains_every'; alias?: string }
   | { name: 'updatedFields_contains_some'; alias?: string }
   | { name: 'node'; alias?: string }
   | { name: 'AND'; alias?: string }

export type KeyUserTypeOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'key_ASC'
   | 'key_DESC'

export type KeyTestResultStatusOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'key_ASC'
   | 'key_DESC'

export type KeyStepResultStatusOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'key_ASC'
   | 'key_DESC'

export type KeyLanguageOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'key_ASC'
   | 'key_DESC'

export type KeyOrderByInputValues = 'id_ASC' | 'id_DESC'

export type MultiLanguageContentOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'pt_ASC'
   | 'pt_DESC'
   | 'en_ASC'
   | 'en_DESC'

export type MessageOrderByInputValues = 'id_ASC' | 'id_DESC'

export type TestOrderByInputValues = 'id_ASC' | 'id_DESC'

export type StepOrderByInputValues = 'id_ASC' | 'id_DESC'

export type MenuOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'root_ASC'
   | 'root_DESC'

export type StepResultOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'start_ASC'
   | 'start_DESC'
   | 'end_ASC'
   | 'end_DESC'
   | 'time_ASC'
   | 'time_DESC'

export type TestResultOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'start_ASC'
   | 'start_DESC'
   | 'end_ASC'
   | 'end_DESC'
   | 'duration_ASC'
   | 'duration_DESC'

export type CompanyOrderByInputValues =
   | 'id_ASC'
   | 'id_DESC'
   | 'name_ASC'
   | 'name_DESC'
   | 'abbr_ASC'
   | 'abbr_DESC'

export type MutationTypeValues = 'CREATED' | 'UPDATED' | 'DELETED'
