// Code generated by Prisma (prisma@1.32.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
   type AggregateCompany {
      count: Int!
   }

   type AggregateMenu {
      count: Int!
   }

   type AggregateStep {
      count: Int!
   }

   type AggregateStepResult {
      count: Int!
   }

   type AggregateTest {
      count: Int!
   }

   type AggregateTestResult {
      count: Int!
   }

   type AggregateTimeResult {
      count: Int!
   }

   type AggregateView {
      count: Int!
   }

   type AggregateWelcome {
      count: Int!
   }

   type BatchPayload {
      count: Long!
   }

   type Company {
      id: ID!
      name: String!
      abbr: String
      logo: String
   }

   type CompanyConnection {
      pageInfo: PageInfo!
      edges: [CompanyEdge]!
      aggregate: AggregateCompany!
   }

   input CompanyCreateInput {
      id: ID
      name: String!
      abbr: String
      logo: String
   }

   input CompanyCreateOneInput {
      create: CompanyCreateInput
      connect: CompanyWhereUniqueInput
   }

   type CompanyEdge {
      node: Company!
      cursor: String!
   }

   enum CompanyOrderByInput {
      id_ASC
      id_DESC
      name_ASC
      name_DESC
      abbr_ASC
      abbr_DESC
      logo_ASC
      logo_DESC
   }

   type CompanyPreviousValues {
      id: ID!
      name: String!
      abbr: String
      logo: String
   }

   type CompanySubscriptionPayload {
      mutation: MutationType!
      node: Company
      updatedFields: [String!]
      previousValues: CompanyPreviousValues
   }

   input CompanySubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: CompanyWhereInput
      AND: [CompanySubscriptionWhereInput!]
   }

   input CompanyUpdateDataInput {
      name: String
      abbr: String
      logo: String
   }

   input CompanyUpdateInput {
      name: String
      abbr: String
      logo: String
   }

   input CompanyUpdateManyMutationInput {
      name: String
      abbr: String
      logo: String
   }

   input CompanyUpdateOneRequiredInput {
      create: CompanyCreateInput
      update: CompanyUpdateDataInput
      upsert: CompanyUpsertNestedInput
      connect: CompanyWhereUniqueInput
   }

   input CompanyUpsertNestedInput {
      update: CompanyUpdateDataInput!
      create: CompanyCreateInput!
   }

   input CompanyWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      abbr: String
      abbr_not: String
      abbr_in: [String!]
      abbr_not_in: [String!]
      abbr_lt: String
      abbr_lte: String
      abbr_gt: String
      abbr_gte: String
      abbr_contains: String
      abbr_not_contains: String
      abbr_starts_with: String
      abbr_not_starts_with: String
      abbr_ends_with: String
      abbr_not_ends_with: String
      logo: String
      logo_not: String
      logo_in: [String!]
      logo_not_in: [String!]
      logo_lt: String
      logo_lte: String
      logo_gt: String
      logo_gte: String
      logo_contains: String
      logo_not_contains: String
      logo_starts_with: String
      logo_not_starts_with: String
      logo_ends_with: String
      logo_not_ends_with: String
      AND: [CompanyWhereInput!]
   }

   input CompanyWhereUniqueInput {
      id: ID
   }

   scalar DateTime

   scalar Long

   type Menu {
      id: ID!
      menu: Menu
      name: String!
      items(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
   }

   type MenuConnection {
      pageInfo: PageInfo!
      edges: [MenuEdge]!
      aggregate: AggregateMenu!
   }

   input MenuCreateInput {
      id: ID
      menu: MenuCreateOneWithoutItemsInput
      name: String!
      items: MenuCreateManyWithoutMenuInput
   }

   input MenuCreateManyInput {
      create: [MenuCreateInput!]
      connect: [MenuWhereUniqueInput!]
   }

   input MenuCreateManyWithoutMenuInput {
      create: [MenuCreateWithoutMenuInput!]
      connect: [MenuWhereUniqueInput!]
   }

   input MenuCreateOneInput {
      create: MenuCreateInput
      connect: MenuWhereUniqueInput
   }

   input MenuCreateOneWithoutItemsInput {
      create: MenuCreateWithoutItemsInput
      connect: MenuWhereUniqueInput
   }

   input MenuCreateWithoutItemsInput {
      id: ID
      menu: MenuCreateOneWithoutItemsInput
      name: String!
   }

   input MenuCreateWithoutMenuInput {
      id: ID
      name: String!
      items: MenuCreateManyWithoutMenuInput
   }

   type MenuEdge {
      node: Menu!
      cursor: String!
   }

   enum MenuOrderByInput {
      id_ASC
      id_DESC
      name_ASC
      name_DESC
   }

   type MenuPreviousValues {
      id: ID!
      name: String!
   }

   input MenuScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      AND: [MenuScalarWhereInput!]
      OR: [MenuScalarWhereInput!]
      NOT: [MenuScalarWhereInput!]
   }

   type MenuSubscriptionPayload {
      mutation: MutationType!
      node: Menu
      updatedFields: [String!]
      previousValues: MenuPreviousValues
   }

   input MenuSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: MenuWhereInput
      AND: [MenuSubscriptionWhereInput!]
   }

   input MenuUpdateDataInput {
      menu: MenuUpdateOneWithoutItemsInput
      name: String
      items: MenuUpdateManyWithoutMenuInput
   }

   input MenuUpdateInput {
      menu: MenuUpdateOneWithoutItemsInput
      name: String
      items: MenuUpdateManyWithoutMenuInput
   }

   input MenuUpdateManyDataInput {
      name: String
   }

   input MenuUpdateManyInput {
      create: [MenuCreateInput!]
      update: [MenuUpdateWithWhereUniqueNestedInput!]
      upsert: [MenuUpsertWithWhereUniqueNestedInput!]
      delete: [MenuWhereUniqueInput!]
      connect: [MenuWhereUniqueInput!]
      set: [MenuWhereUniqueInput!]
      disconnect: [MenuWhereUniqueInput!]
      deleteMany: [MenuScalarWhereInput!]
      updateMany: [MenuUpdateManyWithWhereNestedInput!]
   }

   input MenuUpdateManyMutationInput {
      name: String
   }

   input MenuUpdateManyWithoutMenuInput {
      create: [MenuCreateWithoutMenuInput!]
      delete: [MenuWhereUniqueInput!]
      connect: [MenuWhereUniqueInput!]
      set: [MenuWhereUniqueInput!]
      disconnect: [MenuWhereUniqueInput!]
      update: [MenuUpdateWithWhereUniqueWithoutMenuInput!]
      upsert: [MenuUpsertWithWhereUniqueWithoutMenuInput!]
      deleteMany: [MenuScalarWhereInput!]
      updateMany: [MenuUpdateManyWithWhereNestedInput!]
   }

   input MenuUpdateManyWithWhereNestedInput {
      where: MenuScalarWhereInput!
      data: MenuUpdateManyDataInput!
   }

   input MenuUpdateOneRequiredInput {
      create: MenuCreateInput
      update: MenuUpdateDataInput
      upsert: MenuUpsertNestedInput
      connect: MenuWhereUniqueInput
   }

   input MenuUpdateOneWithoutItemsInput {
      create: MenuCreateWithoutItemsInput
      update: MenuUpdateWithoutItemsDataInput
      upsert: MenuUpsertWithoutItemsInput
      delete: Boolean
      disconnect: Boolean
      connect: MenuWhereUniqueInput
   }

   input MenuUpdateWithoutItemsDataInput {
      menu: MenuUpdateOneWithoutItemsInput
      name: String
   }

   input MenuUpdateWithoutMenuDataInput {
      name: String
      items: MenuUpdateManyWithoutMenuInput
   }

   input MenuUpdateWithWhereUniqueNestedInput {
      where: MenuWhereUniqueInput!
      data: MenuUpdateDataInput!
   }

   input MenuUpdateWithWhereUniqueWithoutMenuInput {
      where: MenuWhereUniqueInput!
      data: MenuUpdateWithoutMenuDataInput!
   }

   input MenuUpsertNestedInput {
      update: MenuUpdateDataInput!
      create: MenuCreateInput!
   }

   input MenuUpsertWithoutItemsInput {
      update: MenuUpdateWithoutItemsDataInput!
      create: MenuCreateWithoutItemsInput!
   }

   input MenuUpsertWithWhereUniqueNestedInput {
      where: MenuWhereUniqueInput!
      update: MenuUpdateDataInput!
      create: MenuCreateInput!
   }

   input MenuUpsertWithWhereUniqueWithoutMenuInput {
      where: MenuWhereUniqueInput!
      update: MenuUpdateWithoutMenuDataInput!
      create: MenuCreateWithoutMenuInput!
   }

   input MenuWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      menu: MenuWhereInput
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      items_some: MenuWhereInput
      AND: [MenuWhereInput!]
   }

   input MenuWhereUniqueInput {
      id: ID
   }

   type Mutation {
      createCompany(data: CompanyCreateInput!): Company!
      updateCompany(
         data: CompanyUpdateInput!
         where: CompanyWhereUniqueInput!
      ): Company
      updateManyCompanies(
         data: CompanyUpdateManyMutationInput!
         where: CompanyWhereInput
      ): BatchPayload!
      upsertCompany(
         where: CompanyWhereUniqueInput!
         create: CompanyCreateInput!
         update: CompanyUpdateInput!
      ): Company!
      deleteCompany(where: CompanyWhereUniqueInput!): Company
      deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
      createMenu(data: MenuCreateInput!): Menu!
      updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
      updateManyMenus(
         data: MenuUpdateManyMutationInput!
         where: MenuWhereInput
      ): BatchPayload!
      upsertMenu(
         where: MenuWhereUniqueInput!
         create: MenuCreateInput!
         update: MenuUpdateInput!
      ): Menu!
      deleteMenu(where: MenuWhereUniqueInput!): Menu
      deleteManyMenus(where: MenuWhereInput): BatchPayload!
      createStep(data: StepCreateInput!): Step!
      updateStep(data: StepUpdateInput!, where: StepWhereUniqueInput!): Step
      updateManySteps(
         data: StepUpdateManyMutationInput!
         where: StepWhereInput
      ): BatchPayload!
      upsertStep(
         where: StepWhereUniqueInput!
         create: StepCreateInput!
         update: StepUpdateInput!
      ): Step!
      deleteStep(where: StepWhereUniqueInput!): Step
      deleteManySteps(where: StepWhereInput): BatchPayload!
      createStepResult(data: StepResultCreateInput!): StepResult!
      updateStepResult(
         data: StepResultUpdateInput!
         where: StepResultWhereUniqueInput!
      ): StepResult
      updateManyStepResults(
         data: StepResultUpdateManyMutationInput!
         where: StepResultWhereInput
      ): BatchPayload!
      upsertStepResult(
         where: StepResultWhereUniqueInput!
         create: StepResultCreateInput!
         update: StepResultUpdateInput!
      ): StepResult!
      deleteStepResult(where: StepResultWhereUniqueInput!): StepResult
      deleteManyStepResults(where: StepResultWhereInput): BatchPayload!
      createTest(data: TestCreateInput!): Test!
      updateTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test
      updateManyTests(
         data: TestUpdateManyMutationInput!
         where: TestWhereInput
      ): BatchPayload!
      upsertTest(
         where: TestWhereUniqueInput!
         create: TestCreateInput!
         update: TestUpdateInput!
      ): Test!
      deleteTest(where: TestWhereUniqueInput!): Test
      deleteManyTests(where: TestWhereInput): BatchPayload!
      createTestResult(data: TestResultCreateInput!): TestResult!
      updateTestResult(
         data: TestResultUpdateInput!
         where: TestResultWhereUniqueInput!
      ): TestResult
      updateManyTestResults(
         data: TestResultUpdateManyMutationInput!
         where: TestResultWhereInput
      ): BatchPayload!
      upsertTestResult(
         where: TestResultWhereUniqueInput!
         create: TestResultCreateInput!
         update: TestResultUpdateInput!
      ): TestResult!
      deleteTestResult(where: TestResultWhereUniqueInput!): TestResult
      deleteManyTestResults(where: TestResultWhereInput): BatchPayload!
      createTimeResult(data: TimeResultCreateInput!): TimeResult!
      updateTimeResult(
         data: TimeResultUpdateInput!
         where: TimeResultWhereUniqueInput!
      ): TimeResult
      updateManyTimeResults(
         data: TimeResultUpdateManyMutationInput!
         where: TimeResultWhereInput
      ): BatchPayload!
      upsertTimeResult(
         where: TimeResultWhereUniqueInput!
         create: TimeResultCreateInput!
         update: TimeResultUpdateInput!
      ): TimeResult!
      deleteTimeResult(where: TimeResultWhereUniqueInput!): TimeResult
      deleteManyTimeResults(where: TimeResultWhereInput): BatchPayload!
      createView(data: ViewCreateInput!): View!
      updateView(data: ViewUpdateInput!, where: ViewWhereUniqueInput!): View
      upsertView(
         where: ViewWhereUniqueInput!
         create: ViewCreateInput!
         update: ViewUpdateInput!
      ): View!
      deleteView(where: ViewWhereUniqueInput!): View
      deleteManyViews(where: ViewWhereInput): BatchPayload!
      createWelcome(data: WelcomeCreateInput!): Welcome!
      updateWelcome(
         data: WelcomeUpdateInput!
         where: WelcomeWhereUniqueInput!
      ): Welcome
      updateManyWelcomes(
         data: WelcomeUpdateManyMutationInput!
         where: WelcomeWhereInput
      ): BatchPayload!
      upsertWelcome(
         where: WelcomeWhereUniqueInput!
         create: WelcomeCreateInput!
         update: WelcomeUpdateInput!
      ): Welcome!
      deleteWelcome(where: WelcomeWhereUniqueInput!): Welcome
      deleteManyWelcomes(where: WelcomeWhereInput): BatchPayload!
   }

   enum MutationType {
      CREATED
      UPDATED
      DELETED
   }

   interface Node {
      id: ID!
   }

   type PageInfo {
      hasNextPage: Boolean!
      hasPreviousPage: Boolean!
      startCursor: String
      endCursor: String
   }

   type Query {
      company(where: CompanyWhereUniqueInput!): Company
      companies(
         where: CompanyWhereInput
         orderBy: CompanyOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Company]!
      companiesConnection(
         where: CompanyWhereInput
         orderBy: CompanyOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): CompanyConnection!
      menu(where: MenuWhereUniqueInput!): Menu
      menus(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu]!
      menusConnection(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): MenuConnection!
      step(where: StepWhereUniqueInput!): Step
      steps(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Step]!
      stepsConnection(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): StepConnection!
      stepResult(where: StepResultWhereUniqueInput!): StepResult
      stepResults(
         where: StepResultWhereInput
         orderBy: StepResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [StepResult]!
      stepResultsConnection(
         where: StepResultWhereInput
         orderBy: StepResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): StepResultConnection!
      test(where: TestWhereUniqueInput!): Test
      tests(
         where: TestWhereInput
         orderBy: TestOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Test]!
      testsConnection(
         where: TestWhereInput
         orderBy: TestOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): TestConnection!
      testResult(where: TestResultWhereUniqueInput!): TestResult
      testResults(
         where: TestResultWhereInput
         orderBy: TestResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [TestResult]!
      testResultsConnection(
         where: TestResultWhereInput
         orderBy: TestResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): TestResultConnection!
      timeResult(where: TimeResultWhereUniqueInput!): TimeResult
      timeResults(
         where: TimeResultWhereInput
         orderBy: TimeResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [TimeResult]!
      timeResultsConnection(
         where: TimeResultWhereInput
         orderBy: TimeResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): TimeResultConnection!
      view(where: ViewWhereUniqueInput!): View
      views(
         where: ViewWhereInput
         orderBy: ViewOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [View]!
      viewsConnection(
         where: ViewWhereInput
         orderBy: ViewOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): ViewConnection!
      welcome(where: WelcomeWhereUniqueInput!): Welcome
      welcomes(
         where: WelcomeWhereInput
         orderBy: WelcomeOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Welcome]!
      welcomesConnection(
         where: WelcomeWhereInput
         orderBy: WelcomeOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): WelcomeConnection!
      node(id: ID!): Node
   }

   enum ResultStatus {
      SUCESSES
      PARTIAL
      FAIL
      ABORTED
   }

   type Step {
      id: ID!
      question: String!
      target: Menu!
      path(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      results(
         where: StepResultWhereInput
         orderBy: StepResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [StepResult!]
   }

   type StepConnection {
      pageInfo: PageInfo!
      edges: [StepEdge]!
      aggregate: AggregateStep!
   }

   input StepCreateInput {
      id: ID
      question: String!
      target: MenuCreateOneInput!
      path: MenuCreateManyInput
      results: StepResultCreateManyWithoutParentInput
   }

   input StepCreateManyInput {
      create: [StepCreateInput!]
      connect: [StepWhereUniqueInput!]
   }

   input StepCreateOneWithoutResultsInput {
      create: StepCreateWithoutResultsInput
      connect: StepWhereUniqueInput
   }

   input StepCreateWithoutResultsInput {
      id: ID
      question: String!
      target: MenuCreateOneInput!
      path: MenuCreateManyInput
   }

   type StepEdge {
      node: Step!
      cursor: String!
   }

   enum StepOrderByInput {
      id_ASC
      id_DESC
      question_ASC
      question_DESC
   }

   type StepPreviousValues {
      id: ID!
      question: String!
   }

   type StepResult {
      id: ID!
      parent: Step!
      resultParent: TestResult!
      start: DateTime!
      end: DateTime
      time: TimeResult
      path(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      status: ResultStatus!
   }

   type StepResultConnection {
      pageInfo: PageInfo!
      edges: [StepResultEdge]!
      aggregate: AggregateStepResult!
   }

   input StepResultCreateInput {
      id: ID
      parent: StepCreateOneWithoutResultsInput!
      resultParent: TestResultCreateOneWithoutStepsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      path: MenuCreateManyInput
      status: ResultStatus
   }

   input StepResultCreateManyWithoutParentInput {
      create: [StepResultCreateWithoutParentInput!]
      connect: [StepResultWhereUniqueInput!]
   }

   input StepResultCreateManyWithoutResultParentInput {
      create: [StepResultCreateWithoutResultParentInput!]
      connect: [StepResultWhereUniqueInput!]
   }

   input StepResultCreateWithoutParentInput {
      id: ID
      resultParent: TestResultCreateOneWithoutStepsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      path: MenuCreateManyInput
      status: ResultStatus
   }

   input StepResultCreateWithoutResultParentInput {
      id: ID
      parent: StepCreateOneWithoutResultsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      path: MenuCreateManyInput
      status: ResultStatus
   }

   type StepResultEdge {
      node: StepResult!
      cursor: String!
   }

   enum StepResultOrderByInput {
      id_ASC
      id_DESC
      start_ASC
      start_DESC
      end_ASC
      end_DESC
      status_ASC
      status_DESC
   }

   type StepResultPreviousValues {
      id: ID!
      start: DateTime!
      end: DateTime
      status: ResultStatus!
   }

   input StepResultScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      start: DateTime
      start_not: DateTime
      start_in: [DateTime!]
      start_not_in: [DateTime!]
      start_lt: DateTime
      start_lte: DateTime
      start_gt: DateTime
      start_gte: DateTime
      end: DateTime
      end_not: DateTime
      end_in: [DateTime!]
      end_not_in: [DateTime!]
      end_lt: DateTime
      end_lte: DateTime
      end_gt: DateTime
      end_gte: DateTime
      status: ResultStatus
      status_not: ResultStatus
      status_in: [ResultStatus!]
      status_not_in: [ResultStatus!]
      AND: [StepResultScalarWhereInput!]
      OR: [StepResultScalarWhereInput!]
      NOT: [StepResultScalarWhereInput!]
   }

   type StepResultSubscriptionPayload {
      mutation: MutationType!
      node: StepResult
      updatedFields: [String!]
      previousValues: StepResultPreviousValues
   }

   input StepResultSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: StepResultWhereInput
      AND: [StepResultSubscriptionWhereInput!]
   }

   input StepResultUpdateInput {
      parent: StepUpdateOneRequiredWithoutResultsInput
      resultParent: TestResultUpdateOneRequiredWithoutStepsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      path: MenuUpdateManyInput
      status: ResultStatus
   }

   input StepResultUpdateManyDataInput {
      start: DateTime
      end: DateTime
      status: ResultStatus
   }

   input StepResultUpdateManyMutationInput {
      start: DateTime
      end: DateTime
      status: ResultStatus
   }

   input StepResultUpdateManyWithoutParentInput {
      create: [StepResultCreateWithoutParentInput!]
      delete: [StepResultWhereUniqueInput!]
      connect: [StepResultWhereUniqueInput!]
      set: [StepResultWhereUniqueInput!]
      disconnect: [StepResultWhereUniqueInput!]
      update: [StepResultUpdateWithWhereUniqueWithoutParentInput!]
      upsert: [StepResultUpsertWithWhereUniqueWithoutParentInput!]
      deleteMany: [StepResultScalarWhereInput!]
      updateMany: [StepResultUpdateManyWithWhereNestedInput!]
   }

   input StepResultUpdateManyWithoutResultParentInput {
      create: [StepResultCreateWithoutResultParentInput!]
      delete: [StepResultWhereUniqueInput!]
      connect: [StepResultWhereUniqueInput!]
      set: [StepResultWhereUniqueInput!]
      disconnect: [StepResultWhereUniqueInput!]
      update: [StepResultUpdateWithWhereUniqueWithoutResultParentInput!]
      upsert: [StepResultUpsertWithWhereUniqueWithoutResultParentInput!]
      deleteMany: [StepResultScalarWhereInput!]
      updateMany: [StepResultUpdateManyWithWhereNestedInput!]
   }

   input StepResultUpdateManyWithWhereNestedInput {
      where: StepResultScalarWhereInput!
      data: StepResultUpdateManyDataInput!
   }

   input StepResultUpdateWithoutParentDataInput {
      resultParent: TestResultUpdateOneRequiredWithoutStepsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      path: MenuUpdateManyInput
      status: ResultStatus
   }

   input StepResultUpdateWithoutResultParentDataInput {
      parent: StepUpdateOneRequiredWithoutResultsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      path: MenuUpdateManyInput
      status: ResultStatus
   }

   input StepResultUpdateWithWhereUniqueWithoutParentInput {
      where: StepResultWhereUniqueInput!
      data: StepResultUpdateWithoutParentDataInput!
   }

   input StepResultUpdateWithWhereUniqueWithoutResultParentInput {
      where: StepResultWhereUniqueInput!
      data: StepResultUpdateWithoutResultParentDataInput!
   }

   input StepResultUpsertWithWhereUniqueWithoutParentInput {
      where: StepResultWhereUniqueInput!
      update: StepResultUpdateWithoutParentDataInput!
      create: StepResultCreateWithoutParentInput!
   }

   input StepResultUpsertWithWhereUniqueWithoutResultParentInput {
      where: StepResultWhereUniqueInput!
      update: StepResultUpdateWithoutResultParentDataInput!
      create: StepResultCreateWithoutResultParentInput!
   }

   input StepResultWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      parent: StepWhereInput
      resultParent: TestResultWhereInput
      start: DateTime
      start_not: DateTime
      start_in: [DateTime!]
      start_not_in: [DateTime!]
      start_lt: DateTime
      start_lte: DateTime
      start_gt: DateTime
      start_gte: DateTime
      end: DateTime
      end_not: DateTime
      end_in: [DateTime!]
      end_not_in: [DateTime!]
      end_lt: DateTime
      end_lte: DateTime
      end_gt: DateTime
      end_gte: DateTime
      time: TimeResultWhereInput
      path_some: MenuWhereInput
      status: ResultStatus
      status_not: ResultStatus
      status_in: [ResultStatus!]
      status_not_in: [ResultStatus!]
      AND: [StepResultWhereInput!]
   }

   input StepResultWhereUniqueInput {
      id: ID
   }

   input StepScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      question: String
      question_not: String
      question_in: [String!]
      question_not_in: [String!]
      question_lt: String
      question_lte: String
      question_gt: String
      question_gte: String
      question_contains: String
      question_not_contains: String
      question_starts_with: String
      question_not_starts_with: String
      question_ends_with: String
      question_not_ends_with: String
      AND: [StepScalarWhereInput!]
      OR: [StepScalarWhereInput!]
      NOT: [StepScalarWhereInput!]
   }

   type StepSubscriptionPayload {
      mutation: MutationType!
      node: Step
      updatedFields: [String!]
      previousValues: StepPreviousValues
   }

   input StepSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: StepWhereInput
      AND: [StepSubscriptionWhereInput!]
   }

   input StepUpdateDataInput {
      question: String
      target: MenuUpdateOneRequiredInput
      path: MenuUpdateManyInput
      results: StepResultUpdateManyWithoutParentInput
   }

   input StepUpdateInput {
      question: String
      target: MenuUpdateOneRequiredInput
      path: MenuUpdateManyInput
      results: StepResultUpdateManyWithoutParentInput
   }

   input StepUpdateManyDataInput {
      question: String
   }

   input StepUpdateManyInput {
      create: [StepCreateInput!]
      update: [StepUpdateWithWhereUniqueNestedInput!]
      upsert: [StepUpsertWithWhereUniqueNestedInput!]
      delete: [StepWhereUniqueInput!]
      connect: [StepWhereUniqueInput!]
      set: [StepWhereUniqueInput!]
      disconnect: [StepWhereUniqueInput!]
      deleteMany: [StepScalarWhereInput!]
      updateMany: [StepUpdateManyWithWhereNestedInput!]
   }

   input StepUpdateManyMutationInput {
      question: String
   }

   input StepUpdateManyWithWhereNestedInput {
      where: StepScalarWhereInput!
      data: StepUpdateManyDataInput!
   }

   input StepUpdateOneRequiredWithoutResultsInput {
      create: StepCreateWithoutResultsInput
      update: StepUpdateWithoutResultsDataInput
      upsert: StepUpsertWithoutResultsInput
      connect: StepWhereUniqueInput
   }

   input StepUpdateWithoutResultsDataInput {
      question: String
      target: MenuUpdateOneRequiredInput
      path: MenuUpdateManyInput
   }

   input StepUpdateWithWhereUniqueNestedInput {
      where: StepWhereUniqueInput!
      data: StepUpdateDataInput!
   }

   input StepUpsertWithoutResultsInput {
      update: StepUpdateWithoutResultsDataInput!
      create: StepCreateWithoutResultsInput!
   }

   input StepUpsertWithWhereUniqueNestedInput {
      where: StepWhereUniqueInput!
      update: StepUpdateDataInput!
      create: StepCreateInput!
   }

   input StepWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      question: String
      question_not: String
      question_in: [String!]
      question_not_in: [String!]
      question_lt: String
      question_lte: String
      question_gt: String
      question_gte: String
      question_contains: String
      question_not_contains: String
      question_starts_with: String
      question_not_starts_with: String
      question_ends_with: String
      question_not_ends_with: String
      target: MenuWhereInput
      path_some: MenuWhereInput
      results_some: StepResultWhereInput
      AND: [StepWhereInput!]
   }

   input StepWhereUniqueInput {
      id: ID
   }

   type Subscription {
      company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
      menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
      step(where: StepSubscriptionWhereInput): StepSubscriptionPayload
      stepResult(
         where: StepResultSubscriptionWhereInput
      ): StepResultSubscriptionPayload
      test(where: TestSubscriptionWhereInput): TestSubscriptionPayload
      testResult(
         where: TestResultSubscriptionWhereInput
      ): TestResultSubscriptionPayload
      timeResult(
         where: TimeResultSubscriptionWhereInput
      ): TimeResultSubscriptionPayload
      view(where: ViewSubscriptionWhereInput): ViewSubscriptionPayload
      welcome(where: WelcomeSubscriptionWhereInput): WelcomeSubscriptionPayload
   }

   type Test {
      id: ID!
      title: String!
      steps(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Step!]
      menus(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      results(
         where: TestResultWhereInput
         orderBy: TestResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [TestResult!]
   }

   type TestConnection {
      pageInfo: PageInfo!
      edges: [TestEdge]!
      aggregate: AggregateTest!
   }

   input TestCreateInput {
      id: ID
      title: String!
      steps: StepCreateManyInput
      menus: MenuCreateManyInput
      results: TestResultCreateManyWithoutParentInput
   }

   input TestCreateManyInput {
      create: [TestCreateInput!]
      connect: [TestWhereUniqueInput!]
   }

   input TestCreateOneWithoutResultsInput {
      create: TestCreateWithoutResultsInput
      connect: TestWhereUniqueInput
   }

   input TestCreateWithoutResultsInput {
      id: ID
      title: String!
      steps: StepCreateManyInput
      menus: MenuCreateManyInput
   }

   type TestEdge {
      node: Test!
      cursor: String!
   }

   enum TestOrderByInput {
      id_ASC
      id_DESC
      title_ASC
      title_DESC
   }

   type TestPreviousValues {
      id: ID!
      title: String!
   }

   type TestResult {
      id: ID!
      parent: Test!
      start: DateTime!
      end: DateTime
      time: TimeResult
      steps(
         where: StepResultWhereInput
         orderBy: StepResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [StepResult!]
      status: ResultStatus!
   }

   type TestResultConnection {
      pageInfo: PageInfo!
      edges: [TestResultEdge]!
      aggregate: AggregateTestResult!
   }

   input TestResultCreateInput {
      id: ID
      parent: TestCreateOneWithoutResultsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      steps: StepResultCreateManyWithoutResultParentInput
      status: ResultStatus
   }

   input TestResultCreateManyWithoutParentInput {
      create: [TestResultCreateWithoutParentInput!]
      connect: [TestResultWhereUniqueInput!]
   }

   input TestResultCreateOneWithoutStepsInput {
      create: TestResultCreateWithoutStepsInput
      connect: TestResultWhereUniqueInput
   }

   input TestResultCreateWithoutParentInput {
      id: ID
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      steps: StepResultCreateManyWithoutResultParentInput
      status: ResultStatus
   }

   input TestResultCreateWithoutStepsInput {
      id: ID
      parent: TestCreateOneWithoutResultsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      status: ResultStatus
   }

   type TestResultEdge {
      node: TestResult!
      cursor: String!
   }

   enum TestResultOrderByInput {
      id_ASC
      id_DESC
      start_ASC
      start_DESC
      end_ASC
      end_DESC
      status_ASC
      status_DESC
   }

   type TestResultPreviousValues {
      id: ID!
      start: DateTime!
      end: DateTime
      status: ResultStatus!
   }

   input TestResultScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      start: DateTime
      start_not: DateTime
      start_in: [DateTime!]
      start_not_in: [DateTime!]
      start_lt: DateTime
      start_lte: DateTime
      start_gt: DateTime
      start_gte: DateTime
      end: DateTime
      end_not: DateTime
      end_in: [DateTime!]
      end_not_in: [DateTime!]
      end_lt: DateTime
      end_lte: DateTime
      end_gt: DateTime
      end_gte: DateTime
      status: ResultStatus
      status_not: ResultStatus
      status_in: [ResultStatus!]
      status_not_in: [ResultStatus!]
      AND: [TestResultScalarWhereInput!]
      OR: [TestResultScalarWhereInput!]
      NOT: [TestResultScalarWhereInput!]
   }

   type TestResultSubscriptionPayload {
      mutation: MutationType!
      node: TestResult
      updatedFields: [String!]
      previousValues: TestResultPreviousValues
   }

   input TestResultSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: TestResultWhereInput
      AND: [TestResultSubscriptionWhereInput!]
   }

   input TestResultUpdateInput {
      parent: TestUpdateOneRequiredWithoutResultsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      steps: StepResultUpdateManyWithoutResultParentInput
      status: ResultStatus
   }

   input TestResultUpdateManyDataInput {
      start: DateTime
      end: DateTime
      status: ResultStatus
   }

   input TestResultUpdateManyMutationInput {
      start: DateTime
      end: DateTime
      status: ResultStatus
   }

   input TestResultUpdateManyWithoutParentInput {
      create: [TestResultCreateWithoutParentInput!]
      delete: [TestResultWhereUniqueInput!]
      connect: [TestResultWhereUniqueInput!]
      set: [TestResultWhereUniqueInput!]
      disconnect: [TestResultWhereUniqueInput!]
      update: [TestResultUpdateWithWhereUniqueWithoutParentInput!]
      upsert: [TestResultUpsertWithWhereUniqueWithoutParentInput!]
      deleteMany: [TestResultScalarWhereInput!]
      updateMany: [TestResultUpdateManyWithWhereNestedInput!]
   }

   input TestResultUpdateManyWithWhereNestedInput {
      where: TestResultScalarWhereInput!
      data: TestResultUpdateManyDataInput!
   }

   input TestResultUpdateOneRequiredWithoutStepsInput {
      create: TestResultCreateWithoutStepsInput
      update: TestResultUpdateWithoutStepsDataInput
      upsert: TestResultUpsertWithoutStepsInput
      connect: TestResultWhereUniqueInput
   }

   input TestResultUpdateWithoutParentDataInput {
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      steps: StepResultUpdateManyWithoutResultParentInput
      status: ResultStatus
   }

   input TestResultUpdateWithoutStepsDataInput {
      parent: TestUpdateOneRequiredWithoutResultsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      status: ResultStatus
   }

   input TestResultUpdateWithWhereUniqueWithoutParentInput {
      where: TestResultWhereUniqueInput!
      data: TestResultUpdateWithoutParentDataInput!
   }

   input TestResultUpsertWithoutStepsInput {
      update: TestResultUpdateWithoutStepsDataInput!
      create: TestResultCreateWithoutStepsInput!
   }

   input TestResultUpsertWithWhereUniqueWithoutParentInput {
      where: TestResultWhereUniqueInput!
      update: TestResultUpdateWithoutParentDataInput!
      create: TestResultCreateWithoutParentInput!
   }

   input TestResultWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      parent: TestWhereInput
      start: DateTime
      start_not: DateTime
      start_in: [DateTime!]
      start_not_in: [DateTime!]
      start_lt: DateTime
      start_lte: DateTime
      start_gt: DateTime
      start_gte: DateTime
      end: DateTime
      end_not: DateTime
      end_in: [DateTime!]
      end_not_in: [DateTime!]
      end_lt: DateTime
      end_lte: DateTime
      end_gt: DateTime
      end_gte: DateTime
      time: TimeResultWhereInput
      steps_some: StepResultWhereInput
      status: ResultStatus
      status_not: ResultStatus
      status_in: [ResultStatus!]
      status_not_in: [ResultStatus!]
      AND: [TestResultWhereInput!]
   }

   input TestResultWhereUniqueInput {
      id: ID
   }

   input TestScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      AND: [TestScalarWhereInput!]
      OR: [TestScalarWhereInput!]
      NOT: [TestScalarWhereInput!]
   }

   type TestSubscriptionPayload {
      mutation: MutationType!
      node: Test
      updatedFields: [String!]
      previousValues: TestPreviousValues
   }

   input TestSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: TestWhereInput
      AND: [TestSubscriptionWhereInput!]
   }

   input TestUpdateDataInput {
      title: String
      steps: StepUpdateManyInput
      menus: MenuUpdateManyInput
      results: TestResultUpdateManyWithoutParentInput
   }

   input TestUpdateInput {
      title: String
      steps: StepUpdateManyInput
      menus: MenuUpdateManyInput
      results: TestResultUpdateManyWithoutParentInput
   }

   input TestUpdateManyDataInput {
      title: String
   }

   input TestUpdateManyInput {
      create: [TestCreateInput!]
      update: [TestUpdateWithWhereUniqueNestedInput!]
      upsert: [TestUpsertWithWhereUniqueNestedInput!]
      delete: [TestWhereUniqueInput!]
      connect: [TestWhereUniqueInput!]
      set: [TestWhereUniqueInput!]
      disconnect: [TestWhereUniqueInput!]
      deleteMany: [TestScalarWhereInput!]
      updateMany: [TestUpdateManyWithWhereNestedInput!]
   }

   input TestUpdateManyMutationInput {
      title: String
   }

   input TestUpdateManyWithWhereNestedInput {
      where: TestScalarWhereInput!
      data: TestUpdateManyDataInput!
   }

   input TestUpdateOneRequiredWithoutResultsInput {
      create: TestCreateWithoutResultsInput
      update: TestUpdateWithoutResultsDataInput
      upsert: TestUpsertWithoutResultsInput
      connect: TestWhereUniqueInput
   }

   input TestUpdateWithoutResultsDataInput {
      title: String
      steps: StepUpdateManyInput
      menus: MenuUpdateManyInput
   }

   input TestUpdateWithWhereUniqueNestedInput {
      where: TestWhereUniqueInput!
      data: TestUpdateDataInput!
   }

   input TestUpsertWithoutResultsInput {
      update: TestUpdateWithoutResultsDataInput!
      create: TestCreateWithoutResultsInput!
   }

   input TestUpsertWithWhereUniqueNestedInput {
      where: TestWhereUniqueInput!
      update: TestUpdateDataInput!
      create: TestCreateInput!
   }

   input TestWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      steps_some: StepWhereInput
      menus_some: MenuWhereInput
      results_some: TestResultWhereInput
      AND: [TestWhereInput!]
   }

   input TestWhereUniqueInput {
      id: ID
   }

   type TimeResult {
      id: ID!
      int: Int!
      text: String!
   }

   type TimeResultConnection {
      pageInfo: PageInfo!
      edges: [TimeResultEdge]!
      aggregate: AggregateTimeResult!
   }

   input TimeResultCreateInput {
      id: ID
      int: Int!
      text: String!
   }

   input TimeResultCreateOneInput {
      create: TimeResultCreateInput
      connect: TimeResultWhereUniqueInput
   }

   type TimeResultEdge {
      node: TimeResult!
      cursor: String!
   }

   enum TimeResultOrderByInput {
      id_ASC
      id_DESC
      int_ASC
      int_DESC
      text_ASC
      text_DESC
   }

   type TimeResultPreviousValues {
      id: ID!
      int: Int!
      text: String!
   }

   type TimeResultSubscriptionPayload {
      mutation: MutationType!
      node: TimeResult
      updatedFields: [String!]
      previousValues: TimeResultPreviousValues
   }

   input TimeResultSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: TimeResultWhereInput
      AND: [TimeResultSubscriptionWhereInput!]
   }

   input TimeResultUpdateDataInput {
      int: Int
      text: String
   }

   input TimeResultUpdateInput {
      int: Int
      text: String
   }

   input TimeResultUpdateManyMutationInput {
      int: Int
      text: String
   }

   input TimeResultUpdateOneInput {
      create: TimeResultCreateInput
      update: TimeResultUpdateDataInput
      upsert: TimeResultUpsertNestedInput
      delete: Boolean
      disconnect: Boolean
      connect: TimeResultWhereUniqueInput
   }

   input TimeResultUpsertNestedInput {
      update: TimeResultUpdateDataInput!
      create: TimeResultCreateInput!
   }

   input TimeResultWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      int: Int
      int_not: Int
      int_in: [Int!]
      int_not_in: [Int!]
      int_lt: Int
      int_lte: Int
      int_gt: Int
      int_gte: Int
      text: String
      text_not: String
      text_in: [String!]
      text_not_in: [String!]
      text_lt: String
      text_lte: String
      text_gt: String
      text_gte: String
      text_contains: String
      text_not_contains: String
      text_starts_with: String
      text_not_starts_with: String
      text_ends_with: String
      text_not_ends_with: String
      AND: [TimeResultWhereInput!]
   }

   input TimeResultWhereUniqueInput {
      id: ID
   }

   type View {
      id: ID!
      welcome: Welcome!
      company: Company!
      menus(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      tests(
         where: TestWhereInput
         orderBy: TestOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Test!]
      steps(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Step!]
   }

   type ViewConnection {
      pageInfo: PageInfo!
      edges: [ViewEdge]!
      aggregate: AggregateView!
   }

   input ViewCreateInput {
      id: ID
      welcome: WelcomeCreateOneInput!
      company: CompanyCreateOneInput!
      menus: MenuCreateManyInput
      tests: TestCreateManyInput
      steps: StepCreateManyInput
   }

   type ViewEdge {
      node: View!
      cursor: String!
   }

   enum ViewOrderByInput {
      id_ASC
      id_DESC
   }

   type ViewPreviousValues {
      id: ID!
   }

   type ViewSubscriptionPayload {
      mutation: MutationType!
      node: View
      updatedFields: [String!]
      previousValues: ViewPreviousValues
   }

   input ViewSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: ViewWhereInput
      AND: [ViewSubscriptionWhereInput!]
   }

   input ViewUpdateInput {
      welcome: WelcomeUpdateOneRequiredInput
      company: CompanyUpdateOneRequiredInput
      menus: MenuUpdateManyInput
      tests: TestUpdateManyInput
      steps: StepUpdateManyInput
   }

   input ViewWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      welcome: WelcomeWhereInput
      company: CompanyWhereInput
      menus_some: MenuWhereInput
      tests_some: TestWhereInput
      steps_some: StepWhereInput
      AND: [ViewWhereInput!]
   }

   input ViewWhereUniqueInput {
      id: ID
   }

   type Welcome {
      id: ID!
      title: String!
      message: String!
   }

   type WelcomeConnection {
      pageInfo: PageInfo!
      edges: [WelcomeEdge]!
      aggregate: AggregateWelcome!
   }

   input WelcomeCreateInput {
      id: ID
      title: String!
      message: String!
   }

   input WelcomeCreateOneInput {
      create: WelcomeCreateInput
      connect: WelcomeWhereUniqueInput
   }

   type WelcomeEdge {
      node: Welcome!
      cursor: String!
   }

   enum WelcomeOrderByInput {
      id_ASC
      id_DESC
      title_ASC
      title_DESC
      message_ASC
      message_DESC
   }

   type WelcomePreviousValues {
      id: ID!
      title: String!
      message: String!
   }

   type WelcomeSubscriptionPayload {
      mutation: MutationType!
      node: Welcome
      updatedFields: [String!]
      previousValues: WelcomePreviousValues
   }

   input WelcomeSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: WelcomeWhereInput
      AND: [WelcomeSubscriptionWhereInput!]
   }

   input WelcomeUpdateDataInput {
      title: String
      message: String
   }

   input WelcomeUpdateInput {
      title: String
      message: String
   }

   input WelcomeUpdateManyMutationInput {
      title: String
      message: String
   }

   input WelcomeUpdateOneRequiredInput {
      create: WelcomeCreateInput
      update: WelcomeUpdateDataInput
      upsert: WelcomeUpsertNestedInput
      connect: WelcomeWhereUniqueInput
   }

   input WelcomeUpsertNestedInput {
      update: WelcomeUpdateDataInput!
      create: WelcomeCreateInput!
   }

   input WelcomeWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      message: String
      message_not: String
      message_in: [String!]
      message_not_in: [String!]
      message_lt: String
      message_lte: String
      message_gt: String
      message_gte: String
      message_contains: String
      message_not_contains: String
      message_starts_with: String
      message_not_starts_with: String
      message_ends_with: String
      message_not_ends_with: String
      AND: [WelcomeWhereInput!]
   }

   input WelcomeWhereUniqueInput {
      id: ID
   }
`
