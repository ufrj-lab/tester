// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
   type AggregateCompany {
      count: Int!
   }

   type AggregateKeyResultStatus {
      count: Int!
   }

   type AggregateKeys {
      count: Int!
   }

   type AggregateKeyUserType {
      count: Int!
   }

   type AggregateMenu {
      count: Int!
   }

   type AggregatePath {
      count: Int!
   }

   type AggregateStep {
      count: Int!
   }

   type AggregateStepResult {
      count: Int!
   }

   type AggregateTest {
      count: Int!
   }

   type AggregateTestResult {
      count: Int!
   }

   type AggregateTimeResult {
      count: Int!
   }

   type AggregateView {
      count: Int!
   }

   type AggregateWelcome {
      count: Int!
   }

   type BatchPayload {
      count: Long!
   }

   type Company {
      id: ID!
      name: String!
      abbr: String
      logo: String
   }

   type CompanyConnection {
      pageInfo: PageInfo!
      edges: [CompanyEdge]!
      aggregate: AggregateCompany!
   }

   input CompanyCreateInput {
      id: ID
      name: String!
      abbr: String
      logo: String
   }

   input CompanyCreateOneInput {
      create: CompanyCreateInput
      connect: CompanyWhereUniqueInput
   }

   type CompanyEdge {
      node: Company!
      cursor: String!
   }

   enum CompanyOrderByInput {
      id_ASC
      id_DESC
      name_ASC
      name_DESC
      abbr_ASC
      abbr_DESC
      logo_ASC
      logo_DESC
   }

   type CompanyPreviousValues {
      id: ID!
      name: String!
      abbr: String
      logo: String
   }

   type CompanySubscriptionPayload {
      mutation: MutationType!
      node: Company
      updatedFields: [String!]
      previousValues: CompanyPreviousValues
   }

   input CompanySubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: CompanyWhereInput
      AND: [CompanySubscriptionWhereInput!]
   }

   input CompanyUpdateDataInput {
      name: String
      abbr: String
      logo: String
   }

   input CompanyUpdateInput {
      name: String
      abbr: String
      logo: String
   }

   input CompanyUpdateManyMutationInput {
      name: String
      abbr: String
      logo: String
   }

   input CompanyUpdateOneRequiredInput {
      create: CompanyCreateInput
      update: CompanyUpdateDataInput
      upsert: CompanyUpsertNestedInput
      connect: CompanyWhereUniqueInput
   }

   input CompanyUpsertNestedInput {
      update: CompanyUpdateDataInput!
      create: CompanyCreateInput!
   }

   input CompanyWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      abbr: String
      abbr_not: String
      abbr_in: [String!]
      abbr_not_in: [String!]
      abbr_lt: String
      abbr_lte: String
      abbr_gt: String
      abbr_gte: String
      abbr_contains: String
      abbr_not_contains: String
      abbr_starts_with: String
      abbr_not_starts_with: String
      abbr_ends_with: String
      abbr_not_ends_with: String
      logo: String
      logo_not: String
      logo_in: [String!]
      logo_not_in: [String!]
      logo_lt: String
      logo_lte: String
      logo_gt: String
      logo_gte: String
      logo_contains: String
      logo_not_contains: String
      logo_starts_with: String
      logo_not_starts_with: String
      logo_ends_with: String
      logo_not_ends_with: String
      AND: [CompanyWhereInput!]
   }

   input CompanyWhereUniqueInput {
      id: ID
   }

   scalar DateTime

   type KeyResultStatus {
      id: ID!
      key: String!
      results(
         where: TestResultWhereInput
         orderBy: TestResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [TestResult!]
   }

   type KeyResultStatusConnection {
      pageInfo: PageInfo!
      edges: [KeyResultStatusEdge]!
      aggregate: AggregateKeyResultStatus!
   }

   input KeyResultStatusCreateInput {
      id: ID
      key: String!
      results: TestResultCreateManyWithoutStatusInput
   }

   input KeyResultStatusCreateManyInput {
      create: [KeyResultStatusCreateInput!]
      connect: [KeyResultStatusWhereUniqueInput!]
   }

   input KeyResultStatusCreateOneInput {
      create: KeyResultStatusCreateInput
      connect: KeyResultStatusWhereUniqueInput
   }

   input KeyResultStatusCreateOneWithoutResultsInput {
      create: KeyResultStatusCreateWithoutResultsInput
      connect: KeyResultStatusWhereUniqueInput
   }

   input KeyResultStatusCreateWithoutResultsInput {
      id: ID
      key: String!
   }

   type KeyResultStatusEdge {
      node: KeyResultStatus!
      cursor: String!
   }

   enum KeyResultStatusOrderByInput {
      id_ASC
      id_DESC
      key_ASC
      key_DESC
   }

   type KeyResultStatusPreviousValues {
      id: ID!
      key: String!
   }

   input KeyResultStatusScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      key: String
      key_not: String
      key_in: [String!]
      key_not_in: [String!]
      key_lt: String
      key_lte: String
      key_gt: String
      key_gte: String
      key_contains: String
      key_not_contains: String
      key_starts_with: String
      key_not_starts_with: String
      key_ends_with: String
      key_not_ends_with: String
      AND: [KeyResultStatusScalarWhereInput!]
      OR: [KeyResultStatusScalarWhereInput!]
      NOT: [KeyResultStatusScalarWhereInput!]
   }

   type KeyResultStatusSubscriptionPayload {
      mutation: MutationType!
      node: KeyResultStatus
      updatedFields: [String!]
      previousValues: KeyResultStatusPreviousValues
   }

   input KeyResultStatusSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: KeyResultStatusWhereInput
      AND: [KeyResultStatusSubscriptionWhereInput!]
   }

   input KeyResultStatusUpdateDataInput {
      key: String
      results: TestResultUpdateManyWithoutStatusInput
   }

   input KeyResultStatusUpdateInput {
      key: String
      results: TestResultUpdateManyWithoutStatusInput
   }

   input KeyResultStatusUpdateManyDataInput {
      key: String
   }

   input KeyResultStatusUpdateManyInput {
      create: [KeyResultStatusCreateInput!]
      update: [KeyResultStatusUpdateWithWhereUniqueNestedInput!]
      upsert: [KeyResultStatusUpsertWithWhereUniqueNestedInput!]
      delete: [KeyResultStatusWhereUniqueInput!]
      connect: [KeyResultStatusWhereUniqueInput!]
      set: [KeyResultStatusWhereUniqueInput!]
      disconnect: [KeyResultStatusWhereUniqueInput!]
      deleteMany: [KeyResultStatusScalarWhereInput!]
      updateMany: [KeyResultStatusUpdateManyWithWhereNestedInput!]
   }

   input KeyResultStatusUpdateManyMutationInput {
      key: String
   }

   input KeyResultStatusUpdateManyWithWhereNestedInput {
      where: KeyResultStatusScalarWhereInput!
      data: KeyResultStatusUpdateManyDataInput!
   }

   input KeyResultStatusUpdateOneRequiredInput {
      create: KeyResultStatusCreateInput
      update: KeyResultStatusUpdateDataInput
      upsert: KeyResultStatusUpsertNestedInput
      connect: KeyResultStatusWhereUniqueInput
   }

   input KeyResultStatusUpdateOneRequiredWithoutResultsInput {
      create: KeyResultStatusCreateWithoutResultsInput
      update: KeyResultStatusUpdateWithoutResultsDataInput
      upsert: KeyResultStatusUpsertWithoutResultsInput
      connect: KeyResultStatusWhereUniqueInput
   }

   input KeyResultStatusUpdateWithoutResultsDataInput {
      key: String
   }

   input KeyResultStatusUpdateWithWhereUniqueNestedInput {
      where: KeyResultStatusWhereUniqueInput!
      data: KeyResultStatusUpdateDataInput!
   }

   input KeyResultStatusUpsertNestedInput {
      update: KeyResultStatusUpdateDataInput!
      create: KeyResultStatusCreateInput!
   }

   input KeyResultStatusUpsertWithoutResultsInput {
      update: KeyResultStatusUpdateWithoutResultsDataInput!
      create: KeyResultStatusCreateWithoutResultsInput!
   }

   input KeyResultStatusUpsertWithWhereUniqueNestedInput {
      where: KeyResultStatusWhereUniqueInput!
      update: KeyResultStatusUpdateDataInput!
      create: KeyResultStatusCreateInput!
   }

   input KeyResultStatusWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      key: String
      key_not: String
      key_in: [String!]
      key_not_in: [String!]
      key_lt: String
      key_lte: String
      key_gt: String
      key_gte: String
      key_contains: String
      key_not_contains: String
      key_starts_with: String
      key_not_starts_with: String
      key_ends_with: String
      key_not_ends_with: String
      results_some: TestResultWhereInput
      AND: [KeyResultStatusWhereInput!]
   }

   input KeyResultStatusWhereUniqueInput {
      id: ID
      key: String
   }

   type Keys {
      id: ID!
      userType(
         where: KeyUserTypeWhereInput
         orderBy: KeyUserTypeOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [KeyUserType!]
      resultStatus(
         where: KeyResultStatusWhereInput
         orderBy: KeyResultStatusOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [KeyResultStatus!]
   }

   type KeysConnection {
      pageInfo: PageInfo!
      edges: [KeysEdge]!
      aggregate: AggregateKeys!
   }

   input KeysCreateInput {
      id: ID
      userType: KeyUserTypeCreateManyInput
      resultStatus: KeyResultStatusCreateManyInput
   }

   type KeysEdge {
      node: Keys!
      cursor: String!
   }

   enum KeysOrderByInput {
      id_ASC
      id_DESC
   }

   type KeysPreviousValues {
      id: ID!
   }

   type KeysSubscriptionPayload {
      mutation: MutationType!
      node: Keys
      updatedFields: [String!]
      previousValues: KeysPreviousValues
   }

   input KeysSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: KeysWhereInput
      AND: [KeysSubscriptionWhereInput!]
   }

   input KeysUpdateInput {
      userType: KeyUserTypeUpdateManyInput
      resultStatus: KeyResultStatusUpdateManyInput
   }

   input KeysWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      userType_some: KeyUserTypeWhereInput
      resultStatus_some: KeyResultStatusWhereInput
      AND: [KeysWhereInput!]
   }

   input KeysWhereUniqueInput {
      id: ID
   }

   type KeyUserType {
      id: ID!
      key: String!
      steps(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Step!]
   }

   type KeyUserTypeConnection {
      pageInfo: PageInfo!
      edges: [KeyUserTypeEdge]!
      aggregate: AggregateKeyUserType!
   }

   input KeyUserTypeCreateInput {
      id: ID
      key: String!
      steps: StepCreateManyWithoutTypeInput
   }

   input KeyUserTypeCreateManyInput {
      create: [KeyUserTypeCreateInput!]
      connect: [KeyUserTypeWhereUniqueInput!]
   }

   input KeyUserTypeCreateManyWithoutStepsInput {
      create: [KeyUserTypeCreateWithoutStepsInput!]
      connect: [KeyUserTypeWhereUniqueInput!]
   }

   input KeyUserTypeCreateWithoutStepsInput {
      id: ID
      key: String!
   }

   type KeyUserTypeEdge {
      node: KeyUserType!
      cursor: String!
   }

   enum KeyUserTypeOrderByInput {
      id_ASC
      id_DESC
      key_ASC
      key_DESC
   }

   type KeyUserTypePreviousValues {
      id: ID!
      key: String!
   }

   input KeyUserTypeScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      key: String
      key_not: String
      key_in: [String!]
      key_not_in: [String!]
      key_lt: String
      key_lte: String
      key_gt: String
      key_gte: String
      key_contains: String
      key_not_contains: String
      key_starts_with: String
      key_not_starts_with: String
      key_ends_with: String
      key_not_ends_with: String
      AND: [KeyUserTypeScalarWhereInput!]
      OR: [KeyUserTypeScalarWhereInput!]
      NOT: [KeyUserTypeScalarWhereInput!]
   }

   type KeyUserTypeSubscriptionPayload {
      mutation: MutationType!
      node: KeyUserType
      updatedFields: [String!]
      previousValues: KeyUserTypePreviousValues
   }

   input KeyUserTypeSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: KeyUserTypeWhereInput
      AND: [KeyUserTypeSubscriptionWhereInput!]
   }

   input KeyUserTypeUpdateDataInput {
      key: String
      steps: StepUpdateManyWithoutTypeInput
   }

   input KeyUserTypeUpdateInput {
      key: String
      steps: StepUpdateManyWithoutTypeInput
   }

   input KeyUserTypeUpdateManyDataInput {
      key: String
   }

   input KeyUserTypeUpdateManyInput {
      create: [KeyUserTypeCreateInput!]
      update: [KeyUserTypeUpdateWithWhereUniqueNestedInput!]
      upsert: [KeyUserTypeUpsertWithWhereUniqueNestedInput!]
      delete: [KeyUserTypeWhereUniqueInput!]
      connect: [KeyUserTypeWhereUniqueInput!]
      set: [KeyUserTypeWhereUniqueInput!]
      disconnect: [KeyUserTypeWhereUniqueInput!]
      deleteMany: [KeyUserTypeScalarWhereInput!]
      updateMany: [KeyUserTypeUpdateManyWithWhereNestedInput!]
   }

   input KeyUserTypeUpdateManyMutationInput {
      key: String
   }

   input KeyUserTypeUpdateManyWithoutStepsInput {
      create: [KeyUserTypeCreateWithoutStepsInput!]
      delete: [KeyUserTypeWhereUniqueInput!]
      connect: [KeyUserTypeWhereUniqueInput!]
      set: [KeyUserTypeWhereUniqueInput!]
      disconnect: [KeyUserTypeWhereUniqueInput!]
      update: [KeyUserTypeUpdateWithWhereUniqueWithoutStepsInput!]
      upsert: [KeyUserTypeUpsertWithWhereUniqueWithoutStepsInput!]
      deleteMany: [KeyUserTypeScalarWhereInput!]
      updateMany: [KeyUserTypeUpdateManyWithWhereNestedInput!]
   }

   input KeyUserTypeUpdateManyWithWhereNestedInput {
      where: KeyUserTypeScalarWhereInput!
      data: KeyUserTypeUpdateManyDataInput!
   }

   input KeyUserTypeUpdateWithoutStepsDataInput {
      key: String
   }

   input KeyUserTypeUpdateWithWhereUniqueNestedInput {
      where: KeyUserTypeWhereUniqueInput!
      data: KeyUserTypeUpdateDataInput!
   }

   input KeyUserTypeUpdateWithWhereUniqueWithoutStepsInput {
      where: KeyUserTypeWhereUniqueInput!
      data: KeyUserTypeUpdateWithoutStepsDataInput!
   }

   input KeyUserTypeUpsertWithWhereUniqueNestedInput {
      where: KeyUserTypeWhereUniqueInput!
      update: KeyUserTypeUpdateDataInput!
      create: KeyUserTypeCreateInput!
   }

   input KeyUserTypeUpsertWithWhereUniqueWithoutStepsInput {
      where: KeyUserTypeWhereUniqueInput!
      update: KeyUserTypeUpdateWithoutStepsDataInput!
      create: KeyUserTypeCreateWithoutStepsInput!
   }

   input KeyUserTypeWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      key: String
      key_not: String
      key_in: [String!]
      key_not_in: [String!]
      key_lt: String
      key_lte: String
      key_gt: String
      key_gte: String
      key_contains: String
      key_not_contains: String
      key_starts_with: String
      key_not_starts_with: String
      key_ends_with: String
      key_not_ends_with: String
      steps_some: StepWhereInput
      AND: [KeyUserTypeWhereInput!]
   }

   input KeyUserTypeWhereUniqueInput {
      id: ID
      key: String
   }

   scalar Long

   type Menu {
      id: ID!
      root: Boolean!
      menus(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      name: String!
      items(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
   }

   type MenuConnection {
      pageInfo: PageInfo!
      edges: [MenuEdge]!
      aggregate: AggregateMenu!
   }

   input MenuCreateInput {
      id: ID
      root: Boolean
      menus: MenuCreateManyWithoutItemsInput
      name: String!
      items: MenuCreateManyWithoutMenusInput
   }

   input MenuCreateManyInput {
      create: [MenuCreateInput!]
      connect: [MenuWhereUniqueInput!]
   }

   input MenuCreateManyWithoutItemsInput {
      create: [MenuCreateWithoutItemsInput!]
      connect: [MenuWhereUniqueInput!]
   }

   input MenuCreateManyWithoutMenusInput {
      create: [MenuCreateWithoutMenusInput!]
      connect: [MenuWhereUniqueInput!]
   }

   input MenuCreateWithoutItemsInput {
      id: ID
      root: Boolean
      menus: MenuCreateManyWithoutItemsInput
      name: String!
   }

   input MenuCreateWithoutMenusInput {
      id: ID
      root: Boolean
      name: String!
      items: MenuCreateManyWithoutMenusInput
   }

   type MenuEdge {
      node: Menu!
      cursor: String!
   }

   enum MenuOrderByInput {
      id_ASC
      id_DESC
      root_ASC
      root_DESC
      name_ASC
      name_DESC
   }

   type MenuPreviousValues {
      id: ID!
      root: Boolean!
      name: String!
   }

   input MenuScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      root: Boolean
      root_not: Boolean
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      AND: [MenuScalarWhereInput!]
      OR: [MenuScalarWhereInput!]
      NOT: [MenuScalarWhereInput!]
   }

   type MenuSubscriptionPayload {
      mutation: MutationType!
      node: Menu
      updatedFields: [String!]
      previousValues: MenuPreviousValues
   }

   input MenuSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: MenuWhereInput
      AND: [MenuSubscriptionWhereInput!]
   }

   input MenuUpdateDataInput {
      root: Boolean
      menus: MenuUpdateManyWithoutItemsInput
      name: String
      items: MenuUpdateManyWithoutMenusInput
   }

   input MenuUpdateInput {
      root: Boolean
      menus: MenuUpdateManyWithoutItemsInput
      name: String
      items: MenuUpdateManyWithoutMenusInput
   }

   input MenuUpdateManyDataInput {
      root: Boolean
      name: String
   }

   input MenuUpdateManyInput {
      create: [MenuCreateInput!]
      update: [MenuUpdateWithWhereUniqueNestedInput!]
      upsert: [MenuUpsertWithWhereUniqueNestedInput!]
      delete: [MenuWhereUniqueInput!]
      connect: [MenuWhereUniqueInput!]
      set: [MenuWhereUniqueInput!]
      disconnect: [MenuWhereUniqueInput!]
      deleteMany: [MenuScalarWhereInput!]
      updateMany: [MenuUpdateManyWithWhereNestedInput!]
   }

   input MenuUpdateManyMutationInput {
      root: Boolean
      name: String
   }

   input MenuUpdateManyWithoutItemsInput {
      create: [MenuCreateWithoutItemsInput!]
      delete: [MenuWhereUniqueInput!]
      connect: [MenuWhereUniqueInput!]
      set: [MenuWhereUniqueInput!]
      disconnect: [MenuWhereUniqueInput!]
      update: [MenuUpdateWithWhereUniqueWithoutItemsInput!]
      upsert: [MenuUpsertWithWhereUniqueWithoutItemsInput!]
      deleteMany: [MenuScalarWhereInput!]
      updateMany: [MenuUpdateManyWithWhereNestedInput!]
   }

   input MenuUpdateManyWithoutMenusInput {
      create: [MenuCreateWithoutMenusInput!]
      delete: [MenuWhereUniqueInput!]
      connect: [MenuWhereUniqueInput!]
      set: [MenuWhereUniqueInput!]
      disconnect: [MenuWhereUniqueInput!]
      update: [MenuUpdateWithWhereUniqueWithoutMenusInput!]
      upsert: [MenuUpsertWithWhereUniqueWithoutMenusInput!]
      deleteMany: [MenuScalarWhereInput!]
      updateMany: [MenuUpdateManyWithWhereNestedInput!]
   }

   input MenuUpdateManyWithWhereNestedInput {
      where: MenuScalarWhereInput!
      data: MenuUpdateManyDataInput!
   }

   input MenuUpdateWithoutItemsDataInput {
      root: Boolean
      menus: MenuUpdateManyWithoutItemsInput
      name: String
   }

   input MenuUpdateWithoutMenusDataInput {
      root: Boolean
      name: String
      items: MenuUpdateManyWithoutMenusInput
   }

   input MenuUpdateWithWhereUniqueNestedInput {
      where: MenuWhereUniqueInput!
      data: MenuUpdateDataInput!
   }

   input MenuUpdateWithWhereUniqueWithoutItemsInput {
      where: MenuWhereUniqueInput!
      data: MenuUpdateWithoutItemsDataInput!
   }

   input MenuUpdateWithWhereUniqueWithoutMenusInput {
      where: MenuWhereUniqueInput!
      data: MenuUpdateWithoutMenusDataInput!
   }

   input MenuUpsertWithWhereUniqueNestedInput {
      where: MenuWhereUniqueInput!
      update: MenuUpdateDataInput!
      create: MenuCreateInput!
   }

   input MenuUpsertWithWhereUniqueWithoutItemsInput {
      where: MenuWhereUniqueInput!
      update: MenuUpdateWithoutItemsDataInput!
      create: MenuCreateWithoutItemsInput!
   }

   input MenuUpsertWithWhereUniqueWithoutMenusInput {
      where: MenuWhereUniqueInput!
      update: MenuUpdateWithoutMenusDataInput!
      create: MenuCreateWithoutMenusInput!
   }

   input MenuWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      root: Boolean
      root_not: Boolean
      menus_some: MenuWhereInput
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      items_some: MenuWhereInput
      AND: [MenuWhereInput!]
   }

   input MenuWhereUniqueInput {
      id: ID
   }

   type Mutation {
      createCompany(data: CompanyCreateInput!): Company!
      updateCompany(
         data: CompanyUpdateInput!
         where: CompanyWhereUniqueInput!
      ): Company
      updateManyCompanies(
         data: CompanyUpdateManyMutationInput!
         where: CompanyWhereInput
      ): BatchPayload!
      upsertCompany(
         where: CompanyWhereUniqueInput!
         create: CompanyCreateInput!
         update: CompanyUpdateInput!
      ): Company!
      deleteCompany(where: CompanyWhereUniqueInput!): Company
      deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
      createKeyResultStatus(data: KeyResultStatusCreateInput!): KeyResultStatus!
      updateKeyResultStatus(
         data: KeyResultStatusUpdateInput!
         where: KeyResultStatusWhereUniqueInput!
      ): KeyResultStatus
      updateManyKeyResultStatuses(
         data: KeyResultStatusUpdateManyMutationInput!
         where: KeyResultStatusWhereInput
      ): BatchPayload!
      upsertKeyResultStatus(
         where: KeyResultStatusWhereUniqueInput!
         create: KeyResultStatusCreateInput!
         update: KeyResultStatusUpdateInput!
      ): KeyResultStatus!
      deleteKeyResultStatus(
         where: KeyResultStatusWhereUniqueInput!
      ): KeyResultStatus
      deleteManyKeyResultStatuses(
         where: KeyResultStatusWhereInput
      ): BatchPayload!
      createKeyUserType(data: KeyUserTypeCreateInput!): KeyUserType!
      updateKeyUserType(
         data: KeyUserTypeUpdateInput!
         where: KeyUserTypeWhereUniqueInput!
      ): KeyUserType
      updateManyKeyUserTypes(
         data: KeyUserTypeUpdateManyMutationInput!
         where: KeyUserTypeWhereInput
      ): BatchPayload!
      upsertKeyUserType(
         where: KeyUserTypeWhereUniqueInput!
         create: KeyUserTypeCreateInput!
         update: KeyUserTypeUpdateInput!
      ): KeyUserType!
      deleteKeyUserType(where: KeyUserTypeWhereUniqueInput!): KeyUserType
      deleteManyKeyUserTypes(where: KeyUserTypeWhereInput): BatchPayload!
      createKeys(data: KeysCreateInput!): Keys!
      updateKeys(data: KeysUpdateInput!, where: KeysWhereUniqueInput!): Keys
      upsertKeys(
         where: KeysWhereUniqueInput!
         create: KeysCreateInput!
         update: KeysUpdateInput!
      ): Keys!
      deleteKeys(where: KeysWhereUniqueInput!): Keys
      deleteManyKeyses(where: KeysWhereInput): BatchPayload!
      createMenu(data: MenuCreateInput!): Menu!
      updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
      updateManyMenus(
         data: MenuUpdateManyMutationInput!
         where: MenuWhereInput
      ): BatchPayload!
      upsertMenu(
         where: MenuWhereUniqueInput!
         create: MenuCreateInput!
         update: MenuUpdateInput!
      ): Menu!
      deleteMenu(where: MenuWhereUniqueInput!): Menu
      deleteManyMenus(where: MenuWhereInput): BatchPayload!
      createPath(data: PathCreateInput!): Path!
      updatePath(data: PathUpdateInput!, where: PathWhereUniqueInput!): Path
      upsertPath(
         where: PathWhereUniqueInput!
         create: PathCreateInput!
         update: PathUpdateInput!
      ): Path!
      deletePath(where: PathWhereUniqueInput!): Path
      deleteManyPaths(where: PathWhereInput): BatchPayload!
      createStep(data: StepCreateInput!): Step!
      updateStep(data: StepUpdateInput!, where: StepWhereUniqueInput!): Step
      updateManySteps(
         data: StepUpdateManyMutationInput!
         where: StepWhereInput
      ): BatchPayload!
      upsertStep(
         where: StepWhereUniqueInput!
         create: StepCreateInput!
         update: StepUpdateInput!
      ): Step!
      deleteStep(where: StepWhereUniqueInput!): Step
      deleteManySteps(where: StepWhereInput): BatchPayload!
      createStepResult(data: StepResultCreateInput!): StepResult!
      updateStepResult(
         data: StepResultUpdateInput!
         where: StepResultWhereUniqueInput!
      ): StepResult
      updateManyStepResults(
         data: StepResultUpdateManyMutationInput!
         where: StepResultWhereInput
      ): BatchPayload!
      upsertStepResult(
         where: StepResultWhereUniqueInput!
         create: StepResultCreateInput!
         update: StepResultUpdateInput!
      ): StepResult!
      deleteStepResult(where: StepResultWhereUniqueInput!): StepResult
      deleteManyStepResults(where: StepResultWhereInput): BatchPayload!
      createTest(data: TestCreateInput!): Test!
      updateTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test
      updateManyTests(
         data: TestUpdateManyMutationInput!
         where: TestWhereInput
      ): BatchPayload!
      upsertTest(
         where: TestWhereUniqueInput!
         create: TestCreateInput!
         update: TestUpdateInput!
      ): Test!
      deleteTest(where: TestWhereUniqueInput!): Test
      deleteManyTests(where: TestWhereInput): BatchPayload!
      createTestResult(data: TestResultCreateInput!): TestResult!
      updateTestResult(
         data: TestResultUpdateInput!
         where: TestResultWhereUniqueInput!
      ): TestResult
      updateManyTestResults(
         data: TestResultUpdateManyMutationInput!
         where: TestResultWhereInput
      ): BatchPayload!
      upsertTestResult(
         where: TestResultWhereUniqueInput!
         create: TestResultCreateInput!
         update: TestResultUpdateInput!
      ): TestResult!
      deleteTestResult(where: TestResultWhereUniqueInput!): TestResult
      deleteManyTestResults(where: TestResultWhereInput): BatchPayload!
      createTimeResult(data: TimeResultCreateInput!): TimeResult!
      updateTimeResult(
         data: TimeResultUpdateInput!
         where: TimeResultWhereUniqueInput!
      ): TimeResult
      updateManyTimeResults(
         data: TimeResultUpdateManyMutationInput!
         where: TimeResultWhereInput
      ): BatchPayload!
      upsertTimeResult(
         where: TimeResultWhereUniqueInput!
         create: TimeResultCreateInput!
         update: TimeResultUpdateInput!
      ): TimeResult!
      deleteTimeResult(where: TimeResultWhereUniqueInput!): TimeResult
      deleteManyTimeResults(where: TimeResultWhereInput): BatchPayload!
      createView(data: ViewCreateInput!): View!
      updateView(data: ViewUpdateInput!, where: ViewWhereUniqueInput!): View
      upsertView(
         where: ViewWhereUniqueInput!
         create: ViewCreateInput!
         update: ViewUpdateInput!
      ): View!
      deleteView(where: ViewWhereUniqueInput!): View
      deleteManyViews(where: ViewWhereInput): BatchPayload!
      createWelcome(data: WelcomeCreateInput!): Welcome!
      updateWelcome(
         data: WelcomeUpdateInput!
         where: WelcomeWhereUniqueInput!
      ): Welcome
      updateManyWelcomes(
         data: WelcomeUpdateManyMutationInput!
         where: WelcomeWhereInput
      ): BatchPayload!
      upsertWelcome(
         where: WelcomeWhereUniqueInput!
         create: WelcomeCreateInput!
         update: WelcomeUpdateInput!
      ): Welcome!
      deleteWelcome(where: WelcomeWhereUniqueInput!): Welcome
      deleteManyWelcomes(where: WelcomeWhereInput): BatchPayload!
   }

   enum MutationType {
      CREATED
      UPDATED
      DELETED
   }

   interface Node {
      id: ID!
   }

   type PageInfo {
      hasNextPage: Boolean!
      hasPreviousPage: Boolean!
      startCursor: String
      endCursor: String
   }

   type Path {
      id: ID!
      parent: Step!
      paths(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
   }

   type PathConnection {
      pageInfo: PageInfo!
      edges: [PathEdge]!
      aggregate: AggregatePath!
   }

   input PathCreateInput {
      id: ID
      parent: StepCreateOneWithoutPathsInput!
      paths: MenuCreateManyInput
   }

   input PathCreateManyWithoutParentInput {
      create: [PathCreateWithoutParentInput!]
      connect: [PathWhereUniqueInput!]
   }

   input PathCreateWithoutParentInput {
      id: ID
      paths: MenuCreateManyInput
   }

   type PathEdge {
      node: Path!
      cursor: String!
   }

   enum PathOrderByInput {
      id_ASC
      id_DESC
   }

   type PathPreviousValues {
      id: ID!
   }

   input PathScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      AND: [PathScalarWhereInput!]
      OR: [PathScalarWhereInput!]
      NOT: [PathScalarWhereInput!]
   }

   type PathSubscriptionPayload {
      mutation: MutationType!
      node: Path
      updatedFields: [String!]
      previousValues: PathPreviousValues
   }

   input PathSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: PathWhereInput
      AND: [PathSubscriptionWhereInput!]
   }

   input PathUpdateInput {
      parent: StepUpdateOneRequiredWithoutPathsInput
      paths: MenuUpdateManyInput
   }

   input PathUpdateManyWithoutParentInput {
      create: [PathCreateWithoutParentInput!]
      delete: [PathWhereUniqueInput!]
      connect: [PathWhereUniqueInput!]
      set: [PathWhereUniqueInput!]
      disconnect: [PathWhereUniqueInput!]
      update: [PathUpdateWithWhereUniqueWithoutParentInput!]
      upsert: [PathUpsertWithWhereUniqueWithoutParentInput!]
      deleteMany: [PathScalarWhereInput!]
   }

   input PathUpdateWithoutParentDataInput {
      paths: MenuUpdateManyInput
   }

   input PathUpdateWithWhereUniqueWithoutParentInput {
      where: PathWhereUniqueInput!
      data: PathUpdateWithoutParentDataInput!
   }

   input PathUpsertWithWhereUniqueWithoutParentInput {
      where: PathWhereUniqueInput!
      update: PathUpdateWithoutParentDataInput!
      create: PathCreateWithoutParentInput!
   }

   input PathWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      parent: StepWhereInput
      paths_some: MenuWhereInput
      AND: [PathWhereInput!]
   }

   input PathWhereUniqueInput {
      id: ID
   }

   type Query {
      company(where: CompanyWhereUniqueInput!): Company
      companies(
         where: CompanyWhereInput
         orderBy: CompanyOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Company]!
      companiesConnection(
         where: CompanyWhereInput
         orderBy: CompanyOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): CompanyConnection!
      keyResultStatus(where: KeyResultStatusWhereUniqueInput!): KeyResultStatus
      keyResultStatuses(
         where: KeyResultStatusWhereInput
         orderBy: KeyResultStatusOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [KeyResultStatus]!
      keyResultStatusesConnection(
         where: KeyResultStatusWhereInput
         orderBy: KeyResultStatusOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): KeyResultStatusConnection!
      keyUserType(where: KeyUserTypeWhereUniqueInput!): KeyUserType
      keyUserTypes(
         where: KeyUserTypeWhereInput
         orderBy: KeyUserTypeOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [KeyUserType]!
      keyUserTypesConnection(
         where: KeyUserTypeWhereInput
         orderBy: KeyUserTypeOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): KeyUserTypeConnection!
      keys(where: KeysWhereUniqueInput!): Keys
      keyses(
         where: KeysWhereInput
         orderBy: KeysOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Keys]!
      keysesConnection(
         where: KeysWhereInput
         orderBy: KeysOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): KeysConnection!
      menu(where: MenuWhereUniqueInput!): Menu
      menus(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu]!
      menusConnection(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): MenuConnection!
      path(where: PathWhereUniqueInput!): Path
      paths(
         where: PathWhereInput
         orderBy: PathOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Path]!
      pathsConnection(
         where: PathWhereInput
         orderBy: PathOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): PathConnection!
      step(where: StepWhereUniqueInput!): Step
      steps(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Step]!
      stepsConnection(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): StepConnection!
      stepResult(where: StepResultWhereUniqueInput!): StepResult
      stepResults(
         where: StepResultWhereInput
         orderBy: StepResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [StepResult]!
      stepResultsConnection(
         where: StepResultWhereInput
         orderBy: StepResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): StepResultConnection!
      test(where: TestWhereUniqueInput!): Test
      tests(
         where: TestWhereInput
         orderBy: TestOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Test]!
      testsConnection(
         where: TestWhereInput
         orderBy: TestOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): TestConnection!
      testResult(where: TestResultWhereUniqueInput!): TestResult
      testResults(
         where: TestResultWhereInput
         orderBy: TestResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [TestResult]!
      testResultsConnection(
         where: TestResultWhereInput
         orderBy: TestResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): TestResultConnection!
      timeResult(where: TimeResultWhereUniqueInput!): TimeResult
      timeResults(
         where: TimeResultWhereInput
         orderBy: TimeResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [TimeResult]!
      timeResultsConnection(
         where: TimeResultWhereInput
         orderBy: TimeResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): TimeResultConnection!
      view(where: ViewWhereUniqueInput!): View
      views(
         where: ViewWhereInput
         orderBy: ViewOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [View]!
      viewsConnection(
         where: ViewWhereInput
         orderBy: ViewOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): ViewConnection!
      welcome(where: WelcomeWhereUniqueInput!): Welcome
      welcomes(
         where: WelcomeWhereInput
         orderBy: WelcomeOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Welcome]!
      welcomesConnection(
         where: WelcomeWhereInput
         orderBy: WelcomeOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): WelcomeConnection!
      node(id: ID!): Node
   }

   type Step {
      id: ID!
      parent: Test
      type(
         where: KeyUserTypeWhereInput
         orderBy: KeyUserTypeOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [KeyUserType!]
      question: String!
      targets(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      paths(
         where: PathWhereInput
         orderBy: PathOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Path!]
      results(
         where: StepResultWhereInput
         orderBy: StepResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [StepResult!]
   }

   type StepConnection {
      pageInfo: PageInfo!
      edges: [StepEdge]!
      aggregate: AggregateStep!
   }

   input StepCreateInput {
      id: ID
      parent: TestCreateOneWithoutStepsInput
      type: KeyUserTypeCreateManyWithoutStepsInput
      question: String!
      targets: MenuCreateManyInput
      paths: PathCreateManyWithoutParentInput
      results: StepResultCreateManyWithoutParentInput
   }

   input StepCreateManyInput {
      create: [StepCreateInput!]
      connect: [StepWhereUniqueInput!]
   }

   input StepCreateManyWithoutParentInput {
      create: [StepCreateWithoutParentInput!]
      connect: [StepWhereUniqueInput!]
   }

   input StepCreateManyWithoutTypeInput {
      create: [StepCreateWithoutTypeInput!]
      connect: [StepWhereUniqueInput!]
   }

   input StepCreateOneWithoutPathsInput {
      create: StepCreateWithoutPathsInput
      connect: StepWhereUniqueInput
   }

   input StepCreateOneWithoutResultsInput {
      create: StepCreateWithoutResultsInput
      connect: StepWhereUniqueInput
   }

   input StepCreateWithoutParentInput {
      id: ID
      type: KeyUserTypeCreateManyWithoutStepsInput
      question: String!
      targets: MenuCreateManyInput
      paths: PathCreateManyWithoutParentInput
      results: StepResultCreateManyWithoutParentInput
   }

   input StepCreateWithoutPathsInput {
      id: ID
      parent: TestCreateOneWithoutStepsInput
      type: KeyUserTypeCreateManyWithoutStepsInput
      question: String!
      targets: MenuCreateManyInput
      results: StepResultCreateManyWithoutParentInput
   }

   input StepCreateWithoutResultsInput {
      id: ID
      parent: TestCreateOneWithoutStepsInput
      type: KeyUserTypeCreateManyWithoutStepsInput
      question: String!
      targets: MenuCreateManyInput
      paths: PathCreateManyWithoutParentInput
   }

   input StepCreateWithoutTypeInput {
      id: ID
      parent: TestCreateOneWithoutStepsInput
      question: String!
      targets: MenuCreateManyInput
      paths: PathCreateManyWithoutParentInput
      results: StepResultCreateManyWithoutParentInput
   }

   type StepEdge {
      node: Step!
      cursor: String!
   }

   enum StepOrderByInput {
      id_ASC
      id_DESC
      question_ASC
      question_DESC
   }

   type StepPreviousValues {
      id: ID!
      question: String!
   }

   type StepResult {
      id: ID!
      parent: Step!
      resultParent: TestResult!
      start: DateTime!
      end: DateTime
      time: TimeResult
      path(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      status: KeyResultStatus!
   }

   type StepResultConnection {
      pageInfo: PageInfo!
      edges: [StepResultEdge]!
      aggregate: AggregateStepResult!
   }

   input StepResultCreateInput {
      id: ID
      parent: StepCreateOneWithoutResultsInput!
      resultParent: TestResultCreateOneWithoutStepsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      path: MenuCreateManyInput
      status: KeyResultStatusCreateOneInput!
   }

   input StepResultCreateManyWithoutParentInput {
      create: [StepResultCreateWithoutParentInput!]
      connect: [StepResultWhereUniqueInput!]
   }

   input StepResultCreateManyWithoutResultParentInput {
      create: [StepResultCreateWithoutResultParentInput!]
      connect: [StepResultWhereUniqueInput!]
   }

   input StepResultCreateWithoutParentInput {
      id: ID
      resultParent: TestResultCreateOneWithoutStepsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      path: MenuCreateManyInput
      status: KeyResultStatusCreateOneInput!
   }

   input StepResultCreateWithoutResultParentInput {
      id: ID
      parent: StepCreateOneWithoutResultsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      path: MenuCreateManyInput
      status: KeyResultStatusCreateOneInput!
   }

   type StepResultEdge {
      node: StepResult!
      cursor: String!
   }

   enum StepResultOrderByInput {
      id_ASC
      id_DESC
      start_ASC
      start_DESC
      end_ASC
      end_DESC
   }

   type StepResultPreviousValues {
      id: ID!
      start: DateTime!
      end: DateTime
   }

   input StepResultScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      start: DateTime
      start_not: DateTime
      start_in: [DateTime!]
      start_not_in: [DateTime!]
      start_lt: DateTime
      start_lte: DateTime
      start_gt: DateTime
      start_gte: DateTime
      end: DateTime
      end_not: DateTime
      end_in: [DateTime!]
      end_not_in: [DateTime!]
      end_lt: DateTime
      end_lte: DateTime
      end_gt: DateTime
      end_gte: DateTime
      AND: [StepResultScalarWhereInput!]
      OR: [StepResultScalarWhereInput!]
      NOT: [StepResultScalarWhereInput!]
   }

   type StepResultSubscriptionPayload {
      mutation: MutationType!
      node: StepResult
      updatedFields: [String!]
      previousValues: StepResultPreviousValues
   }

   input StepResultSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: StepResultWhereInput
      AND: [StepResultSubscriptionWhereInput!]
   }

   input StepResultUpdateInput {
      parent: StepUpdateOneRequiredWithoutResultsInput
      resultParent: TestResultUpdateOneRequiredWithoutStepsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      path: MenuUpdateManyInput
      status: KeyResultStatusUpdateOneRequiredInput
   }

   input StepResultUpdateManyDataInput {
      start: DateTime
      end: DateTime
   }

   input StepResultUpdateManyMutationInput {
      start: DateTime
      end: DateTime
   }

   input StepResultUpdateManyWithoutParentInput {
      create: [StepResultCreateWithoutParentInput!]
      delete: [StepResultWhereUniqueInput!]
      connect: [StepResultWhereUniqueInput!]
      set: [StepResultWhereUniqueInput!]
      disconnect: [StepResultWhereUniqueInput!]
      update: [StepResultUpdateWithWhereUniqueWithoutParentInput!]
      upsert: [StepResultUpsertWithWhereUniqueWithoutParentInput!]
      deleteMany: [StepResultScalarWhereInput!]
      updateMany: [StepResultUpdateManyWithWhereNestedInput!]
   }

   input StepResultUpdateManyWithoutResultParentInput {
      create: [StepResultCreateWithoutResultParentInput!]
      delete: [StepResultWhereUniqueInput!]
      connect: [StepResultWhereUniqueInput!]
      set: [StepResultWhereUniqueInput!]
      disconnect: [StepResultWhereUniqueInput!]
      update: [StepResultUpdateWithWhereUniqueWithoutResultParentInput!]
      upsert: [StepResultUpsertWithWhereUniqueWithoutResultParentInput!]
      deleteMany: [StepResultScalarWhereInput!]
      updateMany: [StepResultUpdateManyWithWhereNestedInput!]
   }

   input StepResultUpdateManyWithWhereNestedInput {
      where: StepResultScalarWhereInput!
      data: StepResultUpdateManyDataInput!
   }

   input StepResultUpdateWithoutParentDataInput {
      resultParent: TestResultUpdateOneRequiredWithoutStepsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      path: MenuUpdateManyInput
      status: KeyResultStatusUpdateOneRequiredInput
   }

   input StepResultUpdateWithoutResultParentDataInput {
      parent: StepUpdateOneRequiredWithoutResultsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      path: MenuUpdateManyInput
      status: KeyResultStatusUpdateOneRequiredInput
   }

   input StepResultUpdateWithWhereUniqueWithoutParentInput {
      where: StepResultWhereUniqueInput!
      data: StepResultUpdateWithoutParentDataInput!
   }

   input StepResultUpdateWithWhereUniqueWithoutResultParentInput {
      where: StepResultWhereUniqueInput!
      data: StepResultUpdateWithoutResultParentDataInput!
   }

   input StepResultUpsertWithWhereUniqueWithoutParentInput {
      where: StepResultWhereUniqueInput!
      update: StepResultUpdateWithoutParentDataInput!
      create: StepResultCreateWithoutParentInput!
   }

   input StepResultUpsertWithWhereUniqueWithoutResultParentInput {
      where: StepResultWhereUniqueInput!
      update: StepResultUpdateWithoutResultParentDataInput!
      create: StepResultCreateWithoutResultParentInput!
   }

   input StepResultWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      parent: StepWhereInput
      resultParent: TestResultWhereInput
      start: DateTime
      start_not: DateTime
      start_in: [DateTime!]
      start_not_in: [DateTime!]
      start_lt: DateTime
      start_lte: DateTime
      start_gt: DateTime
      start_gte: DateTime
      end: DateTime
      end_not: DateTime
      end_in: [DateTime!]
      end_not_in: [DateTime!]
      end_lt: DateTime
      end_lte: DateTime
      end_gt: DateTime
      end_gte: DateTime
      time: TimeResultWhereInput
      path_some: MenuWhereInput
      status: KeyResultStatusWhereInput
      AND: [StepResultWhereInput!]
   }

   input StepResultWhereUniqueInput {
      id: ID
   }

   input StepScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      question: String
      question_not: String
      question_in: [String!]
      question_not_in: [String!]
      question_lt: String
      question_lte: String
      question_gt: String
      question_gte: String
      question_contains: String
      question_not_contains: String
      question_starts_with: String
      question_not_starts_with: String
      question_ends_with: String
      question_not_ends_with: String
      AND: [StepScalarWhereInput!]
      OR: [StepScalarWhereInput!]
      NOT: [StepScalarWhereInput!]
   }

   type StepSubscriptionPayload {
      mutation: MutationType!
      node: Step
      updatedFields: [String!]
      previousValues: StepPreviousValues
   }

   input StepSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: StepWhereInput
      AND: [StepSubscriptionWhereInput!]
   }

   input StepUpdateDataInput {
      parent: TestUpdateOneWithoutStepsInput
      type: KeyUserTypeUpdateManyWithoutStepsInput
      question: String
      targets: MenuUpdateManyInput
      paths: PathUpdateManyWithoutParentInput
      results: StepResultUpdateManyWithoutParentInput
   }

   input StepUpdateInput {
      parent: TestUpdateOneWithoutStepsInput
      type: KeyUserTypeUpdateManyWithoutStepsInput
      question: String
      targets: MenuUpdateManyInput
      paths: PathUpdateManyWithoutParentInput
      results: StepResultUpdateManyWithoutParentInput
   }

   input StepUpdateManyDataInput {
      question: String
   }

   input StepUpdateManyInput {
      create: [StepCreateInput!]
      update: [StepUpdateWithWhereUniqueNestedInput!]
      upsert: [StepUpsertWithWhereUniqueNestedInput!]
      delete: [StepWhereUniqueInput!]
      connect: [StepWhereUniqueInput!]
      set: [StepWhereUniqueInput!]
      disconnect: [StepWhereUniqueInput!]
      deleteMany: [StepScalarWhereInput!]
      updateMany: [StepUpdateManyWithWhereNestedInput!]
   }

   input StepUpdateManyMutationInput {
      question: String
   }

   input StepUpdateManyWithoutParentInput {
      create: [StepCreateWithoutParentInput!]
      delete: [StepWhereUniqueInput!]
      connect: [StepWhereUniqueInput!]
      set: [StepWhereUniqueInput!]
      disconnect: [StepWhereUniqueInput!]
      update: [StepUpdateWithWhereUniqueWithoutParentInput!]
      upsert: [StepUpsertWithWhereUniqueWithoutParentInput!]
      deleteMany: [StepScalarWhereInput!]
      updateMany: [StepUpdateManyWithWhereNestedInput!]
   }

   input StepUpdateManyWithoutTypeInput {
      create: [StepCreateWithoutTypeInput!]
      delete: [StepWhereUniqueInput!]
      connect: [StepWhereUniqueInput!]
      set: [StepWhereUniqueInput!]
      disconnect: [StepWhereUniqueInput!]
      update: [StepUpdateWithWhereUniqueWithoutTypeInput!]
      upsert: [StepUpsertWithWhereUniqueWithoutTypeInput!]
      deleteMany: [StepScalarWhereInput!]
      updateMany: [StepUpdateManyWithWhereNestedInput!]
   }

   input StepUpdateManyWithWhereNestedInput {
      where: StepScalarWhereInput!
      data: StepUpdateManyDataInput!
   }

   input StepUpdateOneRequiredWithoutPathsInput {
      create: StepCreateWithoutPathsInput
      update: StepUpdateWithoutPathsDataInput
      upsert: StepUpsertWithoutPathsInput
      connect: StepWhereUniqueInput
   }

   input StepUpdateOneRequiredWithoutResultsInput {
      create: StepCreateWithoutResultsInput
      update: StepUpdateWithoutResultsDataInput
      upsert: StepUpsertWithoutResultsInput
      connect: StepWhereUniqueInput
   }

   input StepUpdateWithoutParentDataInput {
      type: KeyUserTypeUpdateManyWithoutStepsInput
      question: String
      targets: MenuUpdateManyInput
      paths: PathUpdateManyWithoutParentInput
      results: StepResultUpdateManyWithoutParentInput
   }

   input StepUpdateWithoutPathsDataInput {
      parent: TestUpdateOneWithoutStepsInput
      type: KeyUserTypeUpdateManyWithoutStepsInput
      question: String
      targets: MenuUpdateManyInput
      results: StepResultUpdateManyWithoutParentInput
   }

   input StepUpdateWithoutResultsDataInput {
      parent: TestUpdateOneWithoutStepsInput
      type: KeyUserTypeUpdateManyWithoutStepsInput
      question: String
      targets: MenuUpdateManyInput
      paths: PathUpdateManyWithoutParentInput
   }

   input StepUpdateWithoutTypeDataInput {
      parent: TestUpdateOneWithoutStepsInput
      question: String
      targets: MenuUpdateManyInput
      paths: PathUpdateManyWithoutParentInput
      results: StepResultUpdateManyWithoutParentInput
   }

   input StepUpdateWithWhereUniqueNestedInput {
      where: StepWhereUniqueInput!
      data: StepUpdateDataInput!
   }

   input StepUpdateWithWhereUniqueWithoutParentInput {
      where: StepWhereUniqueInput!
      data: StepUpdateWithoutParentDataInput!
   }

   input StepUpdateWithWhereUniqueWithoutTypeInput {
      where: StepWhereUniqueInput!
      data: StepUpdateWithoutTypeDataInput!
   }

   input StepUpsertWithoutPathsInput {
      update: StepUpdateWithoutPathsDataInput!
      create: StepCreateWithoutPathsInput!
   }

   input StepUpsertWithoutResultsInput {
      update: StepUpdateWithoutResultsDataInput!
      create: StepCreateWithoutResultsInput!
   }

   input StepUpsertWithWhereUniqueNestedInput {
      where: StepWhereUniqueInput!
      update: StepUpdateDataInput!
      create: StepCreateInput!
   }

   input StepUpsertWithWhereUniqueWithoutParentInput {
      where: StepWhereUniqueInput!
      update: StepUpdateWithoutParentDataInput!
      create: StepCreateWithoutParentInput!
   }

   input StepUpsertWithWhereUniqueWithoutTypeInput {
      where: StepWhereUniqueInput!
      update: StepUpdateWithoutTypeDataInput!
      create: StepCreateWithoutTypeInput!
   }

   input StepWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      parent: TestWhereInput
      type_some: KeyUserTypeWhereInput
      question: String
      question_not: String
      question_in: [String!]
      question_not_in: [String!]
      question_lt: String
      question_lte: String
      question_gt: String
      question_gte: String
      question_contains: String
      question_not_contains: String
      question_starts_with: String
      question_not_starts_with: String
      question_ends_with: String
      question_not_ends_with: String
      targets_some: MenuWhereInput
      paths_some: PathWhereInput
      results_some: StepResultWhereInput
      AND: [StepWhereInput!]
   }

   input StepWhereUniqueInput {
      id: ID
   }

   type Subscription {
      company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
      keyResultStatus(
         where: KeyResultStatusSubscriptionWhereInput
      ): KeyResultStatusSubscriptionPayload
      keyUserType(
         where: KeyUserTypeSubscriptionWhereInput
      ): KeyUserTypeSubscriptionPayload
      keys(where: KeysSubscriptionWhereInput): KeysSubscriptionPayload
      menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
      path(where: PathSubscriptionWhereInput): PathSubscriptionPayload
      step(where: StepSubscriptionWhereInput): StepSubscriptionPayload
      stepResult(
         where: StepResultSubscriptionWhereInput
      ): StepResultSubscriptionPayload
      test(where: TestSubscriptionWhereInput): TestSubscriptionPayload
      testResult(
         where: TestResultSubscriptionWhereInput
      ): TestResultSubscriptionPayload
      timeResult(
         where: TimeResultSubscriptionWhereInput
      ): TimeResultSubscriptionPayload
      view(where: ViewSubscriptionWhereInput): ViewSubscriptionPayload
      welcome(where: WelcomeSubscriptionWhereInput): WelcomeSubscriptionPayload
   }

   type Test {
      id: ID!
      title: String!
      steps(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Step!]
      menus(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      results(
         where: TestResultWhereInput
         orderBy: TestResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [TestResult!]
   }

   type TestConnection {
      pageInfo: PageInfo!
      edges: [TestEdge]!
      aggregate: AggregateTest!
   }

   input TestCreateInput {
      id: ID
      title: String!
      steps: StepCreateManyWithoutParentInput
      menus: MenuCreateManyInput
      results: TestResultCreateManyWithoutParentInput
   }

   input TestCreateManyInput {
      create: [TestCreateInput!]
      connect: [TestWhereUniqueInput!]
   }

   input TestCreateOneWithoutResultsInput {
      create: TestCreateWithoutResultsInput
      connect: TestWhereUniqueInput
   }

   input TestCreateOneWithoutStepsInput {
      create: TestCreateWithoutStepsInput
      connect: TestWhereUniqueInput
   }

   input TestCreateWithoutResultsInput {
      id: ID
      title: String!
      steps: StepCreateManyWithoutParentInput
      menus: MenuCreateManyInput
   }

   input TestCreateWithoutStepsInput {
      id: ID
      title: String!
      menus: MenuCreateManyInput
      results: TestResultCreateManyWithoutParentInput
   }

   type TestEdge {
      node: Test!
      cursor: String!
   }

   enum TestOrderByInput {
      id_ASC
      id_DESC
      title_ASC
      title_DESC
   }

   type TestPreviousValues {
      id: ID!
      title: String!
   }

   type TestResult {
      id: ID!
      parent: Test!
      start: DateTime!
      end: DateTime
      time: TimeResult
      steps(
         where: StepResultWhereInput
         orderBy: StepResultOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [StepResult!]
      status: KeyResultStatus!
   }

   type TestResultConnection {
      pageInfo: PageInfo!
      edges: [TestResultEdge]!
      aggregate: AggregateTestResult!
   }

   input TestResultCreateInput {
      id: ID
      parent: TestCreateOneWithoutResultsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      steps: StepResultCreateManyWithoutResultParentInput
      status: KeyResultStatusCreateOneWithoutResultsInput!
   }

   input TestResultCreateManyWithoutParentInput {
      create: [TestResultCreateWithoutParentInput!]
      connect: [TestResultWhereUniqueInput!]
   }

   input TestResultCreateManyWithoutStatusInput {
      create: [TestResultCreateWithoutStatusInput!]
      connect: [TestResultWhereUniqueInput!]
   }

   input TestResultCreateOneWithoutStepsInput {
      create: TestResultCreateWithoutStepsInput
      connect: TestResultWhereUniqueInput
   }

   input TestResultCreateWithoutParentInput {
      id: ID
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      steps: StepResultCreateManyWithoutResultParentInput
      status: KeyResultStatusCreateOneWithoutResultsInput!
   }

   input TestResultCreateWithoutStatusInput {
      id: ID
      parent: TestCreateOneWithoutResultsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      steps: StepResultCreateManyWithoutResultParentInput
   }

   input TestResultCreateWithoutStepsInput {
      id: ID
      parent: TestCreateOneWithoutResultsInput!
      start: DateTime!
      end: DateTime
      time: TimeResultCreateOneInput
      status: KeyResultStatusCreateOneWithoutResultsInput!
   }

   type TestResultEdge {
      node: TestResult!
      cursor: String!
   }

   enum TestResultOrderByInput {
      id_ASC
      id_DESC
      start_ASC
      start_DESC
      end_ASC
      end_DESC
   }

   type TestResultPreviousValues {
      id: ID!
      start: DateTime!
      end: DateTime
   }

   input TestResultScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      start: DateTime
      start_not: DateTime
      start_in: [DateTime!]
      start_not_in: [DateTime!]
      start_lt: DateTime
      start_lte: DateTime
      start_gt: DateTime
      start_gte: DateTime
      end: DateTime
      end_not: DateTime
      end_in: [DateTime!]
      end_not_in: [DateTime!]
      end_lt: DateTime
      end_lte: DateTime
      end_gt: DateTime
      end_gte: DateTime
      AND: [TestResultScalarWhereInput!]
      OR: [TestResultScalarWhereInput!]
      NOT: [TestResultScalarWhereInput!]
   }

   type TestResultSubscriptionPayload {
      mutation: MutationType!
      node: TestResult
      updatedFields: [String!]
      previousValues: TestResultPreviousValues
   }

   input TestResultSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: TestResultWhereInput
      AND: [TestResultSubscriptionWhereInput!]
   }

   input TestResultUpdateInput {
      parent: TestUpdateOneRequiredWithoutResultsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      steps: StepResultUpdateManyWithoutResultParentInput
      status: KeyResultStatusUpdateOneRequiredWithoutResultsInput
   }

   input TestResultUpdateManyDataInput {
      start: DateTime
      end: DateTime
   }

   input TestResultUpdateManyMutationInput {
      start: DateTime
      end: DateTime
   }

   input TestResultUpdateManyWithoutParentInput {
      create: [TestResultCreateWithoutParentInput!]
      delete: [TestResultWhereUniqueInput!]
      connect: [TestResultWhereUniqueInput!]
      set: [TestResultWhereUniqueInput!]
      disconnect: [TestResultWhereUniqueInput!]
      update: [TestResultUpdateWithWhereUniqueWithoutParentInput!]
      upsert: [TestResultUpsertWithWhereUniqueWithoutParentInput!]
      deleteMany: [TestResultScalarWhereInput!]
      updateMany: [TestResultUpdateManyWithWhereNestedInput!]
   }

   input TestResultUpdateManyWithoutStatusInput {
      create: [TestResultCreateWithoutStatusInput!]
      delete: [TestResultWhereUniqueInput!]
      connect: [TestResultWhereUniqueInput!]
      set: [TestResultWhereUniqueInput!]
      disconnect: [TestResultWhereUniqueInput!]
      update: [TestResultUpdateWithWhereUniqueWithoutStatusInput!]
      upsert: [TestResultUpsertWithWhereUniqueWithoutStatusInput!]
      deleteMany: [TestResultScalarWhereInput!]
      updateMany: [TestResultUpdateManyWithWhereNestedInput!]
   }

   input TestResultUpdateManyWithWhereNestedInput {
      where: TestResultScalarWhereInput!
      data: TestResultUpdateManyDataInput!
   }

   input TestResultUpdateOneRequiredWithoutStepsInput {
      create: TestResultCreateWithoutStepsInput
      update: TestResultUpdateWithoutStepsDataInput
      upsert: TestResultUpsertWithoutStepsInput
      connect: TestResultWhereUniqueInput
   }

   input TestResultUpdateWithoutParentDataInput {
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      steps: StepResultUpdateManyWithoutResultParentInput
      status: KeyResultStatusUpdateOneRequiredWithoutResultsInput
   }

   input TestResultUpdateWithoutStatusDataInput {
      parent: TestUpdateOneRequiredWithoutResultsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      steps: StepResultUpdateManyWithoutResultParentInput
   }

   input TestResultUpdateWithoutStepsDataInput {
      parent: TestUpdateOneRequiredWithoutResultsInput
      start: DateTime
      end: DateTime
      time: TimeResultUpdateOneInput
      status: KeyResultStatusUpdateOneRequiredWithoutResultsInput
   }

   input TestResultUpdateWithWhereUniqueWithoutParentInput {
      where: TestResultWhereUniqueInput!
      data: TestResultUpdateWithoutParentDataInput!
   }

   input TestResultUpdateWithWhereUniqueWithoutStatusInput {
      where: TestResultWhereUniqueInput!
      data: TestResultUpdateWithoutStatusDataInput!
   }

   input TestResultUpsertWithoutStepsInput {
      update: TestResultUpdateWithoutStepsDataInput!
      create: TestResultCreateWithoutStepsInput!
   }

   input TestResultUpsertWithWhereUniqueWithoutParentInput {
      where: TestResultWhereUniqueInput!
      update: TestResultUpdateWithoutParentDataInput!
      create: TestResultCreateWithoutParentInput!
   }

   input TestResultUpsertWithWhereUniqueWithoutStatusInput {
      where: TestResultWhereUniqueInput!
      update: TestResultUpdateWithoutStatusDataInput!
      create: TestResultCreateWithoutStatusInput!
   }

   input TestResultWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      parent: TestWhereInput
      start: DateTime
      start_not: DateTime
      start_in: [DateTime!]
      start_not_in: [DateTime!]
      start_lt: DateTime
      start_lte: DateTime
      start_gt: DateTime
      start_gte: DateTime
      end: DateTime
      end_not: DateTime
      end_in: [DateTime!]
      end_not_in: [DateTime!]
      end_lt: DateTime
      end_lte: DateTime
      end_gt: DateTime
      end_gte: DateTime
      time: TimeResultWhereInput
      steps_some: StepResultWhereInput
      status: KeyResultStatusWhereInput
      AND: [TestResultWhereInput!]
   }

   input TestResultWhereUniqueInput {
      id: ID
   }

   input TestScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      AND: [TestScalarWhereInput!]
      OR: [TestScalarWhereInput!]
      NOT: [TestScalarWhereInput!]
   }

   type TestSubscriptionPayload {
      mutation: MutationType!
      node: Test
      updatedFields: [String!]
      previousValues: TestPreviousValues
   }

   input TestSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: TestWhereInput
      AND: [TestSubscriptionWhereInput!]
   }

   input TestUpdateDataInput {
      title: String
      steps: StepUpdateManyWithoutParentInput
      menus: MenuUpdateManyInput
      results: TestResultUpdateManyWithoutParentInput
   }

   input TestUpdateInput {
      title: String
      steps: StepUpdateManyWithoutParentInput
      menus: MenuUpdateManyInput
      results: TestResultUpdateManyWithoutParentInput
   }

   input TestUpdateManyDataInput {
      title: String
   }

   input TestUpdateManyInput {
      create: [TestCreateInput!]
      update: [TestUpdateWithWhereUniqueNestedInput!]
      upsert: [TestUpsertWithWhereUniqueNestedInput!]
      delete: [TestWhereUniqueInput!]
      connect: [TestWhereUniqueInput!]
      set: [TestWhereUniqueInput!]
      disconnect: [TestWhereUniqueInput!]
      deleteMany: [TestScalarWhereInput!]
      updateMany: [TestUpdateManyWithWhereNestedInput!]
   }

   input TestUpdateManyMutationInput {
      title: String
   }

   input TestUpdateManyWithWhereNestedInput {
      where: TestScalarWhereInput!
      data: TestUpdateManyDataInput!
   }

   input TestUpdateOneRequiredWithoutResultsInput {
      create: TestCreateWithoutResultsInput
      update: TestUpdateWithoutResultsDataInput
      upsert: TestUpsertWithoutResultsInput
      connect: TestWhereUniqueInput
   }

   input TestUpdateOneWithoutStepsInput {
      create: TestCreateWithoutStepsInput
      update: TestUpdateWithoutStepsDataInput
      upsert: TestUpsertWithoutStepsInput
      delete: Boolean
      disconnect: Boolean
      connect: TestWhereUniqueInput
   }

   input TestUpdateWithoutResultsDataInput {
      title: String
      steps: StepUpdateManyWithoutParentInput
      menus: MenuUpdateManyInput
   }

   input TestUpdateWithoutStepsDataInput {
      title: String
      menus: MenuUpdateManyInput
      results: TestResultUpdateManyWithoutParentInput
   }

   input TestUpdateWithWhereUniqueNestedInput {
      where: TestWhereUniqueInput!
      data: TestUpdateDataInput!
   }

   input TestUpsertWithoutResultsInput {
      update: TestUpdateWithoutResultsDataInput!
      create: TestCreateWithoutResultsInput!
   }

   input TestUpsertWithoutStepsInput {
      update: TestUpdateWithoutStepsDataInput!
      create: TestCreateWithoutStepsInput!
   }

   input TestUpsertWithWhereUniqueNestedInput {
      where: TestWhereUniqueInput!
      update: TestUpdateDataInput!
      create: TestCreateInput!
   }

   input TestWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      steps_some: StepWhereInput
      menus_some: MenuWhereInput
      results_some: TestResultWhereInput
      AND: [TestWhereInput!]
   }

   input TestWhereUniqueInput {
      id: ID
   }

   type TimeResult {
      id: ID!
      int: Int!
      text: String!
   }

   type TimeResultConnection {
      pageInfo: PageInfo!
      edges: [TimeResultEdge]!
      aggregate: AggregateTimeResult!
   }

   input TimeResultCreateInput {
      id: ID
      int: Int!
      text: String!
   }

   input TimeResultCreateOneInput {
      create: TimeResultCreateInput
      connect: TimeResultWhereUniqueInput
   }

   type TimeResultEdge {
      node: TimeResult!
      cursor: String!
   }

   enum TimeResultOrderByInput {
      id_ASC
      id_DESC
      int_ASC
      int_DESC
      text_ASC
      text_DESC
   }

   type TimeResultPreviousValues {
      id: ID!
      int: Int!
      text: String!
   }

   type TimeResultSubscriptionPayload {
      mutation: MutationType!
      node: TimeResult
      updatedFields: [String!]
      previousValues: TimeResultPreviousValues
   }

   input TimeResultSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: TimeResultWhereInput
      AND: [TimeResultSubscriptionWhereInput!]
   }

   input TimeResultUpdateDataInput {
      int: Int
      text: String
   }

   input TimeResultUpdateInput {
      int: Int
      text: String
   }

   input TimeResultUpdateManyMutationInput {
      int: Int
      text: String
   }

   input TimeResultUpdateOneInput {
      create: TimeResultCreateInput
      update: TimeResultUpdateDataInput
      upsert: TimeResultUpsertNestedInput
      delete: Boolean
      disconnect: Boolean
      connect: TimeResultWhereUniqueInput
   }

   input TimeResultUpsertNestedInput {
      update: TimeResultUpdateDataInput!
      create: TimeResultCreateInput!
   }

   input TimeResultWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      int: Int
      int_not: Int
      int_in: [Int!]
      int_not_in: [Int!]
      int_lt: Int
      int_lte: Int
      int_gt: Int
      int_gte: Int
      text: String
      text_not: String
      text_in: [String!]
      text_not_in: [String!]
      text_lt: String
      text_lte: String
      text_gt: String
      text_gte: String
      text_contains: String
      text_not_contains: String
      text_starts_with: String
      text_not_starts_with: String
      text_ends_with: String
      text_not_ends_with: String
      AND: [TimeResultWhereInput!]
   }

   input TimeResultWhereUniqueInput {
      id: ID
   }

   type View {
      id: ID!
      welcome: Welcome!
      company: Company!
      menus(
         where: MenuWhereInput
         orderBy: MenuOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Menu!]
      tests(
         where: TestWhereInput
         orderBy: TestOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Test!]
      steps(
         where: StepWhereInput
         orderBy: StepOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Step!]
   }

   type ViewConnection {
      pageInfo: PageInfo!
      edges: [ViewEdge]!
      aggregate: AggregateView!
   }

   input ViewCreateInput {
      id: ID
      welcome: WelcomeCreateOneInput!
      company: CompanyCreateOneInput!
      menus: MenuCreateManyInput
      tests: TestCreateManyInput
      steps: StepCreateManyInput
   }

   type ViewEdge {
      node: View!
      cursor: String!
   }

   enum ViewOrderByInput {
      id_ASC
      id_DESC
   }

   type ViewPreviousValues {
      id: ID!
   }

   type ViewSubscriptionPayload {
      mutation: MutationType!
      node: View
      updatedFields: [String!]
      previousValues: ViewPreviousValues
   }

   input ViewSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: ViewWhereInput
      AND: [ViewSubscriptionWhereInput!]
   }

   input ViewUpdateInput {
      welcome: WelcomeUpdateOneRequiredInput
      company: CompanyUpdateOneRequiredInput
      menus: MenuUpdateManyInput
      tests: TestUpdateManyInput
      steps: StepUpdateManyInput
   }

   input ViewWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      welcome: WelcomeWhereInput
      company: CompanyWhereInput
      menus_some: MenuWhereInput
      tests_some: TestWhereInput
      steps_some: StepWhereInput
      AND: [ViewWhereInput!]
   }

   input ViewWhereUniqueInput {
      id: ID
   }

   type Welcome {
      id: ID!
      title: String!
      message: String!
   }

   type WelcomeConnection {
      pageInfo: PageInfo!
      edges: [WelcomeEdge]!
      aggregate: AggregateWelcome!
   }

   input WelcomeCreateInput {
      id: ID
      title: String!
      message: String!
   }

   input WelcomeCreateOneInput {
      create: WelcomeCreateInput
      connect: WelcomeWhereUniqueInput
   }

   type WelcomeEdge {
      node: Welcome!
      cursor: String!
   }

   enum WelcomeOrderByInput {
      id_ASC
      id_DESC
      title_ASC
      title_DESC
      message_ASC
      message_DESC
   }

   type WelcomePreviousValues {
      id: ID!
      title: String!
      message: String!
   }

   type WelcomeSubscriptionPayload {
      mutation: MutationType!
      node: Welcome
      updatedFields: [String!]
      previousValues: WelcomePreviousValues
   }

   input WelcomeSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: WelcomeWhereInput
      AND: [WelcomeSubscriptionWhereInput!]
   }

   input WelcomeUpdateDataInput {
      title: String
      message: String
   }

   input WelcomeUpdateInput {
      title: String
      message: String
   }

   input WelcomeUpdateManyMutationInput {
      title: String
      message: String
   }

   input WelcomeUpdateOneRequiredInput {
      create: WelcomeCreateInput
      update: WelcomeUpdateDataInput
      upsert: WelcomeUpsertNestedInput
      connect: WelcomeWhereUniqueInput
   }

   input WelcomeUpsertNestedInput {
      update: WelcomeUpdateDataInput!
      create: WelcomeCreateInput!
   }

   input WelcomeWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      message: String
      message_not: String
      message_in: [String!]
      message_not_in: [String!]
      message_lt: String
      message_lte: String
      message_gt: String
      message_gte: String
      message_contains: String
      message_not_contains: String
      message_starts_with: String
      message_not_starts_with: String
      message_ends_with: String
      message_not_ends_with: String
      AND: [WelcomeWhereInput!]
   }

   input WelcomeWhereUniqueInput {
      id: ID
   }
`
