// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
  type AggregateCompany {
    count: Int!
  }

  type AggregateKey {
    count: Int!
  }

  type AggregateKeyLanguage {
    count: Int!
  }

  type AggregateKeyStepResultStatus {
    count: Int!
  }

  type AggregateKeyTestResultStatus {
    count: Int!
  }

  type AggregateKeyUserType {
    count: Int!
  }

  type AggregateMenu {
    count: Int!
  }

  type AggregateMessage {
    count: Int!
  }

  type AggregateMultiLanguageContent {
    count: Int!
  }

  type AggregatePath {
    count: Int!
  }

  type AggregateStep {
    count: Int!
  }

  type AggregateStepResult {
    count: Int!
  }

  type AggregateTest {
    count: Int!
  }

  type AggregateTestResult {
    count: Int!
  }

  type BatchPayload {
    count: Long!
  }

  type Company {
    id: ID!
    name: String!
    abbr: String
    welcome: Message!
    tests(
      where: TestWhereInput
      orderBy: TestOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Test!]
  }

  type CompanyConnection {
    pageInfo: PageInfo!
    edges: [CompanyEdge]!
    aggregate: AggregateCompany!
  }

  input CompanyCreateInput {
    id: ID
    name: String!
    abbr: String
    welcome: MessageCreateOneInput!
    tests: TestCreateManyWithoutCompanyInput
  }

  input CompanyCreateOneWithoutTestsInput {
    create: CompanyCreateWithoutTestsInput
    connect: CompanyWhereUniqueInput
  }

  input CompanyCreateWithoutTestsInput {
    id: ID
    name: String!
    abbr: String
    welcome: MessageCreateOneInput!
  }

  type CompanyEdge {
    node: Company!
    cursor: String!
  }

  enum CompanyOrderByInput {
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    abbr_ASC
    abbr_DESC
  }

  type CompanyPreviousValues {
    id: ID!
    name: String!
    abbr: String
  }

  type CompanySubscriptionPayload {
    mutation: MutationType!
    node: Company
    updatedFields: [String!]
    previousValues: CompanyPreviousValues
  }

  input CompanySubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: CompanyWhereInput
    AND: [CompanySubscriptionWhereInput!]
  }

  input CompanyUpdateInput {
    name: String
    abbr: String
    welcome: MessageUpdateOneRequiredInput
    tests: TestUpdateManyWithoutCompanyInput
  }

  input CompanyUpdateManyMutationInput {
    name: String
    abbr: String
  }

  input CompanyUpdateOneRequiredWithoutTestsInput {
    create: CompanyCreateWithoutTestsInput
    update: CompanyUpdateWithoutTestsDataInput
    upsert: CompanyUpsertWithoutTestsInput
    connect: CompanyWhereUniqueInput
  }

  input CompanyUpdateWithoutTestsDataInput {
    name: String
    abbr: String
    welcome: MessageUpdateOneRequiredInput
  }

  input CompanyUpsertWithoutTestsInput {
    update: CompanyUpdateWithoutTestsDataInput!
    create: CompanyCreateWithoutTestsInput!
  }

  input CompanyWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    name: String
    name_not: String
    name_in: [String!]
    name_not_in: [String!]
    name_lt: String
    name_lte: String
    name_gt: String
    name_gte: String
    name_contains: String
    name_not_contains: String
    name_starts_with: String
    name_not_starts_with: String
    name_ends_with: String
    name_not_ends_with: String
    abbr: String
    abbr_not: String
    abbr_in: [String!]
    abbr_not_in: [String!]
    abbr_lt: String
    abbr_lte: String
    abbr_gt: String
    abbr_gte: String
    abbr_contains: String
    abbr_not_contains: String
    abbr_starts_with: String
    abbr_not_starts_with: String
    abbr_ends_with: String
    abbr_not_ends_with: String
    welcome: MessageWhereInput
    tests_some: TestWhereInput
    AND: [CompanyWhereInput!]
  }

  input CompanyWhereUniqueInput {
    id: ID
    name: String
  }

  scalar DateTime

  type Key {
    id: ID!
    userTypes(
      where: KeyUserTypeWhereInput
      orderBy: KeyUserTypeOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyUserType!]
    testResultStatus(
      where: KeyTestResultStatusWhereInput
      orderBy: KeyTestResultStatusOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyTestResultStatus!]
    stepResultStatus(
      where: KeyStepResultStatusWhereInput
      orderBy: KeyStepResultStatusOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyStepResultStatus!]
    languages(
      where: KeyLanguageWhereInput
      orderBy: KeyLanguageOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyLanguage!]
  }

  type KeyConnection {
    pageInfo: PageInfo!
    edges: [KeyEdge]!
    aggregate: AggregateKey!
  }

  input KeyCreateInput {
    id: ID
    userTypes: KeyUserTypeCreateManyInput
    testResultStatus: KeyTestResultStatusCreateManyInput
    stepResultStatus: KeyStepResultStatusCreateManyInput
    languages: KeyLanguageCreateManyInput
  }

  input KeyCreateOneInput {
    create: KeyCreateInput
    connect: KeyWhereUniqueInput
  }

  type KeyEdge {
    node: Key!
    cursor: String!
  }

  type KeyLanguage {
    id: ID!
    key: String!
  }

  type KeyLanguageConnection {
    pageInfo: PageInfo!
    edges: [KeyLanguageEdge]!
    aggregate: AggregateKeyLanguage!
  }

  input KeyLanguageCreateInput {
    id: ID
    key: String!
  }

  input KeyLanguageCreateManyInput {
    create: [KeyLanguageCreateInput!]
    connect: [KeyLanguageWhereUniqueInput!]
  }

  type KeyLanguageEdge {
    node: KeyLanguage!
    cursor: String!
  }

  enum KeyLanguageOrderByInput {
    id_ASC
    id_DESC
    key_ASC
    key_DESC
  }

  type KeyLanguagePreviousValues {
    id: ID!
    key: String!
  }

  input KeyLanguageScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    key: String
    key_not: String
    key_in: [String!]
    key_not_in: [String!]
    key_lt: String
    key_lte: String
    key_gt: String
    key_gte: String
    key_contains: String
    key_not_contains: String
    key_starts_with: String
    key_not_starts_with: String
    key_ends_with: String
    key_not_ends_with: String
    AND: [KeyLanguageScalarWhereInput!]
    OR: [KeyLanguageScalarWhereInput!]
    NOT: [KeyLanguageScalarWhereInput!]
  }

  type KeyLanguageSubscriptionPayload {
    mutation: MutationType!
    node: KeyLanguage
    updatedFields: [String!]
    previousValues: KeyLanguagePreviousValues
  }

  input KeyLanguageSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: KeyLanguageWhereInput
    AND: [KeyLanguageSubscriptionWhereInput!]
  }

  input KeyLanguageUpdateDataInput {
    key: String
  }

  input KeyLanguageUpdateInput {
    key: String
  }

  input KeyLanguageUpdateManyDataInput {
    key: String
  }

  input KeyLanguageUpdateManyInput {
    create: [KeyLanguageCreateInput!]
    update: [KeyLanguageUpdateWithWhereUniqueNestedInput!]
    upsert: [KeyLanguageUpsertWithWhereUniqueNestedInput!]
    delete: [KeyLanguageWhereUniqueInput!]
    connect: [KeyLanguageWhereUniqueInput!]
    set: [KeyLanguageWhereUniqueInput!]
    disconnect: [KeyLanguageWhereUniqueInput!]
    deleteMany: [KeyLanguageScalarWhereInput!]
    updateMany: [KeyLanguageUpdateManyWithWhereNestedInput!]
  }

  input KeyLanguageUpdateManyMutationInput {
    key: String
  }

  input KeyLanguageUpdateManyWithWhereNestedInput {
    where: KeyLanguageScalarWhereInput!
    data: KeyLanguageUpdateManyDataInput!
  }

  input KeyLanguageUpdateWithWhereUniqueNestedInput {
    where: KeyLanguageWhereUniqueInput!
    data: KeyLanguageUpdateDataInput!
  }

  input KeyLanguageUpsertWithWhereUniqueNestedInput {
    where: KeyLanguageWhereUniqueInput!
    update: KeyLanguageUpdateDataInput!
    create: KeyLanguageCreateInput!
  }

  input KeyLanguageWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    key: String
    key_not: String
    key_in: [String!]
    key_not_in: [String!]
    key_lt: String
    key_lte: String
    key_gt: String
    key_gte: String
    key_contains: String
    key_not_contains: String
    key_starts_with: String
    key_not_starts_with: String
    key_ends_with: String
    key_not_ends_with: String
    AND: [KeyLanguageWhereInput!]
  }

  input KeyLanguageWhereUniqueInput {
    id: ID
    key: String
  }

  enum KeyOrderByInput {
    id_ASC
    id_DESC
  }

  type KeyPreviousValues {
    id: ID!
  }

  type KeyStepResultStatus {
    id: ID!
    key: String!
  }

  type KeyStepResultStatusConnection {
    pageInfo: PageInfo!
    edges: [KeyStepResultStatusEdge]!
    aggregate: AggregateKeyStepResultStatus!
  }

  input KeyStepResultStatusCreateInput {
    id: ID
    key: String!
  }

  input KeyStepResultStatusCreateManyInput {
    create: [KeyStepResultStatusCreateInput!]
    connect: [KeyStepResultStatusWhereUniqueInput!]
  }

  input KeyStepResultStatusCreateOneInput {
    create: KeyStepResultStatusCreateInput
    connect: KeyStepResultStatusWhereUniqueInput
  }

  type KeyStepResultStatusEdge {
    node: KeyStepResultStatus!
    cursor: String!
  }

  enum KeyStepResultStatusOrderByInput {
    id_ASC
    id_DESC
    key_ASC
    key_DESC
  }

  type KeyStepResultStatusPreviousValues {
    id: ID!
    key: String!
  }

  input KeyStepResultStatusScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    key: String
    key_not: String
    key_in: [String!]
    key_not_in: [String!]
    key_lt: String
    key_lte: String
    key_gt: String
    key_gte: String
    key_contains: String
    key_not_contains: String
    key_starts_with: String
    key_not_starts_with: String
    key_ends_with: String
    key_not_ends_with: String
    AND: [KeyStepResultStatusScalarWhereInput!]
    OR: [KeyStepResultStatusScalarWhereInput!]
    NOT: [KeyStepResultStatusScalarWhereInput!]
  }

  type KeyStepResultStatusSubscriptionPayload {
    mutation: MutationType!
    node: KeyStepResultStatus
    updatedFields: [String!]
    previousValues: KeyStepResultStatusPreviousValues
  }

  input KeyStepResultStatusSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: KeyStepResultStatusWhereInput
    AND: [KeyStepResultStatusSubscriptionWhereInput!]
  }

  input KeyStepResultStatusUpdateDataInput {
    key: String
  }

  input KeyStepResultStatusUpdateInput {
    key: String
  }

  input KeyStepResultStatusUpdateManyDataInput {
    key: String
  }

  input KeyStepResultStatusUpdateManyInput {
    create: [KeyStepResultStatusCreateInput!]
    update: [KeyStepResultStatusUpdateWithWhereUniqueNestedInput!]
    upsert: [KeyStepResultStatusUpsertWithWhereUniqueNestedInput!]
    delete: [KeyStepResultStatusWhereUniqueInput!]
    connect: [KeyStepResultStatusWhereUniqueInput!]
    set: [KeyStepResultStatusWhereUniqueInput!]
    disconnect: [KeyStepResultStatusWhereUniqueInput!]
    deleteMany: [KeyStepResultStatusScalarWhereInput!]
    updateMany: [KeyStepResultStatusUpdateManyWithWhereNestedInput!]
  }

  input KeyStepResultStatusUpdateManyMutationInput {
    key: String
  }

  input KeyStepResultStatusUpdateManyWithWhereNestedInput {
    where: KeyStepResultStatusScalarWhereInput!
    data: KeyStepResultStatusUpdateManyDataInput!
  }

  input KeyStepResultStatusUpdateOneRequiredInput {
    create: KeyStepResultStatusCreateInput
    update: KeyStepResultStatusUpdateDataInput
    upsert: KeyStepResultStatusUpsertNestedInput
    connect: KeyStepResultStatusWhereUniqueInput
  }

  input KeyStepResultStatusUpdateWithWhereUniqueNestedInput {
    where: KeyStepResultStatusWhereUniqueInput!
    data: KeyStepResultStatusUpdateDataInput!
  }

  input KeyStepResultStatusUpsertNestedInput {
    update: KeyStepResultStatusUpdateDataInput!
    create: KeyStepResultStatusCreateInput!
  }

  input KeyStepResultStatusUpsertWithWhereUniqueNestedInput {
    where: KeyStepResultStatusWhereUniqueInput!
    update: KeyStepResultStatusUpdateDataInput!
    create: KeyStepResultStatusCreateInput!
  }

  input KeyStepResultStatusWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    key: String
    key_not: String
    key_in: [String!]
    key_not_in: [String!]
    key_lt: String
    key_lte: String
    key_gt: String
    key_gte: String
    key_contains: String
    key_not_contains: String
    key_starts_with: String
    key_not_starts_with: String
    key_ends_with: String
    key_not_ends_with: String
    AND: [KeyStepResultStatusWhereInput!]
  }

  input KeyStepResultStatusWhereUniqueInput {
    id: ID
    key: String
  }

  type KeySubscriptionPayload {
    mutation: MutationType!
    node: Key
    updatedFields: [String!]
    previousValues: KeyPreviousValues
  }

  input KeySubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: KeyWhereInput
    AND: [KeySubscriptionWhereInput!]
  }

  type KeyTestResultStatus {
    id: ID!
    key: String!
  }

  type KeyTestResultStatusConnection {
    pageInfo: PageInfo!
    edges: [KeyTestResultStatusEdge]!
    aggregate: AggregateKeyTestResultStatus!
  }

  input KeyTestResultStatusCreateInput {
    id: ID
    key: String!
  }

  input KeyTestResultStatusCreateManyInput {
    create: [KeyTestResultStatusCreateInput!]
    connect: [KeyTestResultStatusWhereUniqueInput!]
  }

  input KeyTestResultStatusCreateOneInput {
    create: KeyTestResultStatusCreateInput
    connect: KeyTestResultStatusWhereUniqueInput
  }

  type KeyTestResultStatusEdge {
    node: KeyTestResultStatus!
    cursor: String!
  }

  enum KeyTestResultStatusOrderByInput {
    id_ASC
    id_DESC
    key_ASC
    key_DESC
  }

  type KeyTestResultStatusPreviousValues {
    id: ID!
    key: String!
  }

  input KeyTestResultStatusScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    key: String
    key_not: String
    key_in: [String!]
    key_not_in: [String!]
    key_lt: String
    key_lte: String
    key_gt: String
    key_gte: String
    key_contains: String
    key_not_contains: String
    key_starts_with: String
    key_not_starts_with: String
    key_ends_with: String
    key_not_ends_with: String
    AND: [KeyTestResultStatusScalarWhereInput!]
    OR: [KeyTestResultStatusScalarWhereInput!]
    NOT: [KeyTestResultStatusScalarWhereInput!]
  }

  type KeyTestResultStatusSubscriptionPayload {
    mutation: MutationType!
    node: KeyTestResultStatus
    updatedFields: [String!]
    previousValues: KeyTestResultStatusPreviousValues
  }

  input KeyTestResultStatusSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: KeyTestResultStatusWhereInput
    AND: [KeyTestResultStatusSubscriptionWhereInput!]
  }

  input KeyTestResultStatusUpdateDataInput {
    key: String
  }

  input KeyTestResultStatusUpdateInput {
    key: String
  }

  input KeyTestResultStatusUpdateManyDataInput {
    key: String
  }

  input KeyTestResultStatusUpdateManyInput {
    create: [KeyTestResultStatusCreateInput!]
    update: [KeyTestResultStatusUpdateWithWhereUniqueNestedInput!]
    upsert: [KeyTestResultStatusUpsertWithWhereUniqueNestedInput!]
    delete: [KeyTestResultStatusWhereUniqueInput!]
    connect: [KeyTestResultStatusWhereUniqueInput!]
    set: [KeyTestResultStatusWhereUniqueInput!]
    disconnect: [KeyTestResultStatusWhereUniqueInput!]
    deleteMany: [KeyTestResultStatusScalarWhereInput!]
    updateMany: [KeyTestResultStatusUpdateManyWithWhereNestedInput!]
  }

  input KeyTestResultStatusUpdateManyMutationInput {
    key: String
  }

  input KeyTestResultStatusUpdateManyWithWhereNestedInput {
    where: KeyTestResultStatusScalarWhereInput!
    data: KeyTestResultStatusUpdateManyDataInput!
  }

  input KeyTestResultStatusUpdateOneRequiredInput {
    create: KeyTestResultStatusCreateInput
    update: KeyTestResultStatusUpdateDataInput
    upsert: KeyTestResultStatusUpsertNestedInput
    connect: KeyTestResultStatusWhereUniqueInput
  }

  input KeyTestResultStatusUpdateWithWhereUniqueNestedInput {
    where: KeyTestResultStatusWhereUniqueInput!
    data: KeyTestResultStatusUpdateDataInput!
  }

  input KeyTestResultStatusUpsertNestedInput {
    update: KeyTestResultStatusUpdateDataInput!
    create: KeyTestResultStatusCreateInput!
  }

  input KeyTestResultStatusUpsertWithWhereUniqueNestedInput {
    where: KeyTestResultStatusWhereUniqueInput!
    update: KeyTestResultStatusUpdateDataInput!
    create: KeyTestResultStatusCreateInput!
  }

  input KeyTestResultStatusWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    key: String
    key_not: String
    key_in: [String!]
    key_not_in: [String!]
    key_lt: String
    key_lte: String
    key_gt: String
    key_gte: String
    key_contains: String
    key_not_contains: String
    key_starts_with: String
    key_not_starts_with: String
    key_ends_with: String
    key_not_ends_with: String
    AND: [KeyTestResultStatusWhereInput!]
  }

  input KeyTestResultStatusWhereUniqueInput {
    id: ID
    key: String
  }

  input KeyUpdateDataInput {
    userTypes: KeyUserTypeUpdateManyInput
    testResultStatus: KeyTestResultStatusUpdateManyInput
    stepResultStatus: KeyStepResultStatusUpdateManyInput
    languages: KeyLanguageUpdateManyInput
  }

  input KeyUpdateInput {
    userTypes: KeyUserTypeUpdateManyInput
    testResultStatus: KeyTestResultStatusUpdateManyInput
    stepResultStatus: KeyStepResultStatusUpdateManyInput
    languages: KeyLanguageUpdateManyInput
  }

  input KeyUpdateOneRequiredInput {
    create: KeyCreateInput
    update: KeyUpdateDataInput
    upsert: KeyUpsertNestedInput
    connect: KeyWhereUniqueInput
  }

  input KeyUpsertNestedInput {
    update: KeyUpdateDataInput!
    create: KeyCreateInput!
  }

  type KeyUserType {
    id: ID!
    key: String!
  }

  type KeyUserTypeConnection {
    pageInfo: PageInfo!
    edges: [KeyUserTypeEdge]!
    aggregate: AggregateKeyUserType!
  }

  input KeyUserTypeCreateInput {
    id: ID
    key: String!
  }

  input KeyUserTypeCreateManyInput {
    create: [KeyUserTypeCreateInput!]
    connect: [KeyUserTypeWhereUniqueInput!]
  }

  type KeyUserTypeEdge {
    node: KeyUserType!
    cursor: String!
  }

  enum KeyUserTypeOrderByInput {
    id_ASC
    id_DESC
    key_ASC
    key_DESC
  }

  type KeyUserTypePreviousValues {
    id: ID!
    key: String!
  }

  input KeyUserTypeScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    key: String
    key_not: String
    key_in: [String!]
    key_not_in: [String!]
    key_lt: String
    key_lte: String
    key_gt: String
    key_gte: String
    key_contains: String
    key_not_contains: String
    key_starts_with: String
    key_not_starts_with: String
    key_ends_with: String
    key_not_ends_with: String
    AND: [KeyUserTypeScalarWhereInput!]
    OR: [KeyUserTypeScalarWhereInput!]
    NOT: [KeyUserTypeScalarWhereInput!]
  }

  type KeyUserTypeSubscriptionPayload {
    mutation: MutationType!
    node: KeyUserType
    updatedFields: [String!]
    previousValues: KeyUserTypePreviousValues
  }

  input KeyUserTypeSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: KeyUserTypeWhereInput
    AND: [KeyUserTypeSubscriptionWhereInput!]
  }

  input KeyUserTypeUpdateDataInput {
    key: String
  }

  input KeyUserTypeUpdateInput {
    key: String
  }

  input KeyUserTypeUpdateManyDataInput {
    key: String
  }

  input KeyUserTypeUpdateManyInput {
    create: [KeyUserTypeCreateInput!]
    update: [KeyUserTypeUpdateWithWhereUniqueNestedInput!]
    upsert: [KeyUserTypeUpsertWithWhereUniqueNestedInput!]
    delete: [KeyUserTypeWhereUniqueInput!]
    connect: [KeyUserTypeWhereUniqueInput!]
    set: [KeyUserTypeWhereUniqueInput!]
    disconnect: [KeyUserTypeWhereUniqueInput!]
    deleteMany: [KeyUserTypeScalarWhereInput!]
    updateMany: [KeyUserTypeUpdateManyWithWhereNestedInput!]
  }

  input KeyUserTypeUpdateManyMutationInput {
    key: String
  }

  input KeyUserTypeUpdateManyWithWhereNestedInput {
    where: KeyUserTypeScalarWhereInput!
    data: KeyUserTypeUpdateManyDataInput!
  }

  input KeyUserTypeUpdateWithWhereUniqueNestedInput {
    where: KeyUserTypeWhereUniqueInput!
    data: KeyUserTypeUpdateDataInput!
  }

  input KeyUserTypeUpsertWithWhereUniqueNestedInput {
    where: KeyUserTypeWhereUniqueInput!
    update: KeyUserTypeUpdateDataInput!
    create: KeyUserTypeCreateInput!
  }

  input KeyUserTypeWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    key: String
    key_not: String
    key_in: [String!]
    key_not_in: [String!]
    key_lt: String
    key_lte: String
    key_gt: String
    key_gte: String
    key_contains: String
    key_not_contains: String
    key_starts_with: String
    key_not_starts_with: String
    key_ends_with: String
    key_not_ends_with: String
    AND: [KeyUserTypeWhereInput!]
  }

  input KeyUserTypeWhereUniqueInput {
    id: ID
    key: String
  }

  input KeyWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    userTypes_some: KeyUserTypeWhereInput
    testResultStatus_some: KeyTestResultStatusWhereInput
    stepResultStatus_some: KeyStepResultStatusWhereInput
    languages_some: KeyLanguageWhereInput
    AND: [KeyWhereInput!]
  }

  input KeyWhereUniqueInput {
    id: ID
  }

  scalar Long

  type Menu {
    id: ID!
    order: Int
    root: Boolean!
    menus(
      where: MenuWhereInput
      orderBy: MenuOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Menu!]
    name: MultiLanguageContent!
    items(
      where: MenuWhereInput
      orderBy: MenuOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Menu!]
  }

  type MenuConnection {
    pageInfo: PageInfo!
    edges: [MenuEdge]!
    aggregate: AggregateMenu!
  }

  input MenuCreateInput {
    id: ID
    order: Int
    root: Boolean
    menus: MenuCreateManyWithoutItemsInput
    name: MultiLanguageContentCreateOneInput!
    items: MenuCreateManyWithoutMenusInput
  }

  input MenuCreateManyInput {
    create: [MenuCreateInput!]
    connect: [MenuWhereUniqueInput!]
  }

  input MenuCreateManyWithoutItemsInput {
    create: [MenuCreateWithoutItemsInput!]
    connect: [MenuWhereUniqueInput!]
  }

  input MenuCreateManyWithoutMenusInput {
    create: [MenuCreateWithoutMenusInput!]
    connect: [MenuWhereUniqueInput!]
  }

  input MenuCreateWithoutItemsInput {
    id: ID
    order: Int
    root: Boolean
    menus: MenuCreateManyWithoutItemsInput
    name: MultiLanguageContentCreateOneInput!
  }

  input MenuCreateWithoutMenusInput {
    id: ID
    order: Int
    root: Boolean
    name: MultiLanguageContentCreateOneInput!
    items: MenuCreateManyWithoutMenusInput
  }

  type MenuEdge {
    node: Menu!
    cursor: String!
  }

  enum MenuOrderByInput {
    id_ASC
    id_DESC
    order_ASC
    order_DESC
    root_ASC
    root_DESC
  }

  type MenuPreviousValues {
    id: ID!
    order: Int
    root: Boolean!
  }

  input MenuScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    order: Int
    order_not: Int
    order_in: [Int!]
    order_not_in: [Int!]
    order_lt: Int
    order_lte: Int
    order_gt: Int
    order_gte: Int
    root: Boolean
    root_not: Boolean
    AND: [MenuScalarWhereInput!]
    OR: [MenuScalarWhereInput!]
    NOT: [MenuScalarWhereInput!]
  }

  type MenuSubscriptionPayload {
    mutation: MutationType!
    node: Menu
    updatedFields: [String!]
    previousValues: MenuPreviousValues
  }

  input MenuSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: MenuWhereInput
    AND: [MenuSubscriptionWhereInput!]
  }

  input MenuUpdateDataInput {
    order: Int
    root: Boolean
    menus: MenuUpdateManyWithoutItemsInput
    name: MultiLanguageContentUpdateOneRequiredInput
    items: MenuUpdateManyWithoutMenusInput
  }

  input MenuUpdateInput {
    order: Int
    root: Boolean
    menus: MenuUpdateManyWithoutItemsInput
    name: MultiLanguageContentUpdateOneRequiredInput
    items: MenuUpdateManyWithoutMenusInput
  }

  input MenuUpdateManyDataInput {
    order: Int
    root: Boolean
  }

  input MenuUpdateManyInput {
    create: [MenuCreateInput!]
    update: [MenuUpdateWithWhereUniqueNestedInput!]
    upsert: [MenuUpsertWithWhereUniqueNestedInput!]
    delete: [MenuWhereUniqueInput!]
    connect: [MenuWhereUniqueInput!]
    set: [MenuWhereUniqueInput!]
    disconnect: [MenuWhereUniqueInput!]
    deleteMany: [MenuScalarWhereInput!]
    updateMany: [MenuUpdateManyWithWhereNestedInput!]
  }

  input MenuUpdateManyMutationInput {
    order: Int
    root: Boolean
  }

  input MenuUpdateManyWithoutItemsInput {
    create: [MenuCreateWithoutItemsInput!]
    delete: [MenuWhereUniqueInput!]
    connect: [MenuWhereUniqueInput!]
    set: [MenuWhereUniqueInput!]
    disconnect: [MenuWhereUniqueInput!]
    update: [MenuUpdateWithWhereUniqueWithoutItemsInput!]
    upsert: [MenuUpsertWithWhereUniqueWithoutItemsInput!]
    deleteMany: [MenuScalarWhereInput!]
    updateMany: [MenuUpdateManyWithWhereNestedInput!]
  }

  input MenuUpdateManyWithoutMenusInput {
    create: [MenuCreateWithoutMenusInput!]
    delete: [MenuWhereUniqueInput!]
    connect: [MenuWhereUniqueInput!]
    set: [MenuWhereUniqueInput!]
    disconnect: [MenuWhereUniqueInput!]
    update: [MenuUpdateWithWhereUniqueWithoutMenusInput!]
    upsert: [MenuUpsertWithWhereUniqueWithoutMenusInput!]
    deleteMany: [MenuScalarWhereInput!]
    updateMany: [MenuUpdateManyWithWhereNestedInput!]
  }

  input MenuUpdateManyWithWhereNestedInput {
    where: MenuScalarWhereInput!
    data: MenuUpdateManyDataInput!
  }

  input MenuUpdateWithoutItemsDataInput {
    order: Int
    root: Boolean
    menus: MenuUpdateManyWithoutItemsInput
    name: MultiLanguageContentUpdateOneRequiredInput
  }

  input MenuUpdateWithoutMenusDataInput {
    order: Int
    root: Boolean
    name: MultiLanguageContentUpdateOneRequiredInput
    items: MenuUpdateManyWithoutMenusInput
  }

  input MenuUpdateWithWhereUniqueNestedInput {
    where: MenuWhereUniqueInput!
    data: MenuUpdateDataInput!
  }

  input MenuUpdateWithWhereUniqueWithoutItemsInput {
    where: MenuWhereUniqueInput!
    data: MenuUpdateWithoutItemsDataInput!
  }

  input MenuUpdateWithWhereUniqueWithoutMenusInput {
    where: MenuWhereUniqueInput!
    data: MenuUpdateWithoutMenusDataInput!
  }

  input MenuUpsertWithWhereUniqueNestedInput {
    where: MenuWhereUniqueInput!
    update: MenuUpdateDataInput!
    create: MenuCreateInput!
  }

  input MenuUpsertWithWhereUniqueWithoutItemsInput {
    where: MenuWhereUniqueInput!
    update: MenuUpdateWithoutItemsDataInput!
    create: MenuCreateWithoutItemsInput!
  }

  input MenuUpsertWithWhereUniqueWithoutMenusInput {
    where: MenuWhereUniqueInput!
    update: MenuUpdateWithoutMenusDataInput!
    create: MenuCreateWithoutMenusInput!
  }

  input MenuWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    order: Int
    order_not: Int
    order_in: [Int!]
    order_not_in: [Int!]
    order_lt: Int
    order_lte: Int
    order_gt: Int
    order_gte: Int
    root: Boolean
    root_not: Boolean
    menus_some: MenuWhereInput
    name: MultiLanguageContentWhereInput
    items_some: MenuWhereInput
    AND: [MenuWhereInput!]
  }

  input MenuWhereUniqueInput {
    id: ID
  }

  type Message {
    id: ID!
    title: MultiLanguageContent!
    message: MultiLanguageContent!
  }

  type MessageConnection {
    pageInfo: PageInfo!
    edges: [MessageEdge]!
    aggregate: AggregateMessage!
  }

  input MessageCreateInput {
    id: ID
    title: MultiLanguageContentCreateOneInput!
    message: MultiLanguageContentCreateOneInput!
  }

  input MessageCreateOneInput {
    create: MessageCreateInput
    connect: MessageWhereUniqueInput
  }

  type MessageEdge {
    node: Message!
    cursor: String!
  }

  enum MessageOrderByInput {
    id_ASC
    id_DESC
  }

  type MessagePreviousValues {
    id: ID!
  }

  type MessageSubscriptionPayload {
    mutation: MutationType!
    node: Message
    updatedFields: [String!]
    previousValues: MessagePreviousValues
  }

  input MessageSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: MessageWhereInput
    AND: [MessageSubscriptionWhereInput!]
  }

  input MessageUpdateDataInput {
    title: MultiLanguageContentUpdateOneRequiredInput
    message: MultiLanguageContentUpdateOneRequiredInput
  }

  input MessageUpdateInput {
    title: MultiLanguageContentUpdateOneRequiredInput
    message: MultiLanguageContentUpdateOneRequiredInput
  }

  input MessageUpdateOneRequiredInput {
    create: MessageCreateInput
    update: MessageUpdateDataInput
    upsert: MessageUpsertNestedInput
    connect: MessageWhereUniqueInput
  }

  input MessageUpsertNestedInput {
    update: MessageUpdateDataInput!
    create: MessageCreateInput!
  }

  input MessageWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    title: MultiLanguageContentWhereInput
    message: MultiLanguageContentWhereInput
    AND: [MessageWhereInput!]
  }

  input MessageWhereUniqueInput {
    id: ID
  }

  type MultiLanguageContent {
    id: ID!
    pt: String!
    en: String
  }

  type MultiLanguageContentConnection {
    pageInfo: PageInfo!
    edges: [MultiLanguageContentEdge]!
    aggregate: AggregateMultiLanguageContent!
  }

  input MultiLanguageContentCreateInput {
    id: ID
    pt: String!
    en: String
  }

  input MultiLanguageContentCreateOneInput {
    create: MultiLanguageContentCreateInput
    connect: MultiLanguageContentWhereUniqueInput
  }

  type MultiLanguageContentEdge {
    node: MultiLanguageContent!
    cursor: String!
  }

  enum MultiLanguageContentOrderByInput {
    id_ASC
    id_DESC
    pt_ASC
    pt_DESC
    en_ASC
    en_DESC
  }

  type MultiLanguageContentPreviousValues {
    id: ID!
    pt: String!
    en: String
  }

  type MultiLanguageContentSubscriptionPayload {
    mutation: MutationType!
    node: MultiLanguageContent
    updatedFields: [String!]
    previousValues: MultiLanguageContentPreviousValues
  }

  input MultiLanguageContentSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: MultiLanguageContentWhereInput
    AND: [MultiLanguageContentSubscriptionWhereInput!]
  }

  input MultiLanguageContentUpdateDataInput {
    pt: String
    en: String
  }

  input MultiLanguageContentUpdateInput {
    pt: String
    en: String
  }

  input MultiLanguageContentUpdateManyMutationInput {
    pt: String
    en: String
  }

  input MultiLanguageContentUpdateOneRequiredInput {
    create: MultiLanguageContentCreateInput
    update: MultiLanguageContentUpdateDataInput
    upsert: MultiLanguageContentUpsertNestedInput
    connect: MultiLanguageContentWhereUniqueInput
  }

  input MultiLanguageContentUpsertNestedInput {
    update: MultiLanguageContentUpdateDataInput!
    create: MultiLanguageContentCreateInput!
  }

  input MultiLanguageContentWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    pt: String
    pt_not: String
    pt_in: [String!]
    pt_not_in: [String!]
    pt_lt: String
    pt_lte: String
    pt_gt: String
    pt_gte: String
    pt_contains: String
    pt_not_contains: String
    pt_starts_with: String
    pt_not_starts_with: String
    pt_ends_with: String
    pt_not_ends_with: String
    en: String
    en_not: String
    en_in: [String!]
    en_not_in: [String!]
    en_lt: String
    en_lte: String
    en_gt: String
    en_gte: String
    en_contains: String
    en_not_contains: String
    en_starts_with: String
    en_not_starts_with: String
    en_ends_with: String
    en_not_ends_with: String
    AND: [MultiLanguageContentWhereInput!]
  }

  input MultiLanguageContentWhereUniqueInput {
    id: ID
  }

  type Mutation {
    createCompany(data: CompanyCreateInput!): Company!
    updateCompany(
      data: CompanyUpdateInput!
      where: CompanyWhereUniqueInput!
    ): Company
    updateManyCompanies(
      data: CompanyUpdateManyMutationInput!
      where: CompanyWhereInput
    ): BatchPayload!
    upsertCompany(
      where: CompanyWhereUniqueInput!
      create: CompanyCreateInput!
      update: CompanyUpdateInput!
    ): Company!
    deleteCompany(where: CompanyWhereUniqueInput!): Company
    deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
    createKey(data: KeyCreateInput!): Key!
    updateKey(data: KeyUpdateInput!, where: KeyWhereUniqueInput!): Key
    upsertKey(
      where: KeyWhereUniqueInput!
      create: KeyCreateInput!
      update: KeyUpdateInput!
    ): Key!
    deleteKey(where: KeyWhereUniqueInput!): Key
    deleteManyKeys(where: KeyWhereInput): BatchPayload!
    createKeyLanguage(data: KeyLanguageCreateInput!): KeyLanguage!
    updateKeyLanguage(
      data: KeyLanguageUpdateInput!
      where: KeyLanguageWhereUniqueInput!
    ): KeyLanguage
    updateManyKeyLanguages(
      data: KeyLanguageUpdateManyMutationInput!
      where: KeyLanguageWhereInput
    ): BatchPayload!
    upsertKeyLanguage(
      where: KeyLanguageWhereUniqueInput!
      create: KeyLanguageCreateInput!
      update: KeyLanguageUpdateInput!
    ): KeyLanguage!
    deleteKeyLanguage(where: KeyLanguageWhereUniqueInput!): KeyLanguage
    deleteManyKeyLanguages(where: KeyLanguageWhereInput): BatchPayload!
    createKeyStepResultStatus(
      data: KeyStepResultStatusCreateInput!
    ): KeyStepResultStatus!
    updateKeyStepResultStatus(
      data: KeyStepResultStatusUpdateInput!
      where: KeyStepResultStatusWhereUniqueInput!
    ): KeyStepResultStatus
    updateManyKeyStepResultStatuses(
      data: KeyStepResultStatusUpdateManyMutationInput!
      where: KeyStepResultStatusWhereInput
    ): BatchPayload!
    upsertKeyStepResultStatus(
      where: KeyStepResultStatusWhereUniqueInput!
      create: KeyStepResultStatusCreateInput!
      update: KeyStepResultStatusUpdateInput!
    ): KeyStepResultStatus!
    deleteKeyStepResultStatus(
      where: KeyStepResultStatusWhereUniqueInput!
    ): KeyStepResultStatus
    deleteManyKeyStepResultStatuses(
      where: KeyStepResultStatusWhereInput
    ): BatchPayload!
    createKeyTestResultStatus(
      data: KeyTestResultStatusCreateInput!
    ): KeyTestResultStatus!
    updateKeyTestResultStatus(
      data: KeyTestResultStatusUpdateInput!
      where: KeyTestResultStatusWhereUniqueInput!
    ): KeyTestResultStatus
    updateManyKeyTestResultStatuses(
      data: KeyTestResultStatusUpdateManyMutationInput!
      where: KeyTestResultStatusWhereInput
    ): BatchPayload!
    upsertKeyTestResultStatus(
      where: KeyTestResultStatusWhereUniqueInput!
      create: KeyTestResultStatusCreateInput!
      update: KeyTestResultStatusUpdateInput!
    ): KeyTestResultStatus!
    deleteKeyTestResultStatus(
      where: KeyTestResultStatusWhereUniqueInput!
    ): KeyTestResultStatus
    deleteManyKeyTestResultStatuses(
      where: KeyTestResultStatusWhereInput
    ): BatchPayload!
    createKeyUserType(data: KeyUserTypeCreateInput!): KeyUserType!
    updateKeyUserType(
      data: KeyUserTypeUpdateInput!
      where: KeyUserTypeWhereUniqueInput!
    ): KeyUserType
    updateManyKeyUserTypes(
      data: KeyUserTypeUpdateManyMutationInput!
      where: KeyUserTypeWhereInput
    ): BatchPayload!
    upsertKeyUserType(
      where: KeyUserTypeWhereUniqueInput!
      create: KeyUserTypeCreateInput!
      update: KeyUserTypeUpdateInput!
    ): KeyUserType!
    deleteKeyUserType(where: KeyUserTypeWhereUniqueInput!): KeyUserType
    deleteManyKeyUserTypes(where: KeyUserTypeWhereInput): BatchPayload!
    createMenu(data: MenuCreateInput!): Menu!
    updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
    updateManyMenus(
      data: MenuUpdateManyMutationInput!
      where: MenuWhereInput
    ): BatchPayload!
    upsertMenu(
      where: MenuWhereUniqueInput!
      create: MenuCreateInput!
      update: MenuUpdateInput!
    ): Menu!
    deleteMenu(where: MenuWhereUniqueInput!): Menu
    deleteManyMenus(where: MenuWhereInput): BatchPayload!
    createMessage(data: MessageCreateInput!): Message!
    updateMessage(
      data: MessageUpdateInput!
      where: MessageWhereUniqueInput!
    ): Message
    upsertMessage(
      where: MessageWhereUniqueInput!
      create: MessageCreateInput!
      update: MessageUpdateInput!
    ): Message!
    deleteMessage(where: MessageWhereUniqueInput!): Message
    deleteManyMessages(where: MessageWhereInput): BatchPayload!
    createMultiLanguageContent(
      data: MultiLanguageContentCreateInput!
    ): MultiLanguageContent!
    updateMultiLanguageContent(
      data: MultiLanguageContentUpdateInput!
      where: MultiLanguageContentWhereUniqueInput!
    ): MultiLanguageContent
    updateManyMultiLanguageContents(
      data: MultiLanguageContentUpdateManyMutationInput!
      where: MultiLanguageContentWhereInput
    ): BatchPayload!
    upsertMultiLanguageContent(
      where: MultiLanguageContentWhereUniqueInput!
      create: MultiLanguageContentCreateInput!
      update: MultiLanguageContentUpdateInput!
    ): MultiLanguageContent!
    deleteMultiLanguageContent(
      where: MultiLanguageContentWhereUniqueInput!
    ): MultiLanguageContent
    deleteManyMultiLanguageContents(
      where: MultiLanguageContentWhereInput
    ): BatchPayload!
    createPath(data: PathCreateInput!): Path!
    updatePath(data: PathUpdateInput!, where: PathWhereUniqueInput!): Path
    upsertPath(
      where: PathWhereUniqueInput!
      create: PathCreateInput!
      update: PathUpdateInput!
    ): Path!
    deletePath(where: PathWhereUniqueInput!): Path
    deleteManyPaths(where: PathWhereInput): BatchPayload!
    createStep(data: StepCreateInput!): Step!
    updateStep(data: StepUpdateInput!, where: StepWhereUniqueInput!): Step
    upsertStep(
      where: StepWhereUniqueInput!
      create: StepCreateInput!
      update: StepUpdateInput!
    ): Step!
    deleteStep(where: StepWhereUniqueInput!): Step
    deleteManySteps(where: StepWhereInput): BatchPayload!
    createStepResult(data: StepResultCreateInput!): StepResult!
    updateStepResult(
      data: StepResultUpdateInput!
      where: StepResultWhereUniqueInput!
    ): StepResult
    updateManyStepResults(
      data: StepResultUpdateManyMutationInput!
      where: StepResultWhereInput
    ): BatchPayload!
    upsertStepResult(
      where: StepResultWhereUniqueInput!
      create: StepResultCreateInput!
      update: StepResultUpdateInput!
    ): StepResult!
    deleteStepResult(where: StepResultWhereUniqueInput!): StepResult
    deleteManyStepResults(where: StepResultWhereInput): BatchPayload!
    createTest(data: TestCreateInput!): Test!
    updateTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test
    upsertTest(
      where: TestWhereUniqueInput!
      create: TestCreateInput!
      update: TestUpdateInput!
    ): Test!
    deleteTest(where: TestWhereUniqueInput!): Test
    deleteManyTests(where: TestWhereInput): BatchPayload!
    createTestResult(data: TestResultCreateInput!): TestResult!
    updateTestResult(
      data: TestResultUpdateInput!
      where: TestResultWhereUniqueInput!
    ): TestResult
    updateManyTestResults(
      data: TestResultUpdateManyMutationInput!
      where: TestResultWhereInput
    ): BatchPayload!
    upsertTestResult(
      where: TestResultWhereUniqueInput!
      create: TestResultCreateInput!
      update: TestResultUpdateInput!
    ): TestResult!
    deleteTestResult(where: TestResultWhereUniqueInput!): TestResult
    deleteManyTestResults(where: TestResultWhereInput): BatchPayload!
  }

  enum MutationType {
    CREATED
    UPDATED
    DELETED
  }

  interface Node {
    id: ID!
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type Path {
    id: ID!
    items(
      where: MenuWhereInput
      orderBy: MenuOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Menu!]
  }

  type PathConnection {
    pageInfo: PageInfo!
    edges: [PathEdge]!
    aggregate: AggregatePath!
  }

  input PathCreateInput {
    id: ID
    items: MenuCreateManyInput
  }

  input PathCreateManyInput {
    create: [PathCreateInput!]
    connect: [PathWhereUniqueInput!]
  }

  type PathEdge {
    node: Path!
    cursor: String!
  }

  enum PathOrderByInput {
    id_ASC
    id_DESC
  }

  type PathPreviousValues {
    id: ID!
  }

  input PathScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    AND: [PathScalarWhereInput!]
    OR: [PathScalarWhereInput!]
    NOT: [PathScalarWhereInput!]
  }

  type PathSubscriptionPayload {
    mutation: MutationType!
    node: Path
    updatedFields: [String!]
    previousValues: PathPreviousValues
  }

  input PathSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: PathWhereInput
    AND: [PathSubscriptionWhereInput!]
  }

  input PathUpdateDataInput {
    items: MenuUpdateManyInput
  }

  input PathUpdateInput {
    items: MenuUpdateManyInput
  }

  input PathUpdateManyInput {
    create: [PathCreateInput!]
    update: [PathUpdateWithWhereUniqueNestedInput!]
    upsert: [PathUpsertWithWhereUniqueNestedInput!]
    delete: [PathWhereUniqueInput!]
    connect: [PathWhereUniqueInput!]
    set: [PathWhereUniqueInput!]
    disconnect: [PathWhereUniqueInput!]
    deleteMany: [PathScalarWhereInput!]
  }

  input PathUpdateWithWhereUniqueNestedInput {
    where: PathWhereUniqueInput!
    data: PathUpdateDataInput!
  }

  input PathUpsertWithWhereUniqueNestedInput {
    where: PathWhereUniqueInput!
    update: PathUpdateDataInput!
    create: PathCreateInput!
  }

  input PathWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    items_some: MenuWhereInput
    AND: [PathWhereInput!]
  }

  input PathWhereUniqueInput {
    id: ID
  }

  type Query {
    company(where: CompanyWhereUniqueInput!): Company
    companies(
      where: CompanyWhereInput
      orderBy: CompanyOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Company]!
    companiesConnection(
      where: CompanyWhereInput
      orderBy: CompanyOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): CompanyConnection!
    key(where: KeyWhereUniqueInput!): Key
    keys(
      where: KeyWhereInput
      orderBy: KeyOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Key]!
    keysConnection(
      where: KeyWhereInput
      orderBy: KeyOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): KeyConnection!
    keyLanguage(where: KeyLanguageWhereUniqueInput!): KeyLanguage
    keyLanguages(
      where: KeyLanguageWhereInput
      orderBy: KeyLanguageOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyLanguage]!
    keyLanguagesConnection(
      where: KeyLanguageWhereInput
      orderBy: KeyLanguageOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): KeyLanguageConnection!
    keyStepResultStatus(
      where: KeyStepResultStatusWhereUniqueInput!
    ): KeyStepResultStatus
    keyStepResultStatuses(
      where: KeyStepResultStatusWhereInput
      orderBy: KeyStepResultStatusOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyStepResultStatus]!
    keyStepResultStatusesConnection(
      where: KeyStepResultStatusWhereInput
      orderBy: KeyStepResultStatusOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): KeyStepResultStatusConnection!
    keyTestResultStatus(
      where: KeyTestResultStatusWhereUniqueInput!
    ): KeyTestResultStatus
    keyTestResultStatuses(
      where: KeyTestResultStatusWhereInput
      orderBy: KeyTestResultStatusOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyTestResultStatus]!
    keyTestResultStatusesConnection(
      where: KeyTestResultStatusWhereInput
      orderBy: KeyTestResultStatusOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): KeyTestResultStatusConnection!
    keyUserType(where: KeyUserTypeWhereUniqueInput!): KeyUserType
    keyUserTypes(
      where: KeyUserTypeWhereInput
      orderBy: KeyUserTypeOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyUserType]!
    keyUserTypesConnection(
      where: KeyUserTypeWhereInput
      orderBy: KeyUserTypeOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): KeyUserTypeConnection!
    menu(where: MenuWhereUniqueInput!): Menu
    menus(
      where: MenuWhereInput
      orderBy: MenuOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Menu]!
    menusConnection(
      where: MenuWhereInput
      orderBy: MenuOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): MenuConnection!
    message(where: MessageWhereUniqueInput!): Message
    messages(
      where: MessageWhereInput
      orderBy: MessageOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Message]!
    messagesConnection(
      where: MessageWhereInput
      orderBy: MessageOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): MessageConnection!
    multiLanguageContent(
      where: MultiLanguageContentWhereUniqueInput!
    ): MultiLanguageContent
    multiLanguageContents(
      where: MultiLanguageContentWhereInput
      orderBy: MultiLanguageContentOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [MultiLanguageContent]!
    multiLanguageContentsConnection(
      where: MultiLanguageContentWhereInput
      orderBy: MultiLanguageContentOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): MultiLanguageContentConnection!
    path(where: PathWhereUniqueInput!): Path
    paths(
      where: PathWhereInput
      orderBy: PathOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Path]!
    pathsConnection(
      where: PathWhereInput
      orderBy: PathOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): PathConnection!
    step(where: StepWhereUniqueInput!): Step
    steps(
      where: StepWhereInput
      orderBy: StepOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Step]!
    stepsConnection(
      where: StepWhereInput
      orderBy: StepOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): StepConnection!
    stepResult(where: StepResultWhereUniqueInput!): StepResult
    stepResults(
      where: StepResultWhereInput
      orderBy: StepResultOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [StepResult]!
    stepResultsConnection(
      where: StepResultWhereInput
      orderBy: StepResultOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): StepResultConnection!
    test(where: TestWhereUniqueInput!): Test
    tests(
      where: TestWhereInput
      orderBy: TestOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Test]!
    testsConnection(
      where: TestWhereInput
      orderBy: TestOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): TestConnection!
    testResult(where: TestResultWhereUniqueInput!): TestResult
    testResults(
      where: TestResultWhereInput
      orderBy: TestResultOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [TestResult]!
    testResultsConnection(
      where: TestResultWhereInput
      orderBy: TestResultOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): TestResultConnection!
    node(id: ID!): Node
  }

  type Step {
    id: ID!
    type(
      where: KeyUserTypeWhereInput
      orderBy: KeyUserTypeOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyUserType!]
    question: MultiLanguageContent!
    targets(
      where: MenuWhereInput
      orderBy: MenuOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Menu!]
    paths(
      where: PathWhereInput
      orderBy: PathOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Path!]
    results(
      where: StepResultWhereInput
      orderBy: StepResultOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [StepResult!]
  }

  type StepConnection {
    pageInfo: PageInfo!
    edges: [StepEdge]!
    aggregate: AggregateStep!
  }

  input StepCreateInput {
    id: ID
    type: KeyUserTypeCreateManyInput
    question: MultiLanguageContentCreateOneInput!
    targets: MenuCreateManyInput
    paths: PathCreateManyInput
    results: StepResultCreateManyWithoutParentInput
  }

  input StepCreateManyInput {
    create: [StepCreateInput!]
    connect: [StepWhereUniqueInput!]
  }

  input StepCreateOneWithoutResultsInput {
    create: StepCreateWithoutResultsInput
    connect: StepWhereUniqueInput
  }

  input StepCreateWithoutResultsInput {
    id: ID
    type: KeyUserTypeCreateManyInput
    question: MultiLanguageContentCreateOneInput!
    targets: MenuCreateManyInput
    paths: PathCreateManyInput
  }

  type StepEdge {
    node: Step!
    cursor: String!
  }

  enum StepOrderByInput {
    id_ASC
    id_DESC
  }

  type StepPreviousValues {
    id: ID!
  }

  type StepResult {
    id: ID!
    parent: Step!
    result: TestResult!
    start: DateTime!
    end: DateTime!
    time: Int!
    path(
      where: MenuWhereInput
      orderBy: MenuOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Menu!]
    status: KeyStepResultStatus!
  }

  type StepResultConnection {
    pageInfo: PageInfo!
    edges: [StepResultEdge]!
    aggregate: AggregateStepResult!
  }

  input StepResultCreateInput {
    id: ID
    parent: StepCreateOneWithoutResultsInput!
    result: TestResultCreateOneWithoutStepsInput!
    start: DateTime!
    end: DateTime!
    time: Int!
    path: MenuCreateManyInput
    status: KeyStepResultStatusCreateOneInput!
  }

  input StepResultCreateManyWithoutParentInput {
    create: [StepResultCreateWithoutParentInput!]
    connect: [StepResultWhereUniqueInput!]
  }

  input StepResultCreateManyWithoutResultInput {
    create: [StepResultCreateWithoutResultInput!]
    connect: [StepResultWhereUniqueInput!]
  }

  input StepResultCreateWithoutParentInput {
    id: ID
    result: TestResultCreateOneWithoutStepsInput!
    start: DateTime!
    end: DateTime!
    time: Int!
    path: MenuCreateManyInput
    status: KeyStepResultStatusCreateOneInput!
  }

  input StepResultCreateWithoutResultInput {
    id: ID
    parent: StepCreateOneWithoutResultsInput!
    start: DateTime!
    end: DateTime!
    time: Int!
    path: MenuCreateManyInput
    status: KeyStepResultStatusCreateOneInput!
  }

  type StepResultEdge {
    node: StepResult!
    cursor: String!
  }

  enum StepResultOrderByInput {
    id_ASC
    id_DESC
    start_ASC
    start_DESC
    end_ASC
    end_DESC
    time_ASC
    time_DESC
  }

  type StepResultPreviousValues {
    id: ID!
    start: DateTime!
    end: DateTime!
    time: Int!
  }

  input StepResultScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    start: DateTime
    start_not: DateTime
    start_in: [DateTime!]
    start_not_in: [DateTime!]
    start_lt: DateTime
    start_lte: DateTime
    start_gt: DateTime
    start_gte: DateTime
    end: DateTime
    end_not: DateTime
    end_in: [DateTime!]
    end_not_in: [DateTime!]
    end_lt: DateTime
    end_lte: DateTime
    end_gt: DateTime
    end_gte: DateTime
    time: Int
    time_not: Int
    time_in: [Int!]
    time_not_in: [Int!]
    time_lt: Int
    time_lte: Int
    time_gt: Int
    time_gte: Int
    AND: [StepResultScalarWhereInput!]
    OR: [StepResultScalarWhereInput!]
    NOT: [StepResultScalarWhereInput!]
  }

  type StepResultSubscriptionPayload {
    mutation: MutationType!
    node: StepResult
    updatedFields: [String!]
    previousValues: StepResultPreviousValues
  }

  input StepResultSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: StepResultWhereInput
    AND: [StepResultSubscriptionWhereInput!]
  }

  input StepResultUpdateInput {
    parent: StepUpdateOneRequiredWithoutResultsInput
    result: TestResultUpdateOneRequiredWithoutStepsInput
    start: DateTime
    end: DateTime
    time: Int
    path: MenuUpdateManyInput
    status: KeyStepResultStatusUpdateOneRequiredInput
  }

  input StepResultUpdateManyDataInput {
    start: DateTime
    end: DateTime
    time: Int
  }

  input StepResultUpdateManyMutationInput {
    start: DateTime
    end: DateTime
    time: Int
  }

  input StepResultUpdateManyWithoutParentInput {
    create: [StepResultCreateWithoutParentInput!]
    delete: [StepResultWhereUniqueInput!]
    connect: [StepResultWhereUniqueInput!]
    set: [StepResultWhereUniqueInput!]
    disconnect: [StepResultWhereUniqueInput!]
    update: [StepResultUpdateWithWhereUniqueWithoutParentInput!]
    upsert: [StepResultUpsertWithWhereUniqueWithoutParentInput!]
    deleteMany: [StepResultScalarWhereInput!]
    updateMany: [StepResultUpdateManyWithWhereNestedInput!]
  }

  input StepResultUpdateManyWithoutResultInput {
    create: [StepResultCreateWithoutResultInput!]
    delete: [StepResultWhereUniqueInput!]
    connect: [StepResultWhereUniqueInput!]
    set: [StepResultWhereUniqueInput!]
    disconnect: [StepResultWhereUniqueInput!]
    update: [StepResultUpdateWithWhereUniqueWithoutResultInput!]
    upsert: [StepResultUpsertWithWhereUniqueWithoutResultInput!]
    deleteMany: [StepResultScalarWhereInput!]
    updateMany: [StepResultUpdateManyWithWhereNestedInput!]
  }

  input StepResultUpdateManyWithWhereNestedInput {
    where: StepResultScalarWhereInput!
    data: StepResultUpdateManyDataInput!
  }

  input StepResultUpdateWithoutParentDataInput {
    result: TestResultUpdateOneRequiredWithoutStepsInput
    start: DateTime
    end: DateTime
    time: Int
    path: MenuUpdateManyInput
    status: KeyStepResultStatusUpdateOneRequiredInput
  }

  input StepResultUpdateWithoutResultDataInput {
    parent: StepUpdateOneRequiredWithoutResultsInput
    start: DateTime
    end: DateTime
    time: Int
    path: MenuUpdateManyInput
    status: KeyStepResultStatusUpdateOneRequiredInput
  }

  input StepResultUpdateWithWhereUniqueWithoutParentInput {
    where: StepResultWhereUniqueInput!
    data: StepResultUpdateWithoutParentDataInput!
  }

  input StepResultUpdateWithWhereUniqueWithoutResultInput {
    where: StepResultWhereUniqueInput!
    data: StepResultUpdateWithoutResultDataInput!
  }

  input StepResultUpsertWithWhereUniqueWithoutParentInput {
    where: StepResultWhereUniqueInput!
    update: StepResultUpdateWithoutParentDataInput!
    create: StepResultCreateWithoutParentInput!
  }

  input StepResultUpsertWithWhereUniqueWithoutResultInput {
    where: StepResultWhereUniqueInput!
    update: StepResultUpdateWithoutResultDataInput!
    create: StepResultCreateWithoutResultInput!
  }

  input StepResultWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    parent: StepWhereInput
    result: TestResultWhereInput
    start: DateTime
    start_not: DateTime
    start_in: [DateTime!]
    start_not_in: [DateTime!]
    start_lt: DateTime
    start_lte: DateTime
    start_gt: DateTime
    start_gte: DateTime
    end: DateTime
    end_not: DateTime
    end_in: [DateTime!]
    end_not_in: [DateTime!]
    end_lt: DateTime
    end_lte: DateTime
    end_gt: DateTime
    end_gte: DateTime
    time: Int
    time_not: Int
    time_in: [Int!]
    time_not_in: [Int!]
    time_lt: Int
    time_lte: Int
    time_gt: Int
    time_gte: Int
    path_some: MenuWhereInput
    status: KeyStepResultStatusWhereInput
    AND: [StepResultWhereInput!]
  }

  input StepResultWhereUniqueInput {
    id: ID
  }

  input StepScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    AND: [StepScalarWhereInput!]
    OR: [StepScalarWhereInput!]
    NOT: [StepScalarWhereInput!]
  }

  type StepSubscriptionPayload {
    mutation: MutationType!
    node: Step
    updatedFields: [String!]
    previousValues: StepPreviousValues
  }

  input StepSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: StepWhereInput
    AND: [StepSubscriptionWhereInput!]
  }

  input StepUpdateDataInput {
    type: KeyUserTypeUpdateManyInput
    question: MultiLanguageContentUpdateOneRequiredInput
    targets: MenuUpdateManyInput
    paths: PathUpdateManyInput
    results: StepResultUpdateManyWithoutParentInput
  }

  input StepUpdateInput {
    type: KeyUserTypeUpdateManyInput
    question: MultiLanguageContentUpdateOneRequiredInput
    targets: MenuUpdateManyInput
    paths: PathUpdateManyInput
    results: StepResultUpdateManyWithoutParentInput
  }

  input StepUpdateManyInput {
    create: [StepCreateInput!]
    update: [StepUpdateWithWhereUniqueNestedInput!]
    upsert: [StepUpsertWithWhereUniqueNestedInput!]
    delete: [StepWhereUniqueInput!]
    connect: [StepWhereUniqueInput!]
    set: [StepWhereUniqueInput!]
    disconnect: [StepWhereUniqueInput!]
    deleteMany: [StepScalarWhereInput!]
  }

  input StepUpdateOneRequiredWithoutResultsInput {
    create: StepCreateWithoutResultsInput
    update: StepUpdateWithoutResultsDataInput
    upsert: StepUpsertWithoutResultsInput
    connect: StepWhereUniqueInput
  }

  input StepUpdateWithoutResultsDataInput {
    type: KeyUserTypeUpdateManyInput
    question: MultiLanguageContentUpdateOneRequiredInput
    targets: MenuUpdateManyInput
    paths: PathUpdateManyInput
  }

  input StepUpdateWithWhereUniqueNestedInput {
    where: StepWhereUniqueInput!
    data: StepUpdateDataInput!
  }

  input StepUpsertWithoutResultsInput {
    update: StepUpdateWithoutResultsDataInput!
    create: StepCreateWithoutResultsInput!
  }

  input StepUpsertWithWhereUniqueNestedInput {
    where: StepWhereUniqueInput!
    update: StepUpdateDataInput!
    create: StepCreateInput!
  }

  input StepWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    type_some: KeyUserTypeWhereInput
    question: MultiLanguageContentWhereInput
    targets_some: MenuWhereInput
    paths_some: PathWhereInput
    results_some: StepResultWhereInput
    AND: [StepWhereInput!]
  }

  input StepWhereUniqueInput {
    id: ID
  }

  type Subscription {
    company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
    key(where: KeySubscriptionWhereInput): KeySubscriptionPayload
    keyLanguage(
      where: KeyLanguageSubscriptionWhereInput
    ): KeyLanguageSubscriptionPayload
    keyStepResultStatus(
      where: KeyStepResultStatusSubscriptionWhereInput
    ): KeyStepResultStatusSubscriptionPayload
    keyTestResultStatus(
      where: KeyTestResultStatusSubscriptionWhereInput
    ): KeyTestResultStatusSubscriptionPayload
    keyUserType(
      where: KeyUserTypeSubscriptionWhereInput
    ): KeyUserTypeSubscriptionPayload
    menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
    message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
    multiLanguageContent(
      where: MultiLanguageContentSubscriptionWhereInput
    ): MultiLanguageContentSubscriptionPayload
    path(where: PathSubscriptionWhereInput): PathSubscriptionPayload
    step(where: StepSubscriptionWhereInput): StepSubscriptionPayload
    stepResult(
      where: StepResultSubscriptionWhereInput
    ): StepResultSubscriptionPayload
    test(where: TestSubscriptionWhereInput): TestSubscriptionPayload
    testResult(
      where: TestResultSubscriptionWhereInput
    ): TestResultSubscriptionPayload
  }

  type Test {
    id: ID!
    publics(
      where: KeyUserTypeWhereInput
      orderBy: KeyUserTypeOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyUserType!]
    languages(
      where: KeyLanguageWhereInput
      orderBy: KeyLanguageOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [KeyLanguage!]
    instruction: Message!
    company: Company!
    title: MultiLanguageContent!
    steps(
      where: StepWhereInput
      orderBy: StepOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Step!]
    menus(
      where: MenuWhereInput
      orderBy: MenuOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [Menu!]
    results(
      where: TestResultWhereInput
      orderBy: TestResultOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [TestResult!]
    keys: Key!
  }

  type TestConnection {
    pageInfo: PageInfo!
    edges: [TestEdge]!
    aggregate: AggregateTest!
  }

  input TestCreateInput {
    id: ID
    publics: KeyUserTypeCreateManyInput
    languages: KeyLanguageCreateManyInput
    instruction: MessageCreateOneInput!
    company: CompanyCreateOneWithoutTestsInput!
    title: MultiLanguageContentCreateOneInput!
    steps: StepCreateManyInput
    menus: MenuCreateManyInput
    results: TestResultCreateManyWithoutParentInput
    keys: KeyCreateOneInput!
  }

  input TestCreateManyWithoutCompanyInput {
    create: [TestCreateWithoutCompanyInput!]
    connect: [TestWhereUniqueInput!]
  }

  input TestCreateOneWithoutResultsInput {
    create: TestCreateWithoutResultsInput
    connect: TestWhereUniqueInput
  }

  input TestCreateWithoutCompanyInput {
    id: ID
    publics: KeyUserTypeCreateManyInput
    languages: KeyLanguageCreateManyInput
    instruction: MessageCreateOneInput!
    title: MultiLanguageContentCreateOneInput!
    steps: StepCreateManyInput
    menus: MenuCreateManyInput
    results: TestResultCreateManyWithoutParentInput
    keys: KeyCreateOneInput!
  }

  input TestCreateWithoutResultsInput {
    id: ID
    publics: KeyUserTypeCreateManyInput
    languages: KeyLanguageCreateManyInput
    instruction: MessageCreateOneInput!
    company: CompanyCreateOneWithoutTestsInput!
    title: MultiLanguageContentCreateOneInput!
    steps: StepCreateManyInput
    menus: MenuCreateManyInput
    keys: KeyCreateOneInput!
  }

  type TestEdge {
    node: Test!
    cursor: String!
  }

  enum TestOrderByInput {
    id_ASC
    id_DESC
  }

  type TestPreviousValues {
    id: ID!
  }

  type TestResult {
    id: ID!
    parent: Test!
    start: DateTime!
    end: DateTime
    time: Int
    steps(
      where: StepResultWhereInput
      orderBy: StepResultOrderByInput
      skip: Int
      after: String
      before: String
      first: Int
      last: Int
    ): [StepResult!]
    status: KeyTestResultStatus!
  }

  type TestResultConnection {
    pageInfo: PageInfo!
    edges: [TestResultEdge]!
    aggregate: AggregateTestResult!
  }

  input TestResultCreateInput {
    id: ID
    parent: TestCreateOneWithoutResultsInput!
    start: DateTime!
    end: DateTime
    time: Int
    steps: StepResultCreateManyWithoutResultInput
    status: KeyTestResultStatusCreateOneInput!
  }

  input TestResultCreateManyWithoutParentInput {
    create: [TestResultCreateWithoutParentInput!]
    connect: [TestResultWhereUniqueInput!]
  }

  input TestResultCreateOneWithoutStepsInput {
    create: TestResultCreateWithoutStepsInput
    connect: TestResultWhereUniqueInput
  }

  input TestResultCreateWithoutParentInput {
    id: ID
    start: DateTime!
    end: DateTime
    time: Int
    steps: StepResultCreateManyWithoutResultInput
    status: KeyTestResultStatusCreateOneInput!
  }

  input TestResultCreateWithoutStepsInput {
    id: ID
    parent: TestCreateOneWithoutResultsInput!
    start: DateTime!
    end: DateTime
    time: Int
    status: KeyTestResultStatusCreateOneInput!
  }

  type TestResultEdge {
    node: TestResult!
    cursor: String!
  }

  enum TestResultOrderByInput {
    id_ASC
    id_DESC
    start_ASC
    start_DESC
    end_ASC
    end_DESC
    time_ASC
    time_DESC
  }

  type TestResultPreviousValues {
    id: ID!
    start: DateTime!
    end: DateTime
    time: Int
  }

  input TestResultScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    start: DateTime
    start_not: DateTime
    start_in: [DateTime!]
    start_not_in: [DateTime!]
    start_lt: DateTime
    start_lte: DateTime
    start_gt: DateTime
    start_gte: DateTime
    end: DateTime
    end_not: DateTime
    end_in: [DateTime!]
    end_not_in: [DateTime!]
    end_lt: DateTime
    end_lte: DateTime
    end_gt: DateTime
    end_gte: DateTime
    time: Int
    time_not: Int
    time_in: [Int!]
    time_not_in: [Int!]
    time_lt: Int
    time_lte: Int
    time_gt: Int
    time_gte: Int
    AND: [TestResultScalarWhereInput!]
    OR: [TestResultScalarWhereInput!]
    NOT: [TestResultScalarWhereInput!]
  }

  type TestResultSubscriptionPayload {
    mutation: MutationType!
    node: TestResult
    updatedFields: [String!]
    previousValues: TestResultPreviousValues
  }

  input TestResultSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: TestResultWhereInput
    AND: [TestResultSubscriptionWhereInput!]
  }

  input TestResultUpdateInput {
    parent: TestUpdateOneRequiredWithoutResultsInput
    start: DateTime
    end: DateTime
    time: Int
    steps: StepResultUpdateManyWithoutResultInput
    status: KeyTestResultStatusUpdateOneRequiredInput
  }

  input TestResultUpdateManyDataInput {
    start: DateTime
    end: DateTime
    time: Int
  }

  input TestResultUpdateManyMutationInput {
    start: DateTime
    end: DateTime
    time: Int
  }

  input TestResultUpdateManyWithoutParentInput {
    create: [TestResultCreateWithoutParentInput!]
    delete: [TestResultWhereUniqueInput!]
    connect: [TestResultWhereUniqueInput!]
    set: [TestResultWhereUniqueInput!]
    disconnect: [TestResultWhereUniqueInput!]
    update: [TestResultUpdateWithWhereUniqueWithoutParentInput!]
    upsert: [TestResultUpsertWithWhereUniqueWithoutParentInput!]
    deleteMany: [TestResultScalarWhereInput!]
    updateMany: [TestResultUpdateManyWithWhereNestedInput!]
  }

  input TestResultUpdateManyWithWhereNestedInput {
    where: TestResultScalarWhereInput!
    data: TestResultUpdateManyDataInput!
  }

  input TestResultUpdateOneRequiredWithoutStepsInput {
    create: TestResultCreateWithoutStepsInput
    update: TestResultUpdateWithoutStepsDataInput
    upsert: TestResultUpsertWithoutStepsInput
    connect: TestResultWhereUniqueInput
  }

  input TestResultUpdateWithoutParentDataInput {
    start: DateTime
    end: DateTime
    time: Int
    steps: StepResultUpdateManyWithoutResultInput
    status: KeyTestResultStatusUpdateOneRequiredInput
  }

  input TestResultUpdateWithoutStepsDataInput {
    parent: TestUpdateOneRequiredWithoutResultsInput
    start: DateTime
    end: DateTime
    time: Int
    status: KeyTestResultStatusUpdateOneRequiredInput
  }

  input TestResultUpdateWithWhereUniqueWithoutParentInput {
    where: TestResultWhereUniqueInput!
    data: TestResultUpdateWithoutParentDataInput!
  }

  input TestResultUpsertWithoutStepsInput {
    update: TestResultUpdateWithoutStepsDataInput!
    create: TestResultCreateWithoutStepsInput!
  }

  input TestResultUpsertWithWhereUniqueWithoutParentInput {
    where: TestResultWhereUniqueInput!
    update: TestResultUpdateWithoutParentDataInput!
    create: TestResultCreateWithoutParentInput!
  }

  input TestResultWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    parent: TestWhereInput
    start: DateTime
    start_not: DateTime
    start_in: [DateTime!]
    start_not_in: [DateTime!]
    start_lt: DateTime
    start_lte: DateTime
    start_gt: DateTime
    start_gte: DateTime
    end: DateTime
    end_not: DateTime
    end_in: [DateTime!]
    end_not_in: [DateTime!]
    end_lt: DateTime
    end_lte: DateTime
    end_gt: DateTime
    end_gte: DateTime
    time: Int
    time_not: Int
    time_in: [Int!]
    time_not_in: [Int!]
    time_lt: Int
    time_lte: Int
    time_gt: Int
    time_gte: Int
    steps_some: StepResultWhereInput
    status: KeyTestResultStatusWhereInput
    AND: [TestResultWhereInput!]
  }

  input TestResultWhereUniqueInput {
    id: ID
  }

  input TestScalarWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    AND: [TestScalarWhereInput!]
    OR: [TestScalarWhereInput!]
    NOT: [TestScalarWhereInput!]
  }

  type TestSubscriptionPayload {
    mutation: MutationType!
    node: Test
    updatedFields: [String!]
    previousValues: TestPreviousValues
  }

  input TestSubscriptionWhereInput {
    mutation_in: [MutationType!]
    updatedFields_contains: String
    updatedFields_contains_every: [String!]
    updatedFields_contains_some: [String!]
    node: TestWhereInput
    AND: [TestSubscriptionWhereInput!]
  }

  input TestUpdateInput {
    publics: KeyUserTypeUpdateManyInput
    languages: KeyLanguageUpdateManyInput
    instruction: MessageUpdateOneRequiredInput
    company: CompanyUpdateOneRequiredWithoutTestsInput
    title: MultiLanguageContentUpdateOneRequiredInput
    steps: StepUpdateManyInput
    menus: MenuUpdateManyInput
    results: TestResultUpdateManyWithoutParentInput
    keys: KeyUpdateOneRequiredInput
  }

  input TestUpdateManyWithoutCompanyInput {
    create: [TestCreateWithoutCompanyInput!]
    delete: [TestWhereUniqueInput!]
    connect: [TestWhereUniqueInput!]
    set: [TestWhereUniqueInput!]
    disconnect: [TestWhereUniqueInput!]
    update: [TestUpdateWithWhereUniqueWithoutCompanyInput!]
    upsert: [TestUpsertWithWhereUniqueWithoutCompanyInput!]
    deleteMany: [TestScalarWhereInput!]
  }

  input TestUpdateOneRequiredWithoutResultsInput {
    create: TestCreateWithoutResultsInput
    update: TestUpdateWithoutResultsDataInput
    upsert: TestUpsertWithoutResultsInput
    connect: TestWhereUniqueInput
  }

  input TestUpdateWithoutCompanyDataInput {
    publics: KeyUserTypeUpdateManyInput
    languages: KeyLanguageUpdateManyInput
    instruction: MessageUpdateOneRequiredInput
    title: MultiLanguageContentUpdateOneRequiredInput
    steps: StepUpdateManyInput
    menus: MenuUpdateManyInput
    results: TestResultUpdateManyWithoutParentInput
    keys: KeyUpdateOneRequiredInput
  }

  input TestUpdateWithoutResultsDataInput {
    publics: KeyUserTypeUpdateManyInput
    languages: KeyLanguageUpdateManyInput
    instruction: MessageUpdateOneRequiredInput
    company: CompanyUpdateOneRequiredWithoutTestsInput
    title: MultiLanguageContentUpdateOneRequiredInput
    steps: StepUpdateManyInput
    menus: MenuUpdateManyInput
    keys: KeyUpdateOneRequiredInput
  }

  input TestUpdateWithWhereUniqueWithoutCompanyInput {
    where: TestWhereUniqueInput!
    data: TestUpdateWithoutCompanyDataInput!
  }

  input TestUpsertWithoutResultsInput {
    update: TestUpdateWithoutResultsDataInput!
    create: TestCreateWithoutResultsInput!
  }

  input TestUpsertWithWhereUniqueWithoutCompanyInput {
    where: TestWhereUniqueInput!
    update: TestUpdateWithoutCompanyDataInput!
    create: TestCreateWithoutCompanyInput!
  }

  input TestWhereInput {
    id: ID
    id_not: ID
    id_in: [ID!]
    id_not_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_gt: ID
    id_gte: ID
    id_contains: ID
    id_not_contains: ID
    id_starts_with: ID
    id_not_starts_with: ID
    id_ends_with: ID
    id_not_ends_with: ID
    publics_some: KeyUserTypeWhereInput
    languages_some: KeyLanguageWhereInput
    instruction: MessageWhereInput
    company: CompanyWhereInput
    title: MultiLanguageContentWhereInput
    steps_some: StepWhereInput
    menus_some: MenuWhereInput
    results_some: TestResultWhereInput
    keys: KeyWhereInput
    AND: [TestWhereInput!]
  }

  input TestWhereUniqueInput {
    id: ID
  }
`
