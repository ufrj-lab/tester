// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  menu: (where?: MenuWhereInput) => Promise<boolean>;
  step: (where?: StepWhereInput) => Promise<boolean>;
  stepResult: (where?: StepResultWhereInput) => Promise<boolean>;
  test: (where?: TestWhereInput) => Promise<boolean>;
  testResult: (where?: TestResultWhereInput) => Promise<boolean>;
  timeResult: (where?: TimeResultWhereInput) => Promise<boolean>;
  view: (where?: ViewWhereInput) => Promise<boolean>;
  welcome: (where?: WelcomeWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  company: (where: CompanyWhereUniqueInput) => CompanyPromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  menu: (where: MenuWhereUniqueInput) => MenuPromise;
  menus: (args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Menu>;
  menusConnection: (args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuConnectionPromise;
  step: (where: StepWhereUniqueInput) => StepPromise;
  steps: (args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Step>;
  stepsConnection: (args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StepConnectionPromise;
  stepResult: (where: StepResultWhereUniqueInput) => StepResultPromise;
  stepResults: (args?: {
    where?: StepResultWhereInput;
    orderBy?: StepResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StepResult>;
  stepResultsConnection: (args?: {
    where?: StepResultWhereInput;
    orderBy?: StepResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StepResultConnectionPromise;
  test: (where: TestWhereUniqueInput) => TestPromise;
  tests: (args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Test>;
  testsConnection: (args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestConnectionPromise;
  testResult: (where: TestResultWhereUniqueInput) => TestResultPromise;
  testResults: (args?: {
    where?: TestResultWhereInput;
    orderBy?: TestResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TestResult>;
  testResultsConnection: (args?: {
    where?: TestResultWhereInput;
    orderBy?: TestResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestResultConnectionPromise;
  timeResult: (where: TimeResultWhereUniqueInput) => TimeResultPromise;
  timeResults: (args?: {
    where?: TimeResultWhereInput;
    orderBy?: TimeResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TimeResult>;
  timeResultsConnection: (args?: {
    where?: TimeResultWhereInput;
    orderBy?: TimeResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TimeResultConnectionPromise;
  view: (where: ViewWhereUniqueInput) => ViewPromise;
  views: (args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<View>;
  viewsConnection: (args?: {
    where?: ViewWhereInput;
    orderBy?: ViewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ViewConnectionPromise;
  welcome: (where: WelcomeWhereUniqueInput) => WelcomePromise;
  welcomes: (args?: {
    where?: WelcomeWhereInput;
    orderBy?: WelcomeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Welcome>;
  welcomesConnection: (args?: {
    where?: WelcomeWhereInput;
    orderBy?: WelcomeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WelcomeConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createMenu: (data: MenuCreateInput) => MenuPromise;
  updateMenu: (args: {
    data: MenuUpdateInput;
    where: MenuWhereUniqueInput;
  }) => MenuPromise;
  updateManyMenus: (args: {
    data: MenuUpdateManyMutationInput;
    where?: MenuWhereInput;
  }) => BatchPayloadPromise;
  upsertMenu: (args: {
    where: MenuWhereUniqueInput;
    create: MenuCreateInput;
    update: MenuUpdateInput;
  }) => MenuPromise;
  deleteMenu: (where: MenuWhereUniqueInput) => MenuPromise;
  deleteManyMenus: (where?: MenuWhereInput) => BatchPayloadPromise;
  createStep: (data: StepCreateInput) => StepPromise;
  updateStep: (args: {
    data: StepUpdateInput;
    where: StepWhereUniqueInput;
  }) => StepPromise;
  updateManySteps: (args: {
    data: StepUpdateManyMutationInput;
    where?: StepWhereInput;
  }) => BatchPayloadPromise;
  upsertStep: (args: {
    where: StepWhereUniqueInput;
    create: StepCreateInput;
    update: StepUpdateInput;
  }) => StepPromise;
  deleteStep: (where: StepWhereUniqueInput) => StepPromise;
  deleteManySteps: (where?: StepWhereInput) => BatchPayloadPromise;
  createStepResult: (data: StepResultCreateInput) => StepResultPromise;
  updateStepResult: (args: {
    data: StepResultUpdateInput;
    where: StepResultWhereUniqueInput;
  }) => StepResultPromise;
  updateManyStepResults: (args: {
    data: StepResultUpdateManyMutationInput;
    where?: StepResultWhereInput;
  }) => BatchPayloadPromise;
  upsertStepResult: (args: {
    where: StepResultWhereUniqueInput;
    create: StepResultCreateInput;
    update: StepResultUpdateInput;
  }) => StepResultPromise;
  deleteStepResult: (where: StepResultWhereUniqueInput) => StepResultPromise;
  deleteManyStepResults: (where?: StepResultWhereInput) => BatchPayloadPromise;
  createTest: (data: TestCreateInput) => TestPromise;
  updateTest: (args: {
    data: TestUpdateInput;
    where: TestWhereUniqueInput;
  }) => TestPromise;
  updateManyTests: (args: {
    data: TestUpdateManyMutationInput;
    where?: TestWhereInput;
  }) => BatchPayloadPromise;
  upsertTest: (args: {
    where: TestWhereUniqueInput;
    create: TestCreateInput;
    update: TestUpdateInput;
  }) => TestPromise;
  deleteTest: (where: TestWhereUniqueInput) => TestPromise;
  deleteManyTests: (where?: TestWhereInput) => BatchPayloadPromise;
  createTestResult: (data: TestResultCreateInput) => TestResultPromise;
  updateTestResult: (args: {
    data: TestResultUpdateInput;
    where: TestResultWhereUniqueInput;
  }) => TestResultPromise;
  updateManyTestResults: (args: {
    data: TestResultUpdateManyMutationInput;
    where?: TestResultWhereInput;
  }) => BatchPayloadPromise;
  upsertTestResult: (args: {
    where: TestResultWhereUniqueInput;
    create: TestResultCreateInput;
    update: TestResultUpdateInput;
  }) => TestResultPromise;
  deleteTestResult: (where: TestResultWhereUniqueInput) => TestResultPromise;
  deleteManyTestResults: (where?: TestResultWhereInput) => BatchPayloadPromise;
  createTimeResult: (data: TimeResultCreateInput) => TimeResultPromise;
  updateTimeResult: (args: {
    data: TimeResultUpdateInput;
    where: TimeResultWhereUniqueInput;
  }) => TimeResultPromise;
  updateManyTimeResults: (args: {
    data: TimeResultUpdateManyMutationInput;
    where?: TimeResultWhereInput;
  }) => BatchPayloadPromise;
  upsertTimeResult: (args: {
    where: TimeResultWhereUniqueInput;
    create: TimeResultCreateInput;
    update: TimeResultUpdateInput;
  }) => TimeResultPromise;
  deleteTimeResult: (where: TimeResultWhereUniqueInput) => TimeResultPromise;
  deleteManyTimeResults: (where?: TimeResultWhereInput) => BatchPayloadPromise;
  createView: (data: ViewCreateInput) => ViewPromise;
  updateView: (args: {
    data: ViewUpdateInput;
    where: ViewWhereUniqueInput;
  }) => ViewPromise;
  upsertView: (args: {
    where: ViewWhereUniqueInput;
    create: ViewCreateInput;
    update: ViewUpdateInput;
  }) => ViewPromise;
  deleteView: (where: ViewWhereUniqueInput) => ViewPromise;
  deleteManyViews: (where?: ViewWhereInput) => BatchPayloadPromise;
  createWelcome: (data: WelcomeCreateInput) => WelcomePromise;
  updateWelcome: (args: {
    data: WelcomeUpdateInput;
    where: WelcomeWhereUniqueInput;
  }) => WelcomePromise;
  updateManyWelcomes: (args: {
    data: WelcomeUpdateManyMutationInput;
    where?: WelcomeWhereInput;
  }) => BatchPayloadPromise;
  upsertWelcome: (args: {
    where: WelcomeWhereUniqueInput;
    create: WelcomeCreateInput;
    update: WelcomeUpdateInput;
  }) => WelcomePromise;
  deleteWelcome: (where: WelcomeWhereUniqueInput) => WelcomePromise;
  deleteManyWelcomes: (where?: WelcomeWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  menu: (
    where?: MenuSubscriptionWhereInput
  ) => MenuSubscriptionPayloadSubscription;
  step: (
    where?: StepSubscriptionWhereInput
  ) => StepSubscriptionPayloadSubscription;
  stepResult: (
    where?: StepResultSubscriptionWhereInput
  ) => StepResultSubscriptionPayloadSubscription;
  test: (
    where?: TestSubscriptionWhereInput
  ) => TestSubscriptionPayloadSubscription;
  testResult: (
    where?: TestResultSubscriptionWhereInput
  ) => TestResultSubscriptionPayloadSubscription;
  timeResult: (
    where?: TimeResultSubscriptionWhereInput
  ) => TimeResultSubscriptionPayloadSubscription;
  view: (
    where?: ViewSubscriptionWhereInput
  ) => ViewSubscriptionPayloadSubscription;
  welcome: (
    where?: WelcomeSubscriptionWhereInput
  ) => WelcomeSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "abbr_ASC"
  | "abbr_DESC"
  | "logo_ASC"
  | "logo_DESC";

export type MenuOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type ResultStatus = "SUCESSES" | "PARTIAL" | "FAIL" | "ABORTED";

export type StepResultOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC"
  | "status_ASC"
  | "status_DESC";

export type StepOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "question_ASC"
  | "question_DESC";

export type TestResultOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC"
  | "status_ASC"
  | "status_DESC";

export type TestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC";

export type TimeResultOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "int_ASC"
  | "int_DESC"
  | "text_ASC"
  | "text_DESC";

export type ViewOrderByInput = "id_ASC" | "id_DESC";

export type WelcomeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "message_ASC"
  | "message_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CompanyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  abbr?: String;
  abbr_not?: String;
  abbr_in?: String[] | String;
  abbr_not_in?: String[] | String;
  abbr_lt?: String;
  abbr_lte?: String;
  abbr_gt?: String;
  abbr_gte?: String;
  abbr_contains?: String;
  abbr_not_contains?: String;
  abbr_starts_with?: String;
  abbr_not_starts_with?: String;
  abbr_ends_with?: String;
  abbr_not_ends_with?: String;
  logo?: String;
  logo_not?: String;
  logo_in?: String[] | String;
  logo_not_in?: String[] | String;
  logo_lt?: String;
  logo_lte?: String;
  logo_gt?: String;
  logo_gte?: String;
  logo_contains?: String;
  logo_not_contains?: String;
  logo_starts_with?: String;
  logo_not_starts_with?: String;
  logo_ends_with?: String;
  logo_not_ends_with?: String;
  AND?: CompanyWhereInput[] | CompanyWhereInput;
  OR?: CompanyWhereInput[] | CompanyWhereInput;
  NOT?: CompanyWhereInput[] | CompanyWhereInput;
}

export type MenuWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MenuWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  menu?: MenuWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  items_every?: MenuWhereInput;
  items_some?: MenuWhereInput;
  items_none?: MenuWhereInput;
  AND?: MenuWhereInput[] | MenuWhereInput;
  OR?: MenuWhereInput[] | MenuWhereInput;
  NOT?: MenuWhereInput[] | MenuWhereInput;
}

export type StepWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StepResultWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parent?: StepWhereInput;
  resultParent?: TestResultWhereInput;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  end?: DateTimeInput;
  end_not?: DateTimeInput;
  end_in?: DateTimeInput[] | DateTimeInput;
  end_not_in?: DateTimeInput[] | DateTimeInput;
  end_lt?: DateTimeInput;
  end_lte?: DateTimeInput;
  end_gt?: DateTimeInput;
  end_gte?: DateTimeInput;
  time?: TimeResultWhereInput;
  path_every?: MenuWhereInput;
  path_some?: MenuWhereInput;
  path_none?: MenuWhereInput;
  status?: ResultStatus;
  status_not?: ResultStatus;
  status_in?: ResultStatus[] | ResultStatus;
  status_not_in?: ResultStatus[] | ResultStatus;
  AND?: StepResultWhereInput[] | StepResultWhereInput;
  OR?: StepResultWhereInput[] | StepResultWhereInput;
  NOT?: StepResultWhereInput[] | StepResultWhereInput;
}

export interface StepWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  question?: String;
  question_not?: String;
  question_in?: String[] | String;
  question_not_in?: String[] | String;
  question_lt?: String;
  question_lte?: String;
  question_gt?: String;
  question_gte?: String;
  question_contains?: String;
  question_not_contains?: String;
  question_starts_with?: String;
  question_not_starts_with?: String;
  question_ends_with?: String;
  question_not_ends_with?: String;
  target?: MenuWhereInput;
  path_every?: MenuWhereInput;
  path_some?: MenuWhereInput;
  path_none?: MenuWhereInput;
  results_every?: StepResultWhereInput;
  results_some?: StepResultWhereInput;
  results_none?: StepResultWhereInput;
  AND?: StepWhereInput[] | StepWhereInput;
  OR?: StepWhereInput[] | StepWhereInput;
  NOT?: StepWhereInput[] | StepWhereInput;
}

export interface TestResultWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parent?: TestWhereInput;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  end?: DateTimeInput;
  end_not?: DateTimeInput;
  end_in?: DateTimeInput[] | DateTimeInput;
  end_not_in?: DateTimeInput[] | DateTimeInput;
  end_lt?: DateTimeInput;
  end_lte?: DateTimeInput;
  end_gt?: DateTimeInput;
  end_gte?: DateTimeInput;
  time?: TimeResultWhereInput;
  steps_every?: StepResultWhereInput;
  steps_some?: StepResultWhereInput;
  steps_none?: StepResultWhereInput;
  status?: ResultStatus;
  status_not?: ResultStatus;
  status_in?: ResultStatus[] | ResultStatus;
  status_not_in?: ResultStatus[] | ResultStatus;
  AND?: TestResultWhereInput[] | TestResultWhereInput;
  OR?: TestResultWhereInput[] | TestResultWhereInput;
  NOT?: TestResultWhereInput[] | TestResultWhereInput;
}

export interface TestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  steps_every?: StepWhereInput;
  steps_some?: StepWhereInput;
  steps_none?: StepWhereInput;
  menus_every?: MenuWhereInput;
  menus_some?: MenuWhereInput;
  menus_none?: MenuWhereInput;
  results_every?: TestResultWhereInput;
  results_some?: TestResultWhereInput;
  results_none?: TestResultWhereInput;
  AND?: TestWhereInput[] | TestWhereInput;
  OR?: TestWhereInput[] | TestWhereInput;
  NOT?: TestWhereInput[] | TestWhereInput;
}

export interface TimeResultWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  int?: Int;
  int_not?: Int;
  int_in?: Int[] | Int;
  int_not_in?: Int[] | Int;
  int_lt?: Int;
  int_lte?: Int;
  int_gt?: Int;
  int_gte?: Int;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: TimeResultWhereInput[] | TimeResultWhereInput;
  OR?: TimeResultWhereInput[] | TimeResultWhereInput;
  NOT?: TimeResultWhereInput[] | TimeResultWhereInput;
}

export type StepResultWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TestResultWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TimeResultWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ViewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ViewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  welcome?: WelcomeWhereInput;
  company?: CompanyWhereInput;
  menus_every?: MenuWhereInput;
  menus_some?: MenuWhereInput;
  menus_none?: MenuWhereInput;
  tests_every?: TestWhereInput;
  tests_some?: TestWhereInput;
  tests_none?: TestWhereInput;
  steps_every?: StepWhereInput;
  steps_some?: StepWhereInput;
  steps_none?: StepWhereInput;
  AND?: ViewWhereInput[] | ViewWhereInput;
  OR?: ViewWhereInput[] | ViewWhereInput;
  NOT?: ViewWhereInput[] | ViewWhereInput;
}

export interface WelcomeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  AND?: WelcomeWhereInput[] | WelcomeWhereInput;
  OR?: WelcomeWhereInput[] | WelcomeWhereInput;
  NOT?: WelcomeWhereInput[] | WelcomeWhereInput;
}

export type WelcomeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CompanyCreateInput {
  id?: ID_Input;
  name: String;
  abbr?: String;
  logo?: String;
}

export interface CompanyUpdateInput {
  name?: String;
  abbr?: String;
  logo?: String;
}

export interface CompanyUpdateManyMutationInput {
  name?: String;
  abbr?: String;
  logo?: String;
}

export interface MenuCreateInput {
  id?: ID_Input;
  menu?: MenuCreateOneWithoutItemsInput;
  name: String;
  items?: MenuCreateManyWithoutMenuInput;
}

export interface MenuCreateOneWithoutItemsInput {
  create?: MenuCreateWithoutItemsInput;
  connect?: MenuWhereUniqueInput;
}

export interface MenuCreateWithoutItemsInput {
  id?: ID_Input;
  menu?: MenuCreateOneWithoutItemsInput;
  name: String;
}

export interface MenuCreateManyWithoutMenuInput {
  create?: MenuCreateWithoutMenuInput[] | MenuCreateWithoutMenuInput;
  connect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
}

export interface MenuCreateWithoutMenuInput {
  id?: ID_Input;
  name: String;
  items?: MenuCreateManyWithoutMenuInput;
}

export interface MenuUpdateInput {
  menu?: MenuUpdateOneWithoutItemsInput;
  name?: String;
  items?: MenuUpdateManyWithoutMenuInput;
}

export interface MenuUpdateOneWithoutItemsInput {
  create?: MenuCreateWithoutItemsInput;
  update?: MenuUpdateWithoutItemsDataInput;
  upsert?: MenuUpsertWithoutItemsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MenuWhereUniqueInput;
}

export interface MenuUpdateWithoutItemsDataInput {
  menu?: MenuUpdateOneWithoutItemsInput;
  name?: String;
}

export interface MenuUpsertWithoutItemsInput {
  update: MenuUpdateWithoutItemsDataInput;
  create: MenuCreateWithoutItemsInput;
}

export interface MenuUpdateManyWithoutMenuInput {
  create?: MenuCreateWithoutMenuInput[] | MenuCreateWithoutMenuInput;
  delete?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  connect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  set?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  disconnect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  update?:
    | MenuUpdateWithWhereUniqueWithoutMenuInput[]
    | MenuUpdateWithWhereUniqueWithoutMenuInput;
  upsert?:
    | MenuUpsertWithWhereUniqueWithoutMenuInput[]
    | MenuUpsertWithWhereUniqueWithoutMenuInput;
  deleteMany?: MenuScalarWhereInput[] | MenuScalarWhereInput;
  updateMany?:
    | MenuUpdateManyWithWhereNestedInput[]
    | MenuUpdateManyWithWhereNestedInput;
}

export interface MenuUpdateWithWhereUniqueWithoutMenuInput {
  where: MenuWhereUniqueInput;
  data: MenuUpdateWithoutMenuDataInput;
}

export interface MenuUpdateWithoutMenuDataInput {
  name?: String;
  items?: MenuUpdateManyWithoutMenuInput;
}

export interface MenuUpsertWithWhereUniqueWithoutMenuInput {
  where: MenuWhereUniqueInput;
  update: MenuUpdateWithoutMenuDataInput;
  create: MenuCreateWithoutMenuInput;
}

export interface MenuScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: MenuScalarWhereInput[] | MenuScalarWhereInput;
  OR?: MenuScalarWhereInput[] | MenuScalarWhereInput;
  NOT?: MenuScalarWhereInput[] | MenuScalarWhereInput;
}

export interface MenuUpdateManyWithWhereNestedInput {
  where: MenuScalarWhereInput;
  data: MenuUpdateManyDataInput;
}

export interface MenuUpdateManyDataInput {
  name?: String;
}

export interface MenuUpdateManyMutationInput {
  name?: String;
}

export interface StepCreateInput {
  id?: ID_Input;
  question: String;
  target: MenuCreateOneInput;
  path?: MenuCreateManyInput;
  results?: StepResultCreateManyWithoutParentInput;
}

export interface MenuCreateOneInput {
  create?: MenuCreateInput;
  connect?: MenuWhereUniqueInput;
}

export interface MenuCreateManyInput {
  create?: MenuCreateInput[] | MenuCreateInput;
  connect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
}

export interface StepResultCreateManyWithoutParentInput {
  create?:
    | StepResultCreateWithoutParentInput[]
    | StepResultCreateWithoutParentInput;
  connect?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
}

export interface StepResultCreateWithoutParentInput {
  id?: ID_Input;
  resultParent: TestResultCreateOneWithoutStepsInput;
  start: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultCreateOneInput;
  path?: MenuCreateManyInput;
  status?: ResultStatus;
}

export interface TestResultCreateOneWithoutStepsInput {
  create?: TestResultCreateWithoutStepsInput;
  connect?: TestResultWhereUniqueInput;
}

export interface TestResultCreateWithoutStepsInput {
  id?: ID_Input;
  parent: TestCreateOneWithoutResultsInput;
  start: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultCreateOneInput;
  status?: ResultStatus;
}

export interface TestCreateOneWithoutResultsInput {
  create?: TestCreateWithoutResultsInput;
  connect?: TestWhereUniqueInput;
}

export interface TestCreateWithoutResultsInput {
  id?: ID_Input;
  title: String;
  steps?: StepCreateManyInput;
  menus?: MenuCreateManyInput;
}

export interface StepCreateManyInput {
  create?: StepCreateInput[] | StepCreateInput;
  connect?: StepWhereUniqueInput[] | StepWhereUniqueInput;
}

export interface TimeResultCreateOneInput {
  create?: TimeResultCreateInput;
  connect?: TimeResultWhereUniqueInput;
}

export interface TimeResultCreateInput {
  id?: ID_Input;
  int: Int;
  text: String;
}

export interface StepUpdateInput {
  question?: String;
  target?: MenuUpdateOneRequiredInput;
  path?: MenuUpdateManyInput;
  results?: StepResultUpdateManyWithoutParentInput;
}

export interface MenuUpdateOneRequiredInput {
  create?: MenuCreateInput;
  update?: MenuUpdateDataInput;
  upsert?: MenuUpsertNestedInput;
  connect?: MenuWhereUniqueInput;
}

export interface MenuUpdateDataInput {
  menu?: MenuUpdateOneWithoutItemsInput;
  name?: String;
  items?: MenuUpdateManyWithoutMenuInput;
}

export interface MenuUpsertNestedInput {
  update: MenuUpdateDataInput;
  create: MenuCreateInput;
}

export interface MenuUpdateManyInput {
  create?: MenuCreateInput[] | MenuCreateInput;
  update?:
    | MenuUpdateWithWhereUniqueNestedInput[]
    | MenuUpdateWithWhereUniqueNestedInput;
  upsert?:
    | MenuUpsertWithWhereUniqueNestedInput[]
    | MenuUpsertWithWhereUniqueNestedInput;
  delete?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  connect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  set?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  disconnect?: MenuWhereUniqueInput[] | MenuWhereUniqueInput;
  deleteMany?: MenuScalarWhereInput[] | MenuScalarWhereInput;
  updateMany?:
    | MenuUpdateManyWithWhereNestedInput[]
    | MenuUpdateManyWithWhereNestedInput;
}

export interface MenuUpdateWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput;
  data: MenuUpdateDataInput;
}

export interface MenuUpsertWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput;
  update: MenuUpdateDataInput;
  create: MenuCreateInput;
}

export interface StepResultUpdateManyWithoutParentInput {
  create?:
    | StepResultCreateWithoutParentInput[]
    | StepResultCreateWithoutParentInput;
  delete?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
  connect?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
  set?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
  disconnect?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
  update?:
    | StepResultUpdateWithWhereUniqueWithoutParentInput[]
    | StepResultUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | StepResultUpsertWithWhereUniqueWithoutParentInput[]
    | StepResultUpsertWithWhereUniqueWithoutParentInput;
  deleteMany?: StepResultScalarWhereInput[] | StepResultScalarWhereInput;
  updateMany?:
    | StepResultUpdateManyWithWhereNestedInput[]
    | StepResultUpdateManyWithWhereNestedInput;
}

export interface StepResultUpdateWithWhereUniqueWithoutParentInput {
  where: StepResultWhereUniqueInput;
  data: StepResultUpdateWithoutParentDataInput;
}

export interface StepResultUpdateWithoutParentDataInput {
  resultParent?: TestResultUpdateOneRequiredWithoutStepsInput;
  start?: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultUpdateOneInput;
  path?: MenuUpdateManyInput;
  status?: ResultStatus;
}

export interface TestResultUpdateOneRequiredWithoutStepsInput {
  create?: TestResultCreateWithoutStepsInput;
  update?: TestResultUpdateWithoutStepsDataInput;
  upsert?: TestResultUpsertWithoutStepsInput;
  connect?: TestResultWhereUniqueInput;
}

export interface TestResultUpdateWithoutStepsDataInput {
  parent?: TestUpdateOneRequiredWithoutResultsInput;
  start?: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultUpdateOneInput;
  status?: ResultStatus;
}

export interface TestUpdateOneRequiredWithoutResultsInput {
  create?: TestCreateWithoutResultsInput;
  update?: TestUpdateWithoutResultsDataInput;
  upsert?: TestUpsertWithoutResultsInput;
  connect?: TestWhereUniqueInput;
}

export interface TestUpdateWithoutResultsDataInput {
  title?: String;
  steps?: StepUpdateManyInput;
  menus?: MenuUpdateManyInput;
}

export interface StepUpdateManyInput {
  create?: StepCreateInput[] | StepCreateInput;
  update?:
    | StepUpdateWithWhereUniqueNestedInput[]
    | StepUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StepUpsertWithWhereUniqueNestedInput[]
    | StepUpsertWithWhereUniqueNestedInput;
  delete?: StepWhereUniqueInput[] | StepWhereUniqueInput;
  connect?: StepWhereUniqueInput[] | StepWhereUniqueInput;
  set?: StepWhereUniqueInput[] | StepWhereUniqueInput;
  disconnect?: StepWhereUniqueInput[] | StepWhereUniqueInput;
  deleteMany?: StepScalarWhereInput[] | StepScalarWhereInput;
  updateMany?:
    | StepUpdateManyWithWhereNestedInput[]
    | StepUpdateManyWithWhereNestedInput;
}

export interface StepUpdateWithWhereUniqueNestedInput {
  where: StepWhereUniqueInput;
  data: StepUpdateDataInput;
}

export interface StepUpdateDataInput {
  question?: String;
  target?: MenuUpdateOneRequiredInput;
  path?: MenuUpdateManyInput;
  results?: StepResultUpdateManyWithoutParentInput;
}

export interface StepUpsertWithWhereUniqueNestedInput {
  where: StepWhereUniqueInput;
  update: StepUpdateDataInput;
  create: StepCreateInput;
}

export interface StepScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  question?: String;
  question_not?: String;
  question_in?: String[] | String;
  question_not_in?: String[] | String;
  question_lt?: String;
  question_lte?: String;
  question_gt?: String;
  question_gte?: String;
  question_contains?: String;
  question_not_contains?: String;
  question_starts_with?: String;
  question_not_starts_with?: String;
  question_ends_with?: String;
  question_not_ends_with?: String;
  AND?: StepScalarWhereInput[] | StepScalarWhereInput;
  OR?: StepScalarWhereInput[] | StepScalarWhereInput;
  NOT?: StepScalarWhereInput[] | StepScalarWhereInput;
}

export interface StepUpdateManyWithWhereNestedInput {
  where: StepScalarWhereInput;
  data: StepUpdateManyDataInput;
}

export interface StepUpdateManyDataInput {
  question?: String;
}

export interface TestUpsertWithoutResultsInput {
  update: TestUpdateWithoutResultsDataInput;
  create: TestCreateWithoutResultsInput;
}

export interface TimeResultUpdateOneInput {
  create?: TimeResultCreateInput;
  update?: TimeResultUpdateDataInput;
  upsert?: TimeResultUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TimeResultWhereUniqueInput;
}

export interface TimeResultUpdateDataInput {
  int?: Int;
  text?: String;
}

export interface TimeResultUpsertNestedInput {
  update: TimeResultUpdateDataInput;
  create: TimeResultCreateInput;
}

export interface TestResultUpsertWithoutStepsInput {
  update: TestResultUpdateWithoutStepsDataInput;
  create: TestResultCreateWithoutStepsInput;
}

export interface StepResultUpsertWithWhereUniqueWithoutParentInput {
  where: StepResultWhereUniqueInput;
  update: StepResultUpdateWithoutParentDataInput;
  create: StepResultCreateWithoutParentInput;
}

export interface StepResultScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  end?: DateTimeInput;
  end_not?: DateTimeInput;
  end_in?: DateTimeInput[] | DateTimeInput;
  end_not_in?: DateTimeInput[] | DateTimeInput;
  end_lt?: DateTimeInput;
  end_lte?: DateTimeInput;
  end_gt?: DateTimeInput;
  end_gte?: DateTimeInput;
  status?: ResultStatus;
  status_not?: ResultStatus;
  status_in?: ResultStatus[] | ResultStatus;
  status_not_in?: ResultStatus[] | ResultStatus;
  AND?: StepResultScalarWhereInput[] | StepResultScalarWhereInput;
  OR?: StepResultScalarWhereInput[] | StepResultScalarWhereInput;
  NOT?: StepResultScalarWhereInput[] | StepResultScalarWhereInput;
}

export interface StepResultUpdateManyWithWhereNestedInput {
  where: StepResultScalarWhereInput;
  data: StepResultUpdateManyDataInput;
}

export interface StepResultUpdateManyDataInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
  status?: ResultStatus;
}

export interface StepUpdateManyMutationInput {
  question?: String;
}

export interface StepResultCreateInput {
  id?: ID_Input;
  parent: StepCreateOneWithoutResultsInput;
  resultParent: TestResultCreateOneWithoutStepsInput;
  start: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultCreateOneInput;
  path?: MenuCreateManyInput;
  status?: ResultStatus;
}

export interface StepCreateOneWithoutResultsInput {
  create?: StepCreateWithoutResultsInput;
  connect?: StepWhereUniqueInput;
}

export interface StepCreateWithoutResultsInput {
  id?: ID_Input;
  question: String;
  target: MenuCreateOneInput;
  path?: MenuCreateManyInput;
}

export interface StepResultUpdateInput {
  parent?: StepUpdateOneRequiredWithoutResultsInput;
  resultParent?: TestResultUpdateOneRequiredWithoutStepsInput;
  start?: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultUpdateOneInput;
  path?: MenuUpdateManyInput;
  status?: ResultStatus;
}

export interface StepUpdateOneRequiredWithoutResultsInput {
  create?: StepCreateWithoutResultsInput;
  update?: StepUpdateWithoutResultsDataInput;
  upsert?: StepUpsertWithoutResultsInput;
  connect?: StepWhereUniqueInput;
}

export interface StepUpdateWithoutResultsDataInput {
  question?: String;
  target?: MenuUpdateOneRequiredInput;
  path?: MenuUpdateManyInput;
}

export interface StepUpsertWithoutResultsInput {
  update: StepUpdateWithoutResultsDataInput;
  create: StepCreateWithoutResultsInput;
}

export interface StepResultUpdateManyMutationInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
  status?: ResultStatus;
}

export interface TestCreateInput {
  id?: ID_Input;
  title: String;
  steps?: StepCreateManyInput;
  menus?: MenuCreateManyInput;
  results?: TestResultCreateManyWithoutParentInput;
}

export interface TestResultCreateManyWithoutParentInput {
  create?:
    | TestResultCreateWithoutParentInput[]
    | TestResultCreateWithoutParentInput;
  connect?: TestResultWhereUniqueInput[] | TestResultWhereUniqueInput;
}

export interface TestResultCreateWithoutParentInput {
  id?: ID_Input;
  start: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultCreateOneInput;
  steps?: StepResultCreateManyWithoutResultParentInput;
  status?: ResultStatus;
}

export interface StepResultCreateManyWithoutResultParentInput {
  create?:
    | StepResultCreateWithoutResultParentInput[]
    | StepResultCreateWithoutResultParentInput;
  connect?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
}

export interface StepResultCreateWithoutResultParentInput {
  id?: ID_Input;
  parent: StepCreateOneWithoutResultsInput;
  start: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultCreateOneInput;
  path?: MenuCreateManyInput;
  status?: ResultStatus;
}

export interface TestUpdateInput {
  title?: String;
  steps?: StepUpdateManyInput;
  menus?: MenuUpdateManyInput;
  results?: TestResultUpdateManyWithoutParentInput;
}

export interface TestResultUpdateManyWithoutParentInput {
  create?:
    | TestResultCreateWithoutParentInput[]
    | TestResultCreateWithoutParentInput;
  delete?: TestResultWhereUniqueInput[] | TestResultWhereUniqueInput;
  connect?: TestResultWhereUniqueInput[] | TestResultWhereUniqueInput;
  set?: TestResultWhereUniqueInput[] | TestResultWhereUniqueInput;
  disconnect?: TestResultWhereUniqueInput[] | TestResultWhereUniqueInput;
  update?:
    | TestResultUpdateWithWhereUniqueWithoutParentInput[]
    | TestResultUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | TestResultUpsertWithWhereUniqueWithoutParentInput[]
    | TestResultUpsertWithWhereUniqueWithoutParentInput;
  deleteMany?: TestResultScalarWhereInput[] | TestResultScalarWhereInput;
  updateMany?:
    | TestResultUpdateManyWithWhereNestedInput[]
    | TestResultUpdateManyWithWhereNestedInput;
}

export interface TestResultUpdateWithWhereUniqueWithoutParentInput {
  where: TestResultWhereUniqueInput;
  data: TestResultUpdateWithoutParentDataInput;
}

export interface TestResultUpdateWithoutParentDataInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultUpdateOneInput;
  steps?: StepResultUpdateManyWithoutResultParentInput;
  status?: ResultStatus;
}

export interface StepResultUpdateManyWithoutResultParentInput {
  create?:
    | StepResultCreateWithoutResultParentInput[]
    | StepResultCreateWithoutResultParentInput;
  delete?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
  connect?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
  set?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
  disconnect?: StepResultWhereUniqueInput[] | StepResultWhereUniqueInput;
  update?:
    | StepResultUpdateWithWhereUniqueWithoutResultParentInput[]
    | StepResultUpdateWithWhereUniqueWithoutResultParentInput;
  upsert?:
    | StepResultUpsertWithWhereUniqueWithoutResultParentInput[]
    | StepResultUpsertWithWhereUniqueWithoutResultParentInput;
  deleteMany?: StepResultScalarWhereInput[] | StepResultScalarWhereInput;
  updateMany?:
    | StepResultUpdateManyWithWhereNestedInput[]
    | StepResultUpdateManyWithWhereNestedInput;
}

export interface StepResultUpdateWithWhereUniqueWithoutResultParentInput {
  where: StepResultWhereUniqueInput;
  data: StepResultUpdateWithoutResultParentDataInput;
}

export interface StepResultUpdateWithoutResultParentDataInput {
  parent?: StepUpdateOneRequiredWithoutResultsInput;
  start?: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultUpdateOneInput;
  path?: MenuUpdateManyInput;
  status?: ResultStatus;
}

export interface StepResultUpsertWithWhereUniqueWithoutResultParentInput {
  where: StepResultWhereUniqueInput;
  update: StepResultUpdateWithoutResultParentDataInput;
  create: StepResultCreateWithoutResultParentInput;
}

export interface TestResultUpsertWithWhereUniqueWithoutParentInput {
  where: TestResultWhereUniqueInput;
  update: TestResultUpdateWithoutParentDataInput;
  create: TestResultCreateWithoutParentInput;
}

export interface TestResultScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  end?: DateTimeInput;
  end_not?: DateTimeInput;
  end_in?: DateTimeInput[] | DateTimeInput;
  end_not_in?: DateTimeInput[] | DateTimeInput;
  end_lt?: DateTimeInput;
  end_lte?: DateTimeInput;
  end_gt?: DateTimeInput;
  end_gte?: DateTimeInput;
  status?: ResultStatus;
  status_not?: ResultStatus;
  status_in?: ResultStatus[] | ResultStatus;
  status_not_in?: ResultStatus[] | ResultStatus;
  AND?: TestResultScalarWhereInput[] | TestResultScalarWhereInput;
  OR?: TestResultScalarWhereInput[] | TestResultScalarWhereInput;
  NOT?: TestResultScalarWhereInput[] | TestResultScalarWhereInput;
}

export interface TestResultUpdateManyWithWhereNestedInput {
  where: TestResultScalarWhereInput;
  data: TestResultUpdateManyDataInput;
}

export interface TestResultUpdateManyDataInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
  status?: ResultStatus;
}

export interface TestUpdateManyMutationInput {
  title?: String;
}

export interface TestResultCreateInput {
  id?: ID_Input;
  parent: TestCreateOneWithoutResultsInput;
  start: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultCreateOneInput;
  steps?: StepResultCreateManyWithoutResultParentInput;
  status?: ResultStatus;
}

export interface TestResultUpdateInput {
  parent?: TestUpdateOneRequiredWithoutResultsInput;
  start?: DateTimeInput;
  end?: DateTimeInput;
  time?: TimeResultUpdateOneInput;
  steps?: StepResultUpdateManyWithoutResultParentInput;
  status?: ResultStatus;
}

export interface TestResultUpdateManyMutationInput {
  start?: DateTimeInput;
  end?: DateTimeInput;
  status?: ResultStatus;
}

export interface TimeResultUpdateInput {
  int?: Int;
  text?: String;
}

export interface TimeResultUpdateManyMutationInput {
  int?: Int;
  text?: String;
}

export interface ViewCreateInput {
  id?: ID_Input;
  welcome: WelcomeCreateOneInput;
  company: CompanyCreateOneInput;
  menus?: MenuCreateManyInput;
  tests?: TestCreateManyInput;
  steps?: StepCreateManyInput;
}

export interface WelcomeCreateOneInput {
  create?: WelcomeCreateInput;
  connect?: WelcomeWhereUniqueInput;
}

export interface WelcomeCreateInput {
  id?: ID_Input;
  title: String;
  message: String;
}

export interface CompanyCreateOneInput {
  create?: CompanyCreateInput;
  connect?: CompanyWhereUniqueInput;
}

export interface TestCreateManyInput {
  create?: TestCreateInput[] | TestCreateInput;
  connect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
}

export interface ViewUpdateInput {
  welcome?: WelcomeUpdateOneRequiredInput;
  company?: CompanyUpdateOneRequiredInput;
  menus?: MenuUpdateManyInput;
  tests?: TestUpdateManyInput;
  steps?: StepUpdateManyInput;
}

export interface WelcomeUpdateOneRequiredInput {
  create?: WelcomeCreateInput;
  update?: WelcomeUpdateDataInput;
  upsert?: WelcomeUpsertNestedInput;
  connect?: WelcomeWhereUniqueInput;
}

export interface WelcomeUpdateDataInput {
  title?: String;
  message?: String;
}

export interface WelcomeUpsertNestedInput {
  update: WelcomeUpdateDataInput;
  create: WelcomeCreateInput;
}

export interface CompanyUpdateOneRequiredInput {
  create?: CompanyCreateInput;
  update?: CompanyUpdateDataInput;
  upsert?: CompanyUpsertNestedInput;
  connect?: CompanyWhereUniqueInput;
}

export interface CompanyUpdateDataInput {
  name?: String;
  abbr?: String;
  logo?: String;
}

export interface CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface TestUpdateManyInput {
  create?: TestCreateInput[] | TestCreateInput;
  update?:
    | TestUpdateWithWhereUniqueNestedInput[]
    | TestUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TestUpsertWithWhereUniqueNestedInput[]
    | TestUpsertWithWhereUniqueNestedInput;
  delete?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  connect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  set?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  disconnect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  deleteMany?: TestScalarWhereInput[] | TestScalarWhereInput;
  updateMany?:
    | TestUpdateManyWithWhereNestedInput[]
    | TestUpdateManyWithWhereNestedInput;
}

export interface TestUpdateWithWhereUniqueNestedInput {
  where: TestWhereUniqueInput;
  data: TestUpdateDataInput;
}

export interface TestUpdateDataInput {
  title?: String;
  steps?: StepUpdateManyInput;
  menus?: MenuUpdateManyInput;
  results?: TestResultUpdateManyWithoutParentInput;
}

export interface TestUpsertWithWhereUniqueNestedInput {
  where: TestWhereUniqueInput;
  update: TestUpdateDataInput;
  create: TestCreateInput;
}

export interface TestScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: TestScalarWhereInput[] | TestScalarWhereInput;
  OR?: TestScalarWhereInput[] | TestScalarWhereInput;
  NOT?: TestScalarWhereInput[] | TestScalarWhereInput;
}

export interface TestUpdateManyWithWhereNestedInput {
  where: TestScalarWhereInput;
  data: TestUpdateManyDataInput;
}

export interface TestUpdateManyDataInput {
  title?: String;
}

export interface WelcomeUpdateInput {
  title?: String;
  message?: String;
}

export interface WelcomeUpdateManyMutationInput {
  title?: String;
  message?: String;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompanyWhereInput;
  AND?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  OR?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  NOT?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
}

export interface MenuSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MenuWhereInput;
  AND?: MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput;
  OR?: MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput;
  NOT?: MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput;
}

export interface StepSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StepWhereInput;
  AND?: StepSubscriptionWhereInput[] | StepSubscriptionWhereInput;
  OR?: StepSubscriptionWhereInput[] | StepSubscriptionWhereInput;
  NOT?: StepSubscriptionWhereInput[] | StepSubscriptionWhereInput;
}

export interface StepResultSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StepResultWhereInput;
  AND?: StepResultSubscriptionWhereInput[] | StepResultSubscriptionWhereInput;
  OR?: StepResultSubscriptionWhereInput[] | StepResultSubscriptionWhereInput;
  NOT?: StepResultSubscriptionWhereInput[] | StepResultSubscriptionWhereInput;
}

export interface TestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TestWhereInput;
  AND?: TestSubscriptionWhereInput[] | TestSubscriptionWhereInput;
  OR?: TestSubscriptionWhereInput[] | TestSubscriptionWhereInput;
  NOT?: TestSubscriptionWhereInput[] | TestSubscriptionWhereInput;
}

export interface TestResultSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TestResultWhereInput;
  AND?: TestResultSubscriptionWhereInput[] | TestResultSubscriptionWhereInput;
  OR?: TestResultSubscriptionWhereInput[] | TestResultSubscriptionWhereInput;
  NOT?: TestResultSubscriptionWhereInput[] | TestResultSubscriptionWhereInput;
}

export interface TimeResultSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TimeResultWhereInput;
  AND?: TimeResultSubscriptionWhereInput[] | TimeResultSubscriptionWhereInput;
  OR?: TimeResultSubscriptionWhereInput[] | TimeResultSubscriptionWhereInput;
  NOT?: TimeResultSubscriptionWhereInput[] | TimeResultSubscriptionWhereInput;
}

export interface ViewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ViewWhereInput;
  AND?: ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput;
  OR?: ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput;
  NOT?: ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput;
}

export interface WelcomeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WelcomeWhereInput;
  AND?: WelcomeSubscriptionWhereInput[] | WelcomeSubscriptionWhereInput;
  OR?: WelcomeSubscriptionWhereInput[] | WelcomeSubscriptionWhereInput;
  NOT?: WelcomeSubscriptionWhereInput[] | WelcomeSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Company {
  id: ID_Output;
  name: String;
  abbr?: String;
  logo?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  abbr: () => Promise<String>;
  logo: () => Promise<String>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  abbr: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Menu {
  id: ID_Output;
  name: String;
}

export interface MenuPromise extends Promise<Menu>, Fragmentable {
  id: () => Promise<ID_Output>;
  menu: <T = MenuPromise>() => T;
  name: () => Promise<String>;
  items: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MenuSubscription
  extends Promise<AsyncIterator<Menu>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  menu: <T = MenuSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  items: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MenuConnection {
  pageInfo: PageInfo;
  edges: MenuEdge[];
}

export interface MenuConnectionPromise
  extends Promise<MenuConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuEdge>>() => T;
  aggregate: <T = AggregateMenuPromise>() => T;
}

export interface MenuConnectionSubscription
  extends Promise<AsyncIterator<MenuConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuSubscription>() => T;
}

export interface MenuEdge {
  node: Menu;
  cursor: String;
}

export interface MenuEdgePromise extends Promise<MenuEdge>, Fragmentable {
  node: <T = MenuPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuEdgeSubscription
  extends Promise<AsyncIterator<MenuEdge>>,
    Fragmentable {
  node: <T = MenuSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMenu {
  count: Int;
}

export interface AggregateMenuPromise
  extends Promise<AggregateMenu>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuSubscription
  extends Promise<AsyncIterator<AggregateMenu>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Step {
  id: ID_Output;
  question: String;
}

export interface StepPromise extends Promise<Step>, Fragmentable {
  id: () => Promise<ID_Output>;
  question: () => Promise<String>;
  target: <T = MenuPromise>() => T;
  path: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  results: <T = FragmentableArray<StepResult>>(args?: {
    where?: StepResultWhereInput;
    orderBy?: StepResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StepSubscription
  extends Promise<AsyncIterator<Step>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  question: () => Promise<AsyncIterator<String>>;
  target: <T = MenuSubscription>() => T;
  path: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  results: <T = Promise<AsyncIterator<StepResultSubscription>>>(args?: {
    where?: StepResultWhereInput;
    orderBy?: StepResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StepResult {
  id: ID_Output;
  start: DateTimeOutput;
  end?: DateTimeOutput;
  status: ResultStatus;
}

export interface StepResultPromise extends Promise<StepResult>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = StepPromise>() => T;
  resultParent: <T = TestResultPromise>() => T;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  time: <T = TimeResultPromise>() => T;
  path: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<ResultStatus>;
}

export interface StepResultSubscription
  extends Promise<AsyncIterator<StepResult>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = StepSubscription>() => T;
  resultParent: <T = TestResultSubscription>() => T;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  time: <T = TimeResultSubscription>() => T;
  path: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<ResultStatus>>;
}

export interface TestResult {
  id: ID_Output;
  start: DateTimeOutput;
  end?: DateTimeOutput;
  status: ResultStatus;
}

export interface TestResultPromise extends Promise<TestResult>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = TestPromise>() => T;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  time: <T = TimeResultPromise>() => T;
  steps: <T = FragmentableArray<StepResult>>(args?: {
    where?: StepResultWhereInput;
    orderBy?: StepResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<ResultStatus>;
}

export interface TestResultSubscription
  extends Promise<AsyncIterator<TestResult>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = TestSubscription>() => T;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  time: <T = TimeResultSubscription>() => T;
  steps: <T = Promise<AsyncIterator<StepResultSubscription>>>(args?: {
    where?: StepResultWhereInput;
    orderBy?: StepResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<ResultStatus>>;
}

export interface Test {
  id: ID_Output;
  title: String;
}

export interface TestPromise extends Promise<Test>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  menus: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  results: <T = FragmentableArray<TestResult>>(args?: {
    where?: TestResultWhereInput;
    orderBy?: TestResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TestSubscription
  extends Promise<AsyncIterator<Test>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  results: <T = Promise<AsyncIterator<TestResultSubscription>>>(args?: {
    where?: TestResultWhereInput;
    orderBy?: TestResultOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TimeResult {
  id: ID_Output;
  int: Int;
  text: String;
}

export interface TimeResultPromise extends Promise<TimeResult>, Fragmentable {
  id: () => Promise<ID_Output>;
  int: () => Promise<Int>;
  text: () => Promise<String>;
}

export interface TimeResultSubscription
  extends Promise<AsyncIterator<TimeResult>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  int: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface StepConnection {
  pageInfo: PageInfo;
  edges: StepEdge[];
}

export interface StepConnectionPromise
  extends Promise<StepConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StepEdge>>() => T;
  aggregate: <T = AggregateStepPromise>() => T;
}

export interface StepConnectionSubscription
  extends Promise<AsyncIterator<StepConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StepEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStepSubscription>() => T;
}

export interface StepEdge {
  node: Step;
  cursor: String;
}

export interface StepEdgePromise extends Promise<StepEdge>, Fragmentable {
  node: <T = StepPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StepEdgeSubscription
  extends Promise<AsyncIterator<StepEdge>>,
    Fragmentable {
  node: <T = StepSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStep {
  count: Int;
}

export interface AggregateStepPromise
  extends Promise<AggregateStep>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStepSubscription
  extends Promise<AsyncIterator<AggregateStep>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StepResultConnection {
  pageInfo: PageInfo;
  edges: StepResultEdge[];
}

export interface StepResultConnectionPromise
  extends Promise<StepResultConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StepResultEdge>>() => T;
  aggregate: <T = AggregateStepResultPromise>() => T;
}

export interface StepResultConnectionSubscription
  extends Promise<AsyncIterator<StepResultConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StepResultEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStepResultSubscription>() => T;
}

export interface StepResultEdge {
  node: StepResult;
  cursor: String;
}

export interface StepResultEdgePromise
  extends Promise<StepResultEdge>,
    Fragmentable {
  node: <T = StepResultPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StepResultEdgeSubscription
  extends Promise<AsyncIterator<StepResultEdge>>,
    Fragmentable {
  node: <T = StepResultSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStepResult {
  count: Int;
}

export interface AggregateStepResultPromise
  extends Promise<AggregateStepResult>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStepResultSubscription
  extends Promise<AsyncIterator<AggregateStepResult>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TestConnection {
  pageInfo: PageInfo;
  edges: TestEdge[];
}

export interface TestConnectionPromise
  extends Promise<TestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestEdge>>() => T;
  aggregate: <T = AggregateTestPromise>() => T;
}

export interface TestConnectionSubscription
  extends Promise<AsyncIterator<TestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestSubscription>() => T;
}

export interface TestEdge {
  node: Test;
  cursor: String;
}

export interface TestEdgePromise extends Promise<TestEdge>, Fragmentable {
  node: <T = TestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestEdgeSubscription
  extends Promise<AsyncIterator<TestEdge>>,
    Fragmentable {
  node: <T = TestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTest {
  count: Int;
}

export interface AggregateTestPromise
  extends Promise<AggregateTest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestSubscription
  extends Promise<AsyncIterator<AggregateTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TestResultConnection {
  pageInfo: PageInfo;
  edges: TestResultEdge[];
}

export interface TestResultConnectionPromise
  extends Promise<TestResultConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestResultEdge>>() => T;
  aggregate: <T = AggregateTestResultPromise>() => T;
}

export interface TestResultConnectionSubscription
  extends Promise<AsyncIterator<TestResultConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestResultEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestResultSubscription>() => T;
}

export interface TestResultEdge {
  node: TestResult;
  cursor: String;
}

export interface TestResultEdgePromise
  extends Promise<TestResultEdge>,
    Fragmentable {
  node: <T = TestResultPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestResultEdgeSubscription
  extends Promise<AsyncIterator<TestResultEdge>>,
    Fragmentable {
  node: <T = TestResultSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTestResult {
  count: Int;
}

export interface AggregateTestResultPromise
  extends Promise<AggregateTestResult>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestResultSubscription
  extends Promise<AsyncIterator<AggregateTestResult>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TimeResultConnection {
  pageInfo: PageInfo;
  edges: TimeResultEdge[];
}

export interface TimeResultConnectionPromise
  extends Promise<TimeResultConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TimeResultEdge>>() => T;
  aggregate: <T = AggregateTimeResultPromise>() => T;
}

export interface TimeResultConnectionSubscription
  extends Promise<AsyncIterator<TimeResultConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TimeResultEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTimeResultSubscription>() => T;
}

export interface TimeResultEdge {
  node: TimeResult;
  cursor: String;
}

export interface TimeResultEdgePromise
  extends Promise<TimeResultEdge>,
    Fragmentable {
  node: <T = TimeResultPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TimeResultEdgeSubscription
  extends Promise<AsyncIterator<TimeResultEdge>>,
    Fragmentable {
  node: <T = TimeResultSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTimeResult {
  count: Int;
}

export interface AggregateTimeResultPromise
  extends Promise<AggregateTimeResult>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTimeResultSubscription
  extends Promise<AsyncIterator<AggregateTimeResult>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface View {
  id: ID_Output;
}

export interface ViewPromise extends Promise<View>, Fragmentable {
  id: () => Promise<ID_Output>;
  welcome: <T = WelcomePromise>() => T;
  company: <T = CompanyPromise>() => T;
  menus: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tests: <T = FragmentableArray<Test>>(args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ViewSubscription
  extends Promise<AsyncIterator<View>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  welcome: <T = WelcomeSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tests: <T = Promise<AsyncIterator<TestSubscription>>>(args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Welcome {
  id: ID_Output;
  title: String;
  message: String;
}

export interface WelcomePromise extends Promise<Welcome>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  message: () => Promise<String>;
}

export interface WelcomeSubscription
  extends Promise<AsyncIterator<Welcome>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface ViewConnection {
  pageInfo: PageInfo;
  edges: ViewEdge[];
}

export interface ViewConnectionPromise
  extends Promise<ViewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ViewEdge>>() => T;
  aggregate: <T = AggregateViewPromise>() => T;
}

export interface ViewConnectionSubscription
  extends Promise<AsyncIterator<ViewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ViewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateViewSubscription>() => T;
}

export interface ViewEdge {
  node: View;
  cursor: String;
}

export interface ViewEdgePromise extends Promise<ViewEdge>, Fragmentable {
  node: <T = ViewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ViewEdgeSubscription
  extends Promise<AsyncIterator<ViewEdge>>,
    Fragmentable {
  node: <T = ViewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateView {
  count: Int;
}

export interface AggregateViewPromise
  extends Promise<AggregateView>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateViewSubscription
  extends Promise<AsyncIterator<AggregateView>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WelcomeConnection {
  pageInfo: PageInfo;
  edges: WelcomeEdge[];
}

export interface WelcomeConnectionPromise
  extends Promise<WelcomeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WelcomeEdge>>() => T;
  aggregate: <T = AggregateWelcomePromise>() => T;
}

export interface WelcomeConnectionSubscription
  extends Promise<AsyncIterator<WelcomeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WelcomeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWelcomeSubscription>() => T;
}

export interface WelcomeEdge {
  node: Welcome;
  cursor: String;
}

export interface WelcomeEdgePromise extends Promise<WelcomeEdge>, Fragmentable {
  node: <T = WelcomePromise>() => T;
  cursor: () => Promise<String>;
}

export interface WelcomeEdgeSubscription
  extends Promise<AsyncIterator<WelcomeEdge>>,
    Fragmentable {
  node: <T = WelcomeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWelcome {
  count: Int;
}

export interface AggregateWelcomePromise
  extends Promise<AggregateWelcome>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWelcomeSubscription
  extends Promise<AsyncIterator<AggregateWelcome>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name: String;
  abbr?: String;
  logo?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  abbr: () => Promise<String>;
  logo: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  abbr: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
}

export interface MenuSubscriptionPayload {
  mutation: MutationType;
  node: Menu;
  updatedFields: String[];
  previousValues: MenuPreviousValues;
}

export interface MenuSubscriptionPayloadPromise
  extends Promise<MenuSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuPreviousValuesPromise>() => T;
}

export interface MenuSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuPreviousValuesSubscription>() => T;
}

export interface MenuPreviousValues {
  id: ID_Output;
  name: String;
}

export interface MenuPreviousValuesPromise
  extends Promise<MenuPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface MenuPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StepSubscriptionPayload {
  mutation: MutationType;
  node: Step;
  updatedFields: String[];
  previousValues: StepPreviousValues;
}

export interface StepSubscriptionPayloadPromise
  extends Promise<StepSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StepPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StepPreviousValuesPromise>() => T;
}

export interface StepSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StepSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StepPreviousValuesSubscription>() => T;
}

export interface StepPreviousValues {
  id: ID_Output;
  question: String;
}

export interface StepPreviousValuesPromise
  extends Promise<StepPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  question: () => Promise<String>;
}

export interface StepPreviousValuesSubscription
  extends Promise<AsyncIterator<StepPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  question: () => Promise<AsyncIterator<String>>;
}

export interface StepResultSubscriptionPayload {
  mutation: MutationType;
  node: StepResult;
  updatedFields: String[];
  previousValues: StepResultPreviousValues;
}

export interface StepResultSubscriptionPayloadPromise
  extends Promise<StepResultSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StepResultPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StepResultPreviousValuesPromise>() => T;
}

export interface StepResultSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepResultSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StepResultSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StepResultPreviousValuesSubscription>() => T;
}

export interface StepResultPreviousValues {
  id: ID_Output;
  start: DateTimeOutput;
  end?: DateTimeOutput;
  status: ResultStatus;
}

export interface StepResultPreviousValuesPromise
  extends Promise<StepResultPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  status: () => Promise<ResultStatus>;
}

export interface StepResultPreviousValuesSubscription
  extends Promise<AsyncIterator<StepResultPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<ResultStatus>>;
}

export interface TestSubscriptionPayload {
  mutation: MutationType;
  node: Test;
  updatedFields: String[];
  previousValues: TestPreviousValues;
}

export interface TestSubscriptionPayloadPromise
  extends Promise<TestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestPreviousValuesPromise>() => T;
}

export interface TestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestPreviousValuesSubscription>() => T;
}

export interface TestPreviousValues {
  id: ID_Output;
  title: String;
}

export interface TestPreviousValuesPromise
  extends Promise<TestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface TestPreviousValuesSubscription
  extends Promise<AsyncIterator<TestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface TestResultSubscriptionPayload {
  mutation: MutationType;
  node: TestResult;
  updatedFields: String[];
  previousValues: TestResultPreviousValues;
}

export interface TestResultSubscriptionPayloadPromise
  extends Promise<TestResultSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestResultPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestResultPreviousValuesPromise>() => T;
}

export interface TestResultSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestResultSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestResultSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestResultPreviousValuesSubscription>() => T;
}

export interface TestResultPreviousValues {
  id: ID_Output;
  start: DateTimeOutput;
  end?: DateTimeOutput;
  status: ResultStatus;
}

export interface TestResultPreviousValuesPromise
  extends Promise<TestResultPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  status: () => Promise<ResultStatus>;
}

export interface TestResultPreviousValuesSubscription
  extends Promise<AsyncIterator<TestResultPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<ResultStatus>>;
}

export interface TimeResultSubscriptionPayload {
  mutation: MutationType;
  node: TimeResult;
  updatedFields: String[];
  previousValues: TimeResultPreviousValues;
}

export interface TimeResultSubscriptionPayloadPromise
  extends Promise<TimeResultSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TimeResultPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TimeResultPreviousValuesPromise>() => T;
}

export interface TimeResultSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TimeResultSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TimeResultSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TimeResultPreviousValuesSubscription>() => T;
}

export interface TimeResultPreviousValues {
  id: ID_Output;
  int: Int;
  text: String;
}

export interface TimeResultPreviousValuesPromise
  extends Promise<TimeResultPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  int: () => Promise<Int>;
  text: () => Promise<String>;
}

export interface TimeResultPreviousValuesSubscription
  extends Promise<AsyncIterator<TimeResultPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  int: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ViewSubscriptionPayload {
  mutation: MutationType;
  node: View;
  updatedFields: String[];
  previousValues: ViewPreviousValues;
}

export interface ViewSubscriptionPayloadPromise
  extends Promise<ViewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ViewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ViewPreviousValuesPromise>() => T;
}

export interface ViewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ViewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ViewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ViewPreviousValuesSubscription>() => T;
}

export interface ViewPreviousValues {
  id: ID_Output;
}

export interface ViewPreviousValuesPromise
  extends Promise<ViewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ViewPreviousValuesSubscription
  extends Promise<AsyncIterator<ViewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface WelcomeSubscriptionPayload {
  mutation: MutationType;
  node: Welcome;
  updatedFields: String[];
  previousValues: WelcomePreviousValues;
}

export interface WelcomeSubscriptionPayloadPromise
  extends Promise<WelcomeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WelcomePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WelcomePreviousValuesPromise>() => T;
}

export interface WelcomeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WelcomeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WelcomeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WelcomePreviousValuesSubscription>() => T;
}

export interface WelcomePreviousValues {
  id: ID_Output;
  title: String;
  message: String;
}

export interface WelcomePreviousValuesPromise
  extends Promise<WelcomePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  message: () => Promise<String>;
}

export interface WelcomePreviousValuesSubscription
  extends Promise<AsyncIterator<WelcomePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  message: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "View",
    embedded: false
  },
  {
    name: "Welcome",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Test",
    embedded: false
  },
  {
    name: "Menu",
    embedded: false
  },
  {
    name: "Step",
    embedded: false
  },
  {
    name: "ResultStatus",
    embedded: false
  },
  {
    name: "TestResult",
    embedded: false
  },
  {
    name: "TimeResult",
    embedded: false
  },
  {
    name: "StepResult",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
