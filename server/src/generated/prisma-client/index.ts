// Code generated by Prisma (prisma@1.32.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql'
import {
   makePrismaClientClass,
   BaseClientOptions,
   Model,
} from 'prisma-client-lib'
import { typeDefs } from './prisma-schema'

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
   U[keyof U]

export type Maybe<T> = T | undefined | null

export interface Exists {
   company: (where?: CompanyWhereInput) => Promise<boolean>
   menu: (where?: MenuWhereInput) => Promise<boolean>
   step: (where?: StepWhereInput) => Promise<boolean>
   stepResult: (where?: StepResultWhereInput) => Promise<boolean>
   test: (where?: TestWhereInput) => Promise<boolean>
   testResult: (where?: TestResultWhereInput) => Promise<boolean>
   timeResult: (where?: TimeResultWhereInput) => Promise<boolean>
   view: (where?: ViewWhereInput) => Promise<boolean>
   welcome: (where?: WelcomeWhereInput) => Promise<boolean>
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

export interface Fragmentable {
   $fragment<T>(fragment: string | DocumentNode): Promise<T>
}

export interface Prisma {
   $exists: Exists
   $graphql: <T = any>(
      query: string,
      variables?: { [key: string]: any },
   ) => Promise<T>

   /**
    * Queries
    */

   company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise
   companies: (args?: {
      where?: CompanyWhereInput
      orderBy?: CompanyOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Company>
   companiesConnection: (args?: {
      where?: CompanyWhereInput
      orderBy?: CompanyOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => CompanyConnectionPromise
   menu: (where: MenuWhereUniqueInput) => MenuNullablePromise
   menus: (args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Menu>
   menusConnection: (args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => MenuConnectionPromise
   step: (where: StepWhereUniqueInput) => StepNullablePromise
   steps: (args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Step>
   stepsConnection: (args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => StepConnectionPromise
   stepResult: (where: StepResultWhereUniqueInput) => StepResultNullablePromise
   stepResults: (args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<StepResult>
   stepResultsConnection: (args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => StepResultConnectionPromise
   test: (where: TestWhereUniqueInput) => TestNullablePromise
   tests: (args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Test>
   testsConnection: (args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => TestConnectionPromise
   testResult: (where: TestResultWhereUniqueInput) => TestResultNullablePromise
   testResults: (args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<TestResult>
   testResultsConnection: (args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => TestResultConnectionPromise
   timeResult: (where: TimeResultWhereUniqueInput) => TimeResultNullablePromise
   timeResults: (args?: {
      where?: TimeResultWhereInput
      orderBy?: TimeResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<TimeResult>
   timeResultsConnection: (args?: {
      where?: TimeResultWhereInput
      orderBy?: TimeResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => TimeResultConnectionPromise
   view: (where: ViewWhereUniqueInput) => ViewNullablePromise
   views: (args?: {
      where?: ViewWhereInput
      orderBy?: ViewOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<View>
   viewsConnection: (args?: {
      where?: ViewWhereInput
      orderBy?: ViewOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => ViewConnectionPromise
   welcome: (where: WelcomeWhereUniqueInput) => WelcomeNullablePromise
   welcomes: (args?: {
      where?: WelcomeWhereInput
      orderBy?: WelcomeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Welcome>
   welcomesConnection: (args?: {
      where?: WelcomeWhereInput
      orderBy?: WelcomeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => WelcomeConnectionPromise
   node: (args: { id: ID_Output }) => Node

   /**
    * Mutations
    */

   createCompany: (data: CompanyCreateInput) => CompanyPromise
   updateCompany: (args: {
      data: CompanyUpdateInput
      where: CompanyWhereUniqueInput
   }) => CompanyPromise
   updateManyCompanies: (args: {
      data: CompanyUpdateManyMutationInput
      where?: CompanyWhereInput
   }) => BatchPayloadPromise
   upsertCompany: (args: {
      where: CompanyWhereUniqueInput
      create: CompanyCreateInput
      update: CompanyUpdateInput
   }) => CompanyPromise
   deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise
   deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise
   createMenu: (data: MenuCreateInput) => MenuPromise
   updateMenu: (args: {
      data: MenuUpdateInput
      where: MenuWhereUniqueInput
   }) => MenuPromise
   updateManyMenus: (args: {
      data: MenuUpdateManyMutationInput
      where?: MenuWhereInput
   }) => BatchPayloadPromise
   upsertMenu: (args: {
      where: MenuWhereUniqueInput
      create: MenuCreateInput
      update: MenuUpdateInput
   }) => MenuPromise
   deleteMenu: (where: MenuWhereUniqueInput) => MenuPromise
   deleteManyMenus: (where?: MenuWhereInput) => BatchPayloadPromise
   createStep: (data: StepCreateInput) => StepPromise
   updateStep: (args: {
      data: StepUpdateInput
      where: StepWhereUniqueInput
   }) => StepPromise
   updateManySteps: (args: {
      data: StepUpdateManyMutationInput
      where?: StepWhereInput
   }) => BatchPayloadPromise
   upsertStep: (args: {
      where: StepWhereUniqueInput
      create: StepCreateInput
      update: StepUpdateInput
   }) => StepPromise
   deleteStep: (where: StepWhereUniqueInput) => StepPromise
   deleteManySteps: (where?: StepWhereInput) => BatchPayloadPromise
   createStepResult: (data: StepResultCreateInput) => StepResultPromise
   updateStepResult: (args: {
      data: StepResultUpdateInput
      where: StepResultWhereUniqueInput
   }) => StepResultPromise
   updateManyStepResults: (args: {
      data: StepResultUpdateManyMutationInput
      where?: StepResultWhereInput
   }) => BatchPayloadPromise
   upsertStepResult: (args: {
      where: StepResultWhereUniqueInput
      create: StepResultCreateInput
      update: StepResultUpdateInput
   }) => StepResultPromise
   deleteStepResult: (where: StepResultWhereUniqueInput) => StepResultPromise
   deleteManyStepResults: (where?: StepResultWhereInput) => BatchPayloadPromise
   createTest: (data: TestCreateInput) => TestPromise
   updateTest: (args: {
      data: TestUpdateInput
      where: TestWhereUniqueInput
   }) => TestPromise
   updateManyTests: (args: {
      data: TestUpdateManyMutationInput
      where?: TestWhereInput
   }) => BatchPayloadPromise
   upsertTest: (args: {
      where: TestWhereUniqueInput
      create: TestCreateInput
      update: TestUpdateInput
   }) => TestPromise
   deleteTest: (where: TestWhereUniqueInput) => TestPromise
   deleteManyTests: (where?: TestWhereInput) => BatchPayloadPromise
   createTestResult: (data: TestResultCreateInput) => TestResultPromise
   updateTestResult: (args: {
      data: TestResultUpdateInput
      where: TestResultWhereUniqueInput
   }) => TestResultPromise
   updateManyTestResults: (args: {
      data: TestResultUpdateManyMutationInput
      where?: TestResultWhereInput
   }) => BatchPayloadPromise
   upsertTestResult: (args: {
      where: TestResultWhereUniqueInput
      create: TestResultCreateInput
      update: TestResultUpdateInput
   }) => TestResultPromise
   deleteTestResult: (where: TestResultWhereUniqueInput) => TestResultPromise
   deleteManyTestResults: (where?: TestResultWhereInput) => BatchPayloadPromise
   createTimeResult: (data: TimeResultCreateInput) => TimeResultPromise
   updateTimeResult: (args: {
      data: TimeResultUpdateInput
      where: TimeResultWhereUniqueInput
   }) => TimeResultPromise
   updateManyTimeResults: (args: {
      data: TimeResultUpdateManyMutationInput
      where?: TimeResultWhereInput
   }) => BatchPayloadPromise
   upsertTimeResult: (args: {
      where: TimeResultWhereUniqueInput
      create: TimeResultCreateInput
      update: TimeResultUpdateInput
   }) => TimeResultPromise
   deleteTimeResult: (where: TimeResultWhereUniqueInput) => TimeResultPromise
   deleteManyTimeResults: (where?: TimeResultWhereInput) => BatchPayloadPromise
   createView: (data: ViewCreateInput) => ViewPromise
   updateView: (args: {
      data: ViewUpdateInput
      where: ViewWhereUniqueInput
   }) => ViewPromise
   upsertView: (args: {
      where: ViewWhereUniqueInput
      create: ViewCreateInput
      update: ViewUpdateInput
   }) => ViewPromise
   deleteView: (where: ViewWhereUniqueInput) => ViewPromise
   deleteManyViews: (where?: ViewWhereInput) => BatchPayloadPromise
   createWelcome: (data: WelcomeCreateInput) => WelcomePromise
   updateWelcome: (args: {
      data: WelcomeUpdateInput
      where: WelcomeWhereUniqueInput
   }) => WelcomePromise
   updateManyWelcomes: (args: {
      data: WelcomeUpdateManyMutationInput
      where?: WelcomeWhereInput
   }) => BatchPayloadPromise
   upsertWelcome: (args: {
      where: WelcomeWhereUniqueInput
      create: WelcomeCreateInput
      update: WelcomeUpdateInput
   }) => WelcomePromise
   deleteWelcome: (where: WelcomeWhereUniqueInput) => WelcomePromise
   deleteManyWelcomes: (where?: WelcomeWhereInput) => BatchPayloadPromise

   /**
    * Subscriptions
    */

   $subscribe: Subscription
}

export interface Subscription {
   company: (
      where?: CompanySubscriptionWhereInput,
   ) => CompanySubscriptionPayloadSubscription
   menu: (
      where?: MenuSubscriptionWhereInput,
   ) => MenuSubscriptionPayloadSubscription
   step: (
      where?: StepSubscriptionWhereInput,
   ) => StepSubscriptionPayloadSubscription
   stepResult: (
      where?: StepResultSubscriptionWhereInput,
   ) => StepResultSubscriptionPayloadSubscription
   test: (
      where?: TestSubscriptionWhereInput,
   ) => TestSubscriptionPayloadSubscription
   testResult: (
      where?: TestResultSubscriptionWhereInput,
   ) => TestResultSubscriptionPayloadSubscription
   timeResult: (
      where?: TimeResultSubscriptionWhereInput,
   ) => TimeResultSubscriptionPayloadSubscription
   view: (
      where?: ViewSubscriptionWhereInput,
   ) => ViewSubscriptionPayloadSubscription
   welcome: (
      where?: WelcomeSubscriptionWhereInput,
   ) => WelcomeSubscriptionPayloadSubscription
}

export interface ClientConstructor<T> {
   new (options?: BaseClientOptions): T
}

/**
 * Types
 */

export type CompanyOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'name_ASC'
   | 'name_DESC'
   | 'abbr_ASC'
   | 'abbr_DESC'
   | 'logo_ASC'
   | 'logo_DESC'

export type MenuOrderByInput = 'id_ASC' | 'id_DESC' | 'name_ASC' | 'name_DESC'

export type ResultStatus = 'SUCESSES' | 'PARTIAL' | 'FAIL' | 'ABORTED'

export type StepResultOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'start_ASC'
   | 'start_DESC'
   | 'end_ASC'
   | 'end_DESC'
   | 'status_ASC'
   | 'status_DESC'

export type StepOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'question_ASC'
   | 'question_DESC'

export type TestResultOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'start_ASC'
   | 'start_DESC'
   | 'end_ASC'
   | 'end_DESC'
   | 'status_ASC'
   | 'status_DESC'

export type TestOrderByInput = 'id_ASC' | 'id_DESC' | 'title_ASC' | 'title_DESC'

export type TimeResultOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'int_ASC'
   | 'int_DESC'
   | 'text_ASC'
   | 'text_DESC'

export type ViewOrderByInput = 'id_ASC' | 'id_DESC'

export type WelcomeOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'title_ASC'
   | 'title_DESC'
   | 'message_ASC'
   | 'message_DESC'

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED'

export type CompanyWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface CompanyWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   abbr?: Maybe<String>
   abbr_not?: Maybe<String>
   abbr_in?: Maybe<String[] | String>
   abbr_not_in?: Maybe<String[] | String>
   abbr_lt?: Maybe<String>
   abbr_lte?: Maybe<String>
   abbr_gt?: Maybe<String>
   abbr_gte?: Maybe<String>
   abbr_contains?: Maybe<String>
   abbr_not_contains?: Maybe<String>
   abbr_starts_with?: Maybe<String>
   abbr_not_starts_with?: Maybe<String>
   abbr_ends_with?: Maybe<String>
   abbr_not_ends_with?: Maybe<String>
   logo?: Maybe<String>
   logo_not?: Maybe<String>
   logo_in?: Maybe<String[] | String>
   logo_not_in?: Maybe<String[] | String>
   logo_lt?: Maybe<String>
   logo_lte?: Maybe<String>
   logo_gt?: Maybe<String>
   logo_gte?: Maybe<String>
   logo_contains?: Maybe<String>
   logo_not_contains?: Maybe<String>
   logo_starts_with?: Maybe<String>
   logo_not_starts_with?: Maybe<String>
   logo_ends_with?: Maybe<String>
   logo_not_ends_with?: Maybe<String>
   AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>
}

export type MenuWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface MenuWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   menu?: Maybe<MenuWhereInput>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   items_some?: Maybe<MenuWhereInput>
   AND?: Maybe<MenuWhereInput[] | MenuWhereInput>
}

export type StepWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface StepResultWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   parent?: Maybe<StepWhereInput>
   resultParent?: Maybe<TestResultWhereInput>
   start?: Maybe<DateTimeInput>
   start_not?: Maybe<DateTimeInput>
   start_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_lt?: Maybe<DateTimeInput>
   start_lte?: Maybe<DateTimeInput>
   start_gt?: Maybe<DateTimeInput>
   start_gte?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   end_not?: Maybe<DateTimeInput>
   end_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_lt?: Maybe<DateTimeInput>
   end_lte?: Maybe<DateTimeInput>
   end_gt?: Maybe<DateTimeInput>
   end_gte?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultWhereInput>
   path_some?: Maybe<MenuWhereInput>
   status?: Maybe<ResultStatus>
   status_not?: Maybe<ResultStatus>
   status_in?: Maybe<ResultStatus[] | ResultStatus>
   status_not_in?: Maybe<ResultStatus[] | ResultStatus>
   AND?: Maybe<StepResultWhereInput[] | StepResultWhereInput>
}

export interface StepWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   question?: Maybe<String>
   question_not?: Maybe<String>
   question_in?: Maybe<String[] | String>
   question_not_in?: Maybe<String[] | String>
   question_lt?: Maybe<String>
   question_lte?: Maybe<String>
   question_gt?: Maybe<String>
   question_gte?: Maybe<String>
   question_contains?: Maybe<String>
   question_not_contains?: Maybe<String>
   question_starts_with?: Maybe<String>
   question_not_starts_with?: Maybe<String>
   question_ends_with?: Maybe<String>
   question_not_ends_with?: Maybe<String>
   target?: Maybe<MenuWhereInput>
   path_some?: Maybe<MenuWhereInput>
   results_some?: Maybe<StepResultWhereInput>
   AND?: Maybe<StepWhereInput[] | StepWhereInput>
}

export interface TestResultWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   parent?: Maybe<TestWhereInput>
   start?: Maybe<DateTimeInput>
   start_not?: Maybe<DateTimeInput>
   start_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_lt?: Maybe<DateTimeInput>
   start_lte?: Maybe<DateTimeInput>
   start_gt?: Maybe<DateTimeInput>
   start_gte?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   end_not?: Maybe<DateTimeInput>
   end_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_lt?: Maybe<DateTimeInput>
   end_lte?: Maybe<DateTimeInput>
   end_gt?: Maybe<DateTimeInput>
   end_gte?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultWhereInput>
   steps_some?: Maybe<StepResultWhereInput>
   status?: Maybe<ResultStatus>
   status_not?: Maybe<ResultStatus>
   status_in?: Maybe<ResultStatus[] | ResultStatus>
   status_not_in?: Maybe<ResultStatus[] | ResultStatus>
   AND?: Maybe<TestResultWhereInput[] | TestResultWhereInput>
}

export interface TestWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   steps_some?: Maybe<StepWhereInput>
   menus_some?: Maybe<MenuWhereInput>
   results_some?: Maybe<TestResultWhereInput>
   AND?: Maybe<TestWhereInput[] | TestWhereInput>
}

export interface TimeResultWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   int?: Maybe<Int>
   int_not?: Maybe<Int>
   int_in?: Maybe<Int[] | Int>
   int_not_in?: Maybe<Int[] | Int>
   int_lt?: Maybe<Int>
   int_lte?: Maybe<Int>
   int_gt?: Maybe<Int>
   int_gte?: Maybe<Int>
   text?: Maybe<String>
   text_not?: Maybe<String>
   text_in?: Maybe<String[] | String>
   text_not_in?: Maybe<String[] | String>
   text_lt?: Maybe<String>
   text_lte?: Maybe<String>
   text_gt?: Maybe<String>
   text_gte?: Maybe<String>
   text_contains?: Maybe<String>
   text_not_contains?: Maybe<String>
   text_starts_with?: Maybe<String>
   text_not_starts_with?: Maybe<String>
   text_ends_with?: Maybe<String>
   text_not_ends_with?: Maybe<String>
   AND?: Maybe<TimeResultWhereInput[] | TimeResultWhereInput>
}

export type StepResultWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type TestWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type TestResultWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type TimeResultWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type ViewWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface ViewWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   welcome?: Maybe<WelcomeWhereInput>
   company?: Maybe<CompanyWhereInput>
   menus_some?: Maybe<MenuWhereInput>
   tests_some?: Maybe<TestWhereInput>
   steps_some?: Maybe<StepWhereInput>
   AND?: Maybe<ViewWhereInput[] | ViewWhereInput>
}

export interface WelcomeWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   message?: Maybe<String>
   message_not?: Maybe<String>
   message_in?: Maybe<String[] | String>
   message_not_in?: Maybe<String[] | String>
   message_lt?: Maybe<String>
   message_lte?: Maybe<String>
   message_gt?: Maybe<String>
   message_gte?: Maybe<String>
   message_contains?: Maybe<String>
   message_not_contains?: Maybe<String>
   message_starts_with?: Maybe<String>
   message_not_starts_with?: Maybe<String>
   message_ends_with?: Maybe<String>
   message_not_ends_with?: Maybe<String>
   AND?: Maybe<WelcomeWhereInput[] | WelcomeWhereInput>
}

export type WelcomeWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface CompanyCreateInput {
   id?: Maybe<ID_Input>
   name: String
   abbr?: Maybe<String>
   logo?: Maybe<String>
}

export interface CompanyUpdateInput {
   name?: Maybe<String>
   abbr?: Maybe<String>
   logo?: Maybe<String>
}

export interface CompanyUpdateManyMutationInput {
   name?: Maybe<String>
   abbr?: Maybe<String>
   logo?: Maybe<String>
}

export interface MenuCreateInput {
   id?: Maybe<ID_Input>
   menu?: Maybe<MenuCreateOneWithoutItemsInput>
   name: String
   items?: Maybe<MenuCreateManyWithoutMenuInput>
}

export interface MenuCreateOneWithoutItemsInput {
   create?: Maybe<MenuCreateWithoutItemsInput>
   connect?: Maybe<MenuWhereUniqueInput>
}

export interface MenuCreateWithoutItemsInput {
   id?: Maybe<ID_Input>
   menu?: Maybe<MenuCreateOneWithoutItemsInput>
   name: String
}

export interface MenuCreateManyWithoutMenuInput {
   create?: Maybe<MenuCreateWithoutMenuInput[] | MenuCreateWithoutMenuInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
}

export interface MenuCreateWithoutMenuInput {
   id?: Maybe<ID_Input>
   name: String
   items?: Maybe<MenuCreateManyWithoutMenuInput>
}

export interface MenuUpdateInput {
   menu?: Maybe<MenuUpdateOneWithoutItemsInput>
   name?: Maybe<String>
   items?: Maybe<MenuUpdateManyWithoutMenuInput>
}

export interface MenuUpdateOneWithoutItemsInput {
   create?: Maybe<MenuCreateWithoutItemsInput>
   update?: Maybe<MenuUpdateWithoutItemsDataInput>
   upsert?: Maybe<MenuUpsertWithoutItemsInput>
   delete?: Maybe<Boolean>
   disconnect?: Maybe<Boolean>
   connect?: Maybe<MenuWhereUniqueInput>
}

export interface MenuUpdateWithoutItemsDataInput {
   menu?: Maybe<MenuUpdateOneWithoutItemsInput>
   name?: Maybe<String>
}

export interface MenuUpsertWithoutItemsInput {
   update: MenuUpdateWithoutItemsDataInput
   create: MenuCreateWithoutItemsInput
}

export interface MenuUpdateManyWithoutMenuInput {
   create?: Maybe<MenuCreateWithoutMenuInput[] | MenuCreateWithoutMenuInput>
   delete?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   set?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   disconnect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   update?: Maybe<
      | MenuUpdateWithWhereUniqueWithoutMenuInput[]
      | MenuUpdateWithWhereUniqueWithoutMenuInput
   >
   upsert?: Maybe<
      | MenuUpsertWithWhereUniqueWithoutMenuInput[]
      | MenuUpsertWithWhereUniqueWithoutMenuInput
   >
   deleteMany?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   updateMany?: Maybe<
      MenuUpdateManyWithWhereNestedInput[] | MenuUpdateManyWithWhereNestedInput
   >
}

export interface MenuUpdateWithWhereUniqueWithoutMenuInput {
   where: MenuWhereUniqueInput
   data: MenuUpdateWithoutMenuDataInput
}

export interface MenuUpdateWithoutMenuDataInput {
   name?: Maybe<String>
   items?: Maybe<MenuUpdateManyWithoutMenuInput>
}

export interface MenuUpsertWithWhereUniqueWithoutMenuInput {
   where: MenuWhereUniqueInput
   update: MenuUpdateWithoutMenuDataInput
   create: MenuCreateWithoutMenuInput
}

export interface MenuScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   AND?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   OR?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   NOT?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
}

export interface MenuUpdateManyWithWhereNestedInput {
   where: MenuScalarWhereInput
   data: MenuUpdateManyDataInput
}

export interface MenuUpdateManyDataInput {
   name?: Maybe<String>
}

export interface MenuUpdateManyMutationInput {
   name?: Maybe<String>
}

export interface StepCreateInput {
   id?: Maybe<ID_Input>
   question: String
   target: MenuCreateOneInput
   path?: Maybe<MenuCreateManyInput>
   results?: Maybe<StepResultCreateManyWithoutParentInput>
}

export interface MenuCreateOneInput {
   create?: Maybe<MenuCreateInput>
   connect?: Maybe<MenuWhereUniqueInput>
}

export interface MenuCreateManyInput {
   create?: Maybe<MenuCreateInput[] | MenuCreateInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
}

export interface StepResultCreateManyWithoutParentInput {
   create?: Maybe<
      StepResultCreateWithoutParentInput[] | StepResultCreateWithoutParentInput
   >
   connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
}

export interface StepResultCreateWithoutParentInput {
   id?: Maybe<ID_Input>
   resultParent: TestResultCreateOneWithoutStepsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   path?: Maybe<MenuCreateManyInput>
   status?: Maybe<ResultStatus>
}

export interface TestResultCreateOneWithoutStepsInput {
   create?: Maybe<TestResultCreateWithoutStepsInput>
   connect?: Maybe<TestResultWhereUniqueInput>
}

export interface TestResultCreateWithoutStepsInput {
   id?: Maybe<ID_Input>
   parent: TestCreateOneWithoutResultsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   status?: Maybe<ResultStatus>
}

export interface TestCreateOneWithoutResultsInput {
   create?: Maybe<TestCreateWithoutResultsInput>
   connect?: Maybe<TestWhereUniqueInput>
}

export interface TestCreateWithoutResultsInput {
   id?: Maybe<ID_Input>
   title: String
   steps?: Maybe<StepCreateManyInput>
   menus?: Maybe<MenuCreateManyInput>
}

export interface StepCreateManyInput {
   create?: Maybe<StepCreateInput[] | StepCreateInput>
   connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
}

export interface TimeResultCreateOneInput {
   create?: Maybe<TimeResultCreateInput>
   connect?: Maybe<TimeResultWhereUniqueInput>
}

export interface TimeResultCreateInput {
   id?: Maybe<ID_Input>
   int: Int
   text: String
}

export interface StepUpdateInput {
   question?: Maybe<String>
   target?: Maybe<MenuUpdateOneRequiredInput>
   path?: Maybe<MenuUpdateManyInput>
   results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface MenuUpdateOneRequiredInput {
   create?: Maybe<MenuCreateInput>
   update?: Maybe<MenuUpdateDataInput>
   upsert?: Maybe<MenuUpsertNestedInput>
   connect?: Maybe<MenuWhereUniqueInput>
}

export interface MenuUpdateDataInput {
   menu?: Maybe<MenuUpdateOneWithoutItemsInput>
   name?: Maybe<String>
   items?: Maybe<MenuUpdateManyWithoutMenuInput>
}

export interface MenuUpsertNestedInput {
   update: MenuUpdateDataInput
   create: MenuCreateInput
}

export interface MenuUpdateManyInput {
   create?: Maybe<MenuCreateInput[] | MenuCreateInput>
   update?: Maybe<
      | MenuUpdateWithWhereUniqueNestedInput[]
      | MenuUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | MenuUpsertWithWhereUniqueNestedInput[]
      | MenuUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   set?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   disconnect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   deleteMany?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   updateMany?: Maybe<
      MenuUpdateManyWithWhereNestedInput[] | MenuUpdateManyWithWhereNestedInput
   >
}

export interface MenuUpdateWithWhereUniqueNestedInput {
   where: MenuWhereUniqueInput
   data: MenuUpdateDataInput
}

export interface MenuUpsertWithWhereUniqueNestedInput {
   where: MenuWhereUniqueInput
   update: MenuUpdateDataInput
   create: MenuCreateInput
}

export interface StepResultUpdateManyWithoutParentInput {
   create?: Maybe<
      StepResultCreateWithoutParentInput[] | StepResultCreateWithoutParentInput
   >
   delete?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   set?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   disconnect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   update?: Maybe<
      | StepResultUpdateWithWhereUniqueWithoutParentInput[]
      | StepResultUpdateWithWhereUniqueWithoutParentInput
   >
   upsert?: Maybe<
      | StepResultUpsertWithWhereUniqueWithoutParentInput[]
      | StepResultUpsertWithWhereUniqueWithoutParentInput
   >
   deleteMany?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
   updateMany?: Maybe<
      | StepResultUpdateManyWithWhereNestedInput[]
      | StepResultUpdateManyWithWhereNestedInput
   >
}

export interface StepResultUpdateWithWhereUniqueWithoutParentInput {
   where: StepResultWhereUniqueInput
   data: StepResultUpdateWithoutParentDataInput
}

export interface StepResultUpdateWithoutParentDataInput {
   resultParent?: Maybe<TestResultUpdateOneRequiredWithoutStepsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   path?: Maybe<MenuUpdateManyInput>
   status?: Maybe<ResultStatus>
}

export interface TestResultUpdateOneRequiredWithoutStepsInput {
   create?: Maybe<TestResultCreateWithoutStepsInput>
   update?: Maybe<TestResultUpdateWithoutStepsDataInput>
   upsert?: Maybe<TestResultUpsertWithoutStepsInput>
   connect?: Maybe<TestResultWhereUniqueInput>
}

export interface TestResultUpdateWithoutStepsDataInput {
   parent?: Maybe<TestUpdateOneRequiredWithoutResultsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   status?: Maybe<ResultStatus>
}

export interface TestUpdateOneRequiredWithoutResultsInput {
   create?: Maybe<TestCreateWithoutResultsInput>
   update?: Maybe<TestUpdateWithoutResultsDataInput>
   upsert?: Maybe<TestUpsertWithoutResultsInput>
   connect?: Maybe<TestWhereUniqueInput>
}

export interface TestUpdateWithoutResultsDataInput {
   title?: Maybe<String>
   steps?: Maybe<StepUpdateManyInput>
   menus?: Maybe<MenuUpdateManyInput>
}

export interface StepUpdateManyInput {
   create?: Maybe<StepCreateInput[] | StepCreateInput>
   update?: Maybe<
      | StepUpdateWithWhereUniqueNestedInput[]
      | StepUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | StepUpsertWithWhereUniqueNestedInput[]
      | StepUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   set?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   disconnect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   deleteMany?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
   updateMany?: Maybe<
      StepUpdateManyWithWhereNestedInput[] | StepUpdateManyWithWhereNestedInput
   >
}

export interface StepUpdateWithWhereUniqueNestedInput {
   where: StepWhereUniqueInput
   data: StepUpdateDataInput
}

export interface StepUpdateDataInput {
   question?: Maybe<String>
   target?: Maybe<MenuUpdateOneRequiredInput>
   path?: Maybe<MenuUpdateManyInput>
   results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface StepUpsertWithWhereUniqueNestedInput {
   where: StepWhereUniqueInput
   update: StepUpdateDataInput
   create: StepCreateInput
}

export interface StepScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   question?: Maybe<String>
   question_not?: Maybe<String>
   question_in?: Maybe<String[] | String>
   question_not_in?: Maybe<String[] | String>
   question_lt?: Maybe<String>
   question_lte?: Maybe<String>
   question_gt?: Maybe<String>
   question_gte?: Maybe<String>
   question_contains?: Maybe<String>
   question_not_contains?: Maybe<String>
   question_starts_with?: Maybe<String>
   question_not_starts_with?: Maybe<String>
   question_ends_with?: Maybe<String>
   question_not_ends_with?: Maybe<String>
   AND?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
   OR?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
   NOT?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
}

export interface StepUpdateManyWithWhereNestedInput {
   where: StepScalarWhereInput
   data: StepUpdateManyDataInput
}

export interface StepUpdateManyDataInput {
   question?: Maybe<String>
}

export interface TestUpsertWithoutResultsInput {
   update: TestUpdateWithoutResultsDataInput
   create: TestCreateWithoutResultsInput
}

export interface TimeResultUpdateOneInput {
   create?: Maybe<TimeResultCreateInput>
   update?: Maybe<TimeResultUpdateDataInput>
   upsert?: Maybe<TimeResultUpsertNestedInput>
   delete?: Maybe<Boolean>
   disconnect?: Maybe<Boolean>
   connect?: Maybe<TimeResultWhereUniqueInput>
}

export interface TimeResultUpdateDataInput {
   int?: Maybe<Int>
   text?: Maybe<String>
}

export interface TimeResultUpsertNestedInput {
   update: TimeResultUpdateDataInput
   create: TimeResultCreateInput
}

export interface TestResultUpsertWithoutStepsInput {
   update: TestResultUpdateWithoutStepsDataInput
   create: TestResultCreateWithoutStepsInput
}

export interface StepResultUpsertWithWhereUniqueWithoutParentInput {
   where: StepResultWhereUniqueInput
   update: StepResultUpdateWithoutParentDataInput
   create: StepResultCreateWithoutParentInput
}

export interface StepResultScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   start?: Maybe<DateTimeInput>
   start_not?: Maybe<DateTimeInput>
   start_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_lt?: Maybe<DateTimeInput>
   start_lte?: Maybe<DateTimeInput>
   start_gt?: Maybe<DateTimeInput>
   start_gte?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   end_not?: Maybe<DateTimeInput>
   end_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_lt?: Maybe<DateTimeInput>
   end_lte?: Maybe<DateTimeInput>
   end_gt?: Maybe<DateTimeInput>
   end_gte?: Maybe<DateTimeInput>
   status?: Maybe<ResultStatus>
   status_not?: Maybe<ResultStatus>
   status_in?: Maybe<ResultStatus[] | ResultStatus>
   status_not_in?: Maybe<ResultStatus[] | ResultStatus>
   AND?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
   OR?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
   NOT?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
}

export interface StepResultUpdateManyWithWhereNestedInput {
   where: StepResultScalarWhereInput
   data: StepResultUpdateManyDataInput
}

export interface StepResultUpdateManyDataInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   status?: Maybe<ResultStatus>
}

export interface StepUpdateManyMutationInput {
   question?: Maybe<String>
}

export interface StepResultCreateInput {
   id?: Maybe<ID_Input>
   parent: StepCreateOneWithoutResultsInput
   resultParent: TestResultCreateOneWithoutStepsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   path?: Maybe<MenuCreateManyInput>
   status?: Maybe<ResultStatus>
}

export interface StepCreateOneWithoutResultsInput {
   create?: Maybe<StepCreateWithoutResultsInput>
   connect?: Maybe<StepWhereUniqueInput>
}

export interface StepCreateWithoutResultsInput {
   id?: Maybe<ID_Input>
   question: String
   target: MenuCreateOneInput
   path?: Maybe<MenuCreateManyInput>
}

export interface StepResultUpdateInput {
   parent?: Maybe<StepUpdateOneRequiredWithoutResultsInput>
   resultParent?: Maybe<TestResultUpdateOneRequiredWithoutStepsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   path?: Maybe<MenuUpdateManyInput>
   status?: Maybe<ResultStatus>
}

export interface StepUpdateOneRequiredWithoutResultsInput {
   create?: Maybe<StepCreateWithoutResultsInput>
   update?: Maybe<StepUpdateWithoutResultsDataInput>
   upsert?: Maybe<StepUpsertWithoutResultsInput>
   connect?: Maybe<StepWhereUniqueInput>
}

export interface StepUpdateWithoutResultsDataInput {
   question?: Maybe<String>
   target?: Maybe<MenuUpdateOneRequiredInput>
   path?: Maybe<MenuUpdateManyInput>
}

export interface StepUpsertWithoutResultsInput {
   update: StepUpdateWithoutResultsDataInput
   create: StepCreateWithoutResultsInput
}

export interface StepResultUpdateManyMutationInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   status?: Maybe<ResultStatus>
}

export interface TestCreateInput {
   id?: Maybe<ID_Input>
   title: String
   steps?: Maybe<StepCreateManyInput>
   menus?: Maybe<MenuCreateManyInput>
   results?: Maybe<TestResultCreateManyWithoutParentInput>
}

export interface TestResultCreateManyWithoutParentInput {
   create?: Maybe<
      TestResultCreateWithoutParentInput[] | TestResultCreateWithoutParentInput
   >
   connect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
}

export interface TestResultCreateWithoutParentInput {
   id?: Maybe<ID_Input>
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   steps?: Maybe<StepResultCreateManyWithoutResultParentInput>
   status?: Maybe<ResultStatus>
}

export interface StepResultCreateManyWithoutResultParentInput {
   create?: Maybe<
      | StepResultCreateWithoutResultParentInput[]
      | StepResultCreateWithoutResultParentInput
   >
   connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
}

export interface StepResultCreateWithoutResultParentInput {
   id?: Maybe<ID_Input>
   parent: StepCreateOneWithoutResultsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   path?: Maybe<MenuCreateManyInput>
   status?: Maybe<ResultStatus>
}

export interface TestUpdateInput {
   title?: Maybe<String>
   steps?: Maybe<StepUpdateManyInput>
   menus?: Maybe<MenuUpdateManyInput>
   results?: Maybe<TestResultUpdateManyWithoutParentInput>
}

export interface TestResultUpdateManyWithoutParentInput {
   create?: Maybe<
      TestResultCreateWithoutParentInput[] | TestResultCreateWithoutParentInput
   >
   delete?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   connect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   set?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   disconnect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   update?: Maybe<
      | TestResultUpdateWithWhereUniqueWithoutParentInput[]
      | TestResultUpdateWithWhereUniqueWithoutParentInput
   >
   upsert?: Maybe<
      | TestResultUpsertWithWhereUniqueWithoutParentInput[]
      | TestResultUpsertWithWhereUniqueWithoutParentInput
   >
   deleteMany?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
   updateMany?: Maybe<
      | TestResultUpdateManyWithWhereNestedInput[]
      | TestResultUpdateManyWithWhereNestedInput
   >
}

export interface TestResultUpdateWithWhereUniqueWithoutParentInput {
   where: TestResultWhereUniqueInput
   data: TestResultUpdateWithoutParentDataInput
}

export interface TestResultUpdateWithoutParentDataInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   steps?: Maybe<StepResultUpdateManyWithoutResultParentInput>
   status?: Maybe<ResultStatus>
}

export interface StepResultUpdateManyWithoutResultParentInput {
   create?: Maybe<
      | StepResultCreateWithoutResultParentInput[]
      | StepResultCreateWithoutResultParentInput
   >
   delete?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   set?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   disconnect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   update?: Maybe<
      | StepResultUpdateWithWhereUniqueWithoutResultParentInput[]
      | StepResultUpdateWithWhereUniqueWithoutResultParentInput
   >
   upsert?: Maybe<
      | StepResultUpsertWithWhereUniqueWithoutResultParentInput[]
      | StepResultUpsertWithWhereUniqueWithoutResultParentInput
   >
   deleteMany?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
   updateMany?: Maybe<
      | StepResultUpdateManyWithWhereNestedInput[]
      | StepResultUpdateManyWithWhereNestedInput
   >
}

export interface StepResultUpdateWithWhereUniqueWithoutResultParentInput {
   where: StepResultWhereUniqueInput
   data: StepResultUpdateWithoutResultParentDataInput
}

export interface StepResultUpdateWithoutResultParentDataInput {
   parent?: Maybe<StepUpdateOneRequiredWithoutResultsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   path?: Maybe<MenuUpdateManyInput>
   status?: Maybe<ResultStatus>
}

export interface StepResultUpsertWithWhereUniqueWithoutResultParentInput {
   where: StepResultWhereUniqueInput
   update: StepResultUpdateWithoutResultParentDataInput
   create: StepResultCreateWithoutResultParentInput
}

export interface TestResultUpsertWithWhereUniqueWithoutParentInput {
   where: TestResultWhereUniqueInput
   update: TestResultUpdateWithoutParentDataInput
   create: TestResultCreateWithoutParentInput
}

export interface TestResultScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   start?: Maybe<DateTimeInput>
   start_not?: Maybe<DateTimeInput>
   start_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_lt?: Maybe<DateTimeInput>
   start_lte?: Maybe<DateTimeInput>
   start_gt?: Maybe<DateTimeInput>
   start_gte?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   end_not?: Maybe<DateTimeInput>
   end_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_lt?: Maybe<DateTimeInput>
   end_lte?: Maybe<DateTimeInput>
   end_gt?: Maybe<DateTimeInput>
   end_gte?: Maybe<DateTimeInput>
   status?: Maybe<ResultStatus>
   status_not?: Maybe<ResultStatus>
   status_in?: Maybe<ResultStatus[] | ResultStatus>
   status_not_in?: Maybe<ResultStatus[] | ResultStatus>
   AND?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
   OR?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
   NOT?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
}

export interface TestResultUpdateManyWithWhereNestedInput {
   where: TestResultScalarWhereInput
   data: TestResultUpdateManyDataInput
}

export interface TestResultUpdateManyDataInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   status?: Maybe<ResultStatus>
}

export interface TestUpdateManyMutationInput {
   title?: Maybe<String>
}

export interface TestResultCreateInput {
   id?: Maybe<ID_Input>
   parent: TestCreateOneWithoutResultsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   steps?: Maybe<StepResultCreateManyWithoutResultParentInput>
   status?: Maybe<ResultStatus>
}

export interface TestResultUpdateInput {
   parent?: Maybe<TestUpdateOneRequiredWithoutResultsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   steps?: Maybe<StepResultUpdateManyWithoutResultParentInput>
   status?: Maybe<ResultStatus>
}

export interface TestResultUpdateManyMutationInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   status?: Maybe<ResultStatus>
}

export interface TimeResultUpdateInput {
   int?: Maybe<Int>
   text?: Maybe<String>
}

export interface TimeResultUpdateManyMutationInput {
   int?: Maybe<Int>
   text?: Maybe<String>
}

export interface ViewCreateInput {
   id?: Maybe<ID_Input>
   welcome: WelcomeCreateOneInput
   company: CompanyCreateOneInput
   menus?: Maybe<MenuCreateManyInput>
   tests?: Maybe<TestCreateManyInput>
   steps?: Maybe<StepCreateManyInput>
}

export interface WelcomeCreateOneInput {
   create?: Maybe<WelcomeCreateInput>
   connect?: Maybe<WelcomeWhereUniqueInput>
}

export interface WelcomeCreateInput {
   id?: Maybe<ID_Input>
   title: String
   message: String
}

export interface CompanyCreateOneInput {
   create?: Maybe<CompanyCreateInput>
   connect?: Maybe<CompanyWhereUniqueInput>
}

export interface TestCreateManyInput {
   create?: Maybe<TestCreateInput[] | TestCreateInput>
   connect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
}

export interface ViewUpdateInput {
   welcome?: Maybe<WelcomeUpdateOneRequiredInput>
   company?: Maybe<CompanyUpdateOneRequiredInput>
   menus?: Maybe<MenuUpdateManyInput>
   tests?: Maybe<TestUpdateManyInput>
   steps?: Maybe<StepUpdateManyInput>
}

export interface WelcomeUpdateOneRequiredInput {
   create?: Maybe<WelcomeCreateInput>
   update?: Maybe<WelcomeUpdateDataInput>
   upsert?: Maybe<WelcomeUpsertNestedInput>
   connect?: Maybe<WelcomeWhereUniqueInput>
}

export interface WelcomeUpdateDataInput {
   title?: Maybe<String>
   message?: Maybe<String>
}

export interface WelcomeUpsertNestedInput {
   update: WelcomeUpdateDataInput
   create: WelcomeCreateInput
}

export interface CompanyUpdateOneRequiredInput {
   create?: Maybe<CompanyCreateInput>
   update?: Maybe<CompanyUpdateDataInput>
   upsert?: Maybe<CompanyUpsertNestedInput>
   connect?: Maybe<CompanyWhereUniqueInput>
}

export interface CompanyUpdateDataInput {
   name?: Maybe<String>
   abbr?: Maybe<String>
   logo?: Maybe<String>
}

export interface CompanyUpsertNestedInput {
   update: CompanyUpdateDataInput
   create: CompanyCreateInput
}

export interface TestUpdateManyInput {
   create?: Maybe<TestCreateInput[] | TestCreateInput>
   update?: Maybe<
      | TestUpdateWithWhereUniqueNestedInput[]
      | TestUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | TestUpsertWithWhereUniqueNestedInput[]
      | TestUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
   connect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
   set?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
   disconnect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
   deleteMany?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
   updateMany?: Maybe<
      TestUpdateManyWithWhereNestedInput[] | TestUpdateManyWithWhereNestedInput
   >
}

export interface TestUpdateWithWhereUniqueNestedInput {
   where: TestWhereUniqueInput
   data: TestUpdateDataInput
}

export interface TestUpdateDataInput {
   title?: Maybe<String>
   steps?: Maybe<StepUpdateManyInput>
   menus?: Maybe<MenuUpdateManyInput>
   results?: Maybe<TestResultUpdateManyWithoutParentInput>
}

export interface TestUpsertWithWhereUniqueNestedInput {
   where: TestWhereUniqueInput
   update: TestUpdateDataInput
   create: TestCreateInput
}

export interface TestScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   AND?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
   OR?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
   NOT?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
}

export interface TestUpdateManyWithWhereNestedInput {
   where: TestScalarWhereInput
   data: TestUpdateManyDataInput
}

export interface TestUpdateManyDataInput {
   title?: Maybe<String>
}

export interface WelcomeUpdateInput {
   title?: Maybe<String>
   message?: Maybe<String>
}

export interface WelcomeUpdateManyMutationInput {
   title?: Maybe<String>
   message?: Maybe<String>
}

export interface CompanySubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<CompanyWhereInput>
   AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>
}

export interface MenuSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<MenuWhereInput>
   AND?: Maybe<MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput>
}

export interface StepSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<StepWhereInput>
   AND?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>
}

export interface StepResultSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<StepResultWhereInput>
   AND?: Maybe<
      StepResultSubscriptionWhereInput[] | StepResultSubscriptionWhereInput
   >
}

export interface TestSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<TestWhereInput>
   AND?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>
}

export interface TestResultSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<TestResultWhereInput>
   AND?: Maybe<
      TestResultSubscriptionWhereInput[] | TestResultSubscriptionWhereInput
   >
}

export interface TimeResultSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<TimeResultWhereInput>
   AND?: Maybe<
      TimeResultSubscriptionWhereInput[] | TimeResultSubscriptionWhereInput
   >
}

export interface ViewSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<ViewWhereInput>
   AND?: Maybe<ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput>
}

export interface WelcomeSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<WelcomeWhereInput>
   AND?: Maybe<WelcomeSubscriptionWhereInput[] | WelcomeSubscriptionWhereInput>
}

export interface NodeNode {
   id: ID_Output
}

export interface Company {
   id: ID_Output
   name: String
   abbr?: String
   logo?: String
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
   id: () => Promise<ID_Output>
   name: () => Promise<String>
   abbr: () => Promise<String>
   logo: () => Promise<String>
}

export interface CompanySubscription
   extends Promise<AsyncIterator<Company>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   name: () => Promise<AsyncIterator<String>>
   abbr: () => Promise<AsyncIterator<String>>
   logo: () => Promise<AsyncIterator<String>>
}

export interface CompanyNullablePromise
   extends Promise<Company | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   name: () => Promise<String>
   abbr: () => Promise<String>
   logo: () => Promise<String>
}

export interface CompanyConnection {
   pageInfo: PageInfo
   edges: CompanyEdge[]
}

export interface CompanyConnectionPromise
   extends Promise<CompanyConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<CompanyEdge>>() => T
   aggregate: <T = AggregateCompanyPromise>() => T
}

export interface CompanyConnectionSubscription
   extends Promise<AsyncIterator<CompanyConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T
   aggregate: <T = AggregateCompanySubscription>() => T
}

export interface PageInfo {
   hasNextPage: Boolean
   hasPreviousPage: Boolean
   startCursor?: String
   endCursor?: String
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
   hasNextPage: () => Promise<Boolean>
   hasPreviousPage: () => Promise<Boolean>
   startCursor: () => Promise<String>
   endCursor: () => Promise<String>
}

export interface PageInfoSubscription
   extends Promise<AsyncIterator<PageInfo>>,
      Fragmentable {
   hasNextPage: () => Promise<AsyncIterator<Boolean>>
   hasPreviousPage: () => Promise<AsyncIterator<Boolean>>
   startCursor: () => Promise<AsyncIterator<String>>
   endCursor: () => Promise<AsyncIterator<String>>
}

export interface CompanyEdge {
   node: Company
   cursor: String
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
   node: <T = CompanyPromise>() => T
   cursor: () => Promise<String>
}

export interface CompanyEdgeSubscription
   extends Promise<AsyncIterator<CompanyEdge>>,
      Fragmentable {
   node: <T = CompanySubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateCompany {
   count: Int
}

export interface AggregateCompanyPromise
   extends Promise<AggregateCompany>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateCompanySubscription
   extends Promise<AsyncIterator<AggregateCompany>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface Menu {
   id: ID_Output
   name: String
}

export interface MenuPromise extends Promise<Menu>, Fragmentable {
   id: () => Promise<ID_Output>
   menu: <T = MenuPromise>() => T
   name: () => Promise<String>
   items: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface MenuSubscription
   extends Promise<AsyncIterator<Menu>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   menu: <T = MenuSubscription>() => T
   name: () => Promise<AsyncIterator<String>>
   items: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface MenuNullablePromise
   extends Promise<Menu | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   menu: <T = MenuPromise>() => T
   name: () => Promise<String>
   items: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface MenuConnection {
   pageInfo: PageInfo
   edges: MenuEdge[]
}

export interface MenuConnectionPromise
   extends Promise<MenuConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<MenuEdge>>() => T
   aggregate: <T = AggregateMenuPromise>() => T
}

export interface MenuConnectionSubscription
   extends Promise<AsyncIterator<MenuConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<MenuEdgeSubscription>>>() => T
   aggregate: <T = AggregateMenuSubscription>() => T
}

export interface MenuEdge {
   node: Menu
   cursor: String
}

export interface MenuEdgePromise extends Promise<MenuEdge>, Fragmentable {
   node: <T = MenuPromise>() => T
   cursor: () => Promise<String>
}

export interface MenuEdgeSubscription
   extends Promise<AsyncIterator<MenuEdge>>,
      Fragmentable {
   node: <T = MenuSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateMenu {
   count: Int
}

export interface AggregateMenuPromise
   extends Promise<AggregateMenu>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateMenuSubscription
   extends Promise<AsyncIterator<AggregateMenu>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface Step {
   id: ID_Output
   question: String
}

export interface StepPromise extends Promise<Step>, Fragmentable {
   id: () => Promise<ID_Output>
   question: () => Promise<String>
   target: <T = MenuPromise>() => T
   path: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = FragmentableArray<StepResult>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface StepSubscription
   extends Promise<AsyncIterator<Step>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   question: () => Promise<AsyncIterator<String>>
   target: <T = MenuSubscription>() => T
   path: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = Promise<AsyncIterator<StepResultSubscription>>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface StepNullablePromise
   extends Promise<Step | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   question: () => Promise<String>
   target: <T = MenuPromise>() => T
   path: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = FragmentableArray<StepResult>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface StepResult {
   id: ID_Output
   start: DateTimeOutput
   end?: DateTimeOutput
   status: ResultStatus
}

export interface StepResultPromise extends Promise<StepResult>, Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = StepPromise>() => T
   resultParent: <T = TestResultPromise>() => T
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   time: <T = TimeResultPromise>() => T
   path: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: () => Promise<ResultStatus>
}

export interface StepResultSubscription
   extends Promise<AsyncIterator<StepResult>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   parent: <T = StepSubscription>() => T
   resultParent: <T = TestResultSubscription>() => T
   start: () => Promise<AsyncIterator<DateTimeOutput>>
   end: () => Promise<AsyncIterator<DateTimeOutput>>
   time: <T = TimeResultSubscription>() => T
   path: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: () => Promise<AsyncIterator<ResultStatus>>
}

export interface StepResultNullablePromise
   extends Promise<StepResult | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = StepPromise>() => T
   resultParent: <T = TestResultPromise>() => T
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   time: <T = TimeResultPromise>() => T
   path: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: () => Promise<ResultStatus>
}

export interface TestResult {
   id: ID_Output
   start: DateTimeOutput
   end?: DateTimeOutput
   status: ResultStatus
}

export interface TestResultPromise extends Promise<TestResult>, Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = TestPromise>() => T
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   time: <T = TimeResultPromise>() => T
   steps: <T = FragmentableArray<StepResult>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: () => Promise<ResultStatus>
}

export interface TestResultSubscription
   extends Promise<AsyncIterator<TestResult>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   parent: <T = TestSubscription>() => T
   start: () => Promise<AsyncIterator<DateTimeOutput>>
   end: () => Promise<AsyncIterator<DateTimeOutput>>
   time: <T = TimeResultSubscription>() => T
   steps: <T = Promise<AsyncIterator<StepResultSubscription>>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: () => Promise<AsyncIterator<ResultStatus>>
}

export interface TestResultNullablePromise
   extends Promise<TestResult | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = TestPromise>() => T
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   time: <T = TimeResultPromise>() => T
   steps: <T = FragmentableArray<StepResult>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: () => Promise<ResultStatus>
}

export interface Test {
   id: ID_Output
   title: String
}

export interface TestPromise extends Promise<Test>, Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = FragmentableArray<TestResult>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface TestSubscription
   extends Promise<AsyncIterator<Test>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   title: () => Promise<AsyncIterator<String>>
   steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = Promise<AsyncIterator<TestResultSubscription>>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface TestNullablePromise
   extends Promise<Test | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = FragmentableArray<TestResult>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface TimeResult {
   id: ID_Output
   int: Int
   text: String
}

export interface TimeResultPromise extends Promise<TimeResult>, Fragmentable {
   id: () => Promise<ID_Output>
   int: () => Promise<Int>
   text: () => Promise<String>
}

export interface TimeResultSubscription
   extends Promise<AsyncIterator<TimeResult>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   int: () => Promise<AsyncIterator<Int>>
   text: () => Promise<AsyncIterator<String>>
}

export interface TimeResultNullablePromise
   extends Promise<TimeResult | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   int: () => Promise<Int>
   text: () => Promise<String>
}

export interface StepConnection {
   pageInfo: PageInfo
   edges: StepEdge[]
}

export interface StepConnectionPromise
   extends Promise<StepConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<StepEdge>>() => T
   aggregate: <T = AggregateStepPromise>() => T
}

export interface StepConnectionSubscription
   extends Promise<AsyncIterator<StepConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<StepEdgeSubscription>>>() => T
   aggregate: <T = AggregateStepSubscription>() => T
}

export interface StepEdge {
   node: Step
   cursor: String
}

export interface StepEdgePromise extends Promise<StepEdge>, Fragmentable {
   node: <T = StepPromise>() => T
   cursor: () => Promise<String>
}

export interface StepEdgeSubscription
   extends Promise<AsyncIterator<StepEdge>>,
      Fragmentable {
   node: <T = StepSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateStep {
   count: Int
}

export interface AggregateStepPromise
   extends Promise<AggregateStep>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateStepSubscription
   extends Promise<AsyncIterator<AggregateStep>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface StepResultConnection {
   pageInfo: PageInfo
   edges: StepResultEdge[]
}

export interface StepResultConnectionPromise
   extends Promise<StepResultConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<StepResultEdge>>() => T
   aggregate: <T = AggregateStepResultPromise>() => T
}

export interface StepResultConnectionSubscription
   extends Promise<AsyncIterator<StepResultConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<StepResultEdgeSubscription>>>() => T
   aggregate: <T = AggregateStepResultSubscription>() => T
}

export interface StepResultEdge {
   node: StepResult
   cursor: String
}

export interface StepResultEdgePromise
   extends Promise<StepResultEdge>,
      Fragmentable {
   node: <T = StepResultPromise>() => T
   cursor: () => Promise<String>
}

export interface StepResultEdgeSubscription
   extends Promise<AsyncIterator<StepResultEdge>>,
      Fragmentable {
   node: <T = StepResultSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateStepResult {
   count: Int
}

export interface AggregateStepResultPromise
   extends Promise<AggregateStepResult>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateStepResultSubscription
   extends Promise<AsyncIterator<AggregateStepResult>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface TestConnection {
   pageInfo: PageInfo
   edges: TestEdge[]
}

export interface TestConnectionPromise
   extends Promise<TestConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<TestEdge>>() => T
   aggregate: <T = AggregateTestPromise>() => T
}

export interface TestConnectionSubscription
   extends Promise<AsyncIterator<TestConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<TestEdgeSubscription>>>() => T
   aggregate: <T = AggregateTestSubscription>() => T
}

export interface TestEdge {
   node: Test
   cursor: String
}

export interface TestEdgePromise extends Promise<TestEdge>, Fragmentable {
   node: <T = TestPromise>() => T
   cursor: () => Promise<String>
}

export interface TestEdgeSubscription
   extends Promise<AsyncIterator<TestEdge>>,
      Fragmentable {
   node: <T = TestSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTest {
   count: Int
}

export interface AggregateTestPromise
   extends Promise<AggregateTest>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateTestSubscription
   extends Promise<AsyncIterator<AggregateTest>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface TestResultConnection {
   pageInfo: PageInfo
   edges: TestResultEdge[]
}

export interface TestResultConnectionPromise
   extends Promise<TestResultConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<TestResultEdge>>() => T
   aggregate: <T = AggregateTestResultPromise>() => T
}

export interface TestResultConnectionSubscription
   extends Promise<AsyncIterator<TestResultConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<TestResultEdgeSubscription>>>() => T
   aggregate: <T = AggregateTestResultSubscription>() => T
}

export interface TestResultEdge {
   node: TestResult
   cursor: String
}

export interface TestResultEdgePromise
   extends Promise<TestResultEdge>,
      Fragmentable {
   node: <T = TestResultPromise>() => T
   cursor: () => Promise<String>
}

export interface TestResultEdgeSubscription
   extends Promise<AsyncIterator<TestResultEdge>>,
      Fragmentable {
   node: <T = TestResultSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTestResult {
   count: Int
}

export interface AggregateTestResultPromise
   extends Promise<AggregateTestResult>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateTestResultSubscription
   extends Promise<AsyncIterator<AggregateTestResult>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface TimeResultConnection {
   pageInfo: PageInfo
   edges: TimeResultEdge[]
}

export interface TimeResultConnectionPromise
   extends Promise<TimeResultConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<TimeResultEdge>>() => T
   aggregate: <T = AggregateTimeResultPromise>() => T
}

export interface TimeResultConnectionSubscription
   extends Promise<AsyncIterator<TimeResultConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<TimeResultEdgeSubscription>>>() => T
   aggregate: <T = AggregateTimeResultSubscription>() => T
}

export interface TimeResultEdge {
   node: TimeResult
   cursor: String
}

export interface TimeResultEdgePromise
   extends Promise<TimeResultEdge>,
      Fragmentable {
   node: <T = TimeResultPromise>() => T
   cursor: () => Promise<String>
}

export interface TimeResultEdgeSubscription
   extends Promise<AsyncIterator<TimeResultEdge>>,
      Fragmentable {
   node: <T = TimeResultSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTimeResult {
   count: Int
}

export interface AggregateTimeResultPromise
   extends Promise<AggregateTimeResult>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateTimeResultSubscription
   extends Promise<AsyncIterator<AggregateTimeResult>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface View {
   id: ID_Output
}

export interface ViewPromise extends Promise<View>, Fragmentable {
   id: () => Promise<ID_Output>
   welcome: <T = WelcomePromise>() => T
   company: <T = CompanyPromise>() => T
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   tests: <T = FragmentableArray<Test>>(args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface ViewSubscription
   extends Promise<AsyncIterator<View>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   welcome: <T = WelcomeSubscription>() => T
   company: <T = CompanySubscription>() => T
   menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   tests: <T = Promise<AsyncIterator<TestSubscription>>>(args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface ViewNullablePromise
   extends Promise<View | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   welcome: <T = WelcomePromise>() => T
   company: <T = CompanyPromise>() => T
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   tests: <T = FragmentableArray<Test>>(args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface Welcome {
   id: ID_Output
   title: String
   message: String
}

export interface WelcomePromise extends Promise<Welcome>, Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   message: () => Promise<String>
}

export interface WelcomeSubscription
   extends Promise<AsyncIterator<Welcome>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   title: () => Promise<AsyncIterator<String>>
   message: () => Promise<AsyncIterator<String>>
}

export interface WelcomeNullablePromise
   extends Promise<Welcome | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   message: () => Promise<String>
}

export interface ViewConnection {
   pageInfo: PageInfo
   edges: ViewEdge[]
}

export interface ViewConnectionPromise
   extends Promise<ViewConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<ViewEdge>>() => T
   aggregate: <T = AggregateViewPromise>() => T
}

export interface ViewConnectionSubscription
   extends Promise<AsyncIterator<ViewConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<ViewEdgeSubscription>>>() => T
   aggregate: <T = AggregateViewSubscription>() => T
}

export interface ViewEdge {
   node: View
   cursor: String
}

export interface ViewEdgePromise extends Promise<ViewEdge>, Fragmentable {
   node: <T = ViewPromise>() => T
   cursor: () => Promise<String>
}

export interface ViewEdgeSubscription
   extends Promise<AsyncIterator<ViewEdge>>,
      Fragmentable {
   node: <T = ViewSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateView {
   count: Int
}

export interface AggregateViewPromise
   extends Promise<AggregateView>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateViewSubscription
   extends Promise<AsyncIterator<AggregateView>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface WelcomeConnection {
   pageInfo: PageInfo
   edges: WelcomeEdge[]
}

export interface WelcomeConnectionPromise
   extends Promise<WelcomeConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<WelcomeEdge>>() => T
   aggregate: <T = AggregateWelcomePromise>() => T
}

export interface WelcomeConnectionSubscription
   extends Promise<AsyncIterator<WelcomeConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<WelcomeEdgeSubscription>>>() => T
   aggregate: <T = AggregateWelcomeSubscription>() => T
}

export interface WelcomeEdge {
   node: Welcome
   cursor: String
}

export interface WelcomeEdgePromise extends Promise<WelcomeEdge>, Fragmentable {
   node: <T = WelcomePromise>() => T
   cursor: () => Promise<String>
}

export interface WelcomeEdgeSubscription
   extends Promise<AsyncIterator<WelcomeEdge>>,
      Fragmentable {
   node: <T = WelcomeSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateWelcome {
   count: Int
}

export interface AggregateWelcomePromise
   extends Promise<AggregateWelcome>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateWelcomeSubscription
   extends Promise<AsyncIterator<AggregateWelcome>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface BatchPayload {
   count: Long
}

export interface BatchPayloadPromise
   extends Promise<BatchPayload>,
      Fragmentable {
   count: () => Promise<Long>
}

export interface BatchPayloadSubscription
   extends Promise<AsyncIterator<BatchPayload>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Long>>
}

export interface CompanySubscriptionPayload {
   mutation: MutationType
   node: Company
   updatedFields: String[]
   previousValues: CompanyPreviousValues
}

export interface CompanySubscriptionPayloadPromise
   extends Promise<CompanySubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = CompanyPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = CompanyPreviousValuesPromise>() => T
}

export interface CompanySubscriptionPayloadSubscription
   extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = CompanySubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = CompanyPreviousValuesSubscription>() => T
}

export interface CompanyPreviousValues {
   id: ID_Output
   name: String
   abbr?: String
   logo?: String
}

export interface CompanyPreviousValuesPromise
   extends Promise<CompanyPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   name: () => Promise<String>
   abbr: () => Promise<String>
   logo: () => Promise<String>
}

export interface CompanyPreviousValuesSubscription
   extends Promise<AsyncIterator<CompanyPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   name: () => Promise<AsyncIterator<String>>
   abbr: () => Promise<AsyncIterator<String>>
   logo: () => Promise<AsyncIterator<String>>
}

export interface MenuSubscriptionPayload {
   mutation: MutationType
   node: Menu
   updatedFields: String[]
   previousValues: MenuPreviousValues
}

export interface MenuSubscriptionPayloadPromise
   extends Promise<MenuSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = MenuPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = MenuPreviousValuesPromise>() => T
}

export interface MenuSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<MenuSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = MenuSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = MenuPreviousValuesSubscription>() => T
}

export interface MenuPreviousValues {
   id: ID_Output
   name: String
}

export interface MenuPreviousValuesPromise
   extends Promise<MenuPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   name: () => Promise<String>
}

export interface MenuPreviousValuesSubscription
   extends Promise<AsyncIterator<MenuPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   name: () => Promise<AsyncIterator<String>>
}

export interface StepSubscriptionPayload {
   mutation: MutationType
   node: Step
   updatedFields: String[]
   previousValues: StepPreviousValues
}

export interface StepSubscriptionPayloadPromise
   extends Promise<StepSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = StepPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = StepPreviousValuesPromise>() => T
}

export interface StepSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<StepSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = StepSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = StepPreviousValuesSubscription>() => T
}

export interface StepPreviousValues {
   id: ID_Output
   question: String
}

export interface StepPreviousValuesPromise
   extends Promise<StepPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   question: () => Promise<String>
}

export interface StepPreviousValuesSubscription
   extends Promise<AsyncIterator<StepPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   question: () => Promise<AsyncIterator<String>>
}

export interface StepResultSubscriptionPayload {
   mutation: MutationType
   node: StepResult
   updatedFields: String[]
   previousValues: StepResultPreviousValues
}

export interface StepResultSubscriptionPayloadPromise
   extends Promise<StepResultSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = StepResultPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = StepResultPreviousValuesPromise>() => T
}

export interface StepResultSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<StepResultSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = StepResultSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = StepResultPreviousValuesSubscription>() => T
}

export interface StepResultPreviousValues {
   id: ID_Output
   start: DateTimeOutput
   end?: DateTimeOutput
   status: ResultStatus
}

export interface StepResultPreviousValuesPromise
   extends Promise<StepResultPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   status: () => Promise<ResultStatus>
}

export interface StepResultPreviousValuesSubscription
   extends Promise<AsyncIterator<StepResultPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   start: () => Promise<AsyncIterator<DateTimeOutput>>
   end: () => Promise<AsyncIterator<DateTimeOutput>>
   status: () => Promise<AsyncIterator<ResultStatus>>
}

export interface TestSubscriptionPayload {
   mutation: MutationType
   node: Test
   updatedFields: String[]
   previousValues: TestPreviousValues
}

export interface TestSubscriptionPayloadPromise
   extends Promise<TestSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = TestPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = TestPreviousValuesPromise>() => T
}

export interface TestSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<TestSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = TestSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = TestPreviousValuesSubscription>() => T
}

export interface TestPreviousValues {
   id: ID_Output
   title: String
}

export interface TestPreviousValuesPromise
   extends Promise<TestPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
}

export interface TestPreviousValuesSubscription
   extends Promise<AsyncIterator<TestPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   title: () => Promise<AsyncIterator<String>>
}

export interface TestResultSubscriptionPayload {
   mutation: MutationType
   node: TestResult
   updatedFields: String[]
   previousValues: TestResultPreviousValues
}

export interface TestResultSubscriptionPayloadPromise
   extends Promise<TestResultSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = TestResultPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = TestResultPreviousValuesPromise>() => T
}

export interface TestResultSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<TestResultSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = TestResultSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = TestResultPreviousValuesSubscription>() => T
}

export interface TestResultPreviousValues {
   id: ID_Output
   start: DateTimeOutput
   end?: DateTimeOutput
   status: ResultStatus
}

export interface TestResultPreviousValuesPromise
   extends Promise<TestResultPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   status: () => Promise<ResultStatus>
}

export interface TestResultPreviousValuesSubscription
   extends Promise<AsyncIterator<TestResultPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   start: () => Promise<AsyncIterator<DateTimeOutput>>
   end: () => Promise<AsyncIterator<DateTimeOutput>>
   status: () => Promise<AsyncIterator<ResultStatus>>
}

export interface TimeResultSubscriptionPayload {
   mutation: MutationType
   node: TimeResult
   updatedFields: String[]
   previousValues: TimeResultPreviousValues
}

export interface TimeResultSubscriptionPayloadPromise
   extends Promise<TimeResultSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = TimeResultPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = TimeResultPreviousValuesPromise>() => T
}

export interface TimeResultSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<TimeResultSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = TimeResultSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = TimeResultPreviousValuesSubscription>() => T
}

export interface TimeResultPreviousValues {
   id: ID_Output
   int: Int
   text: String
}

export interface TimeResultPreviousValuesPromise
   extends Promise<TimeResultPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   int: () => Promise<Int>
   text: () => Promise<String>
}

export interface TimeResultPreviousValuesSubscription
   extends Promise<AsyncIterator<TimeResultPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   int: () => Promise<AsyncIterator<Int>>
   text: () => Promise<AsyncIterator<String>>
}

export interface ViewSubscriptionPayload {
   mutation: MutationType
   node: View
   updatedFields: String[]
   previousValues: ViewPreviousValues
}

export interface ViewSubscriptionPayloadPromise
   extends Promise<ViewSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = ViewPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = ViewPreviousValuesPromise>() => T
}

export interface ViewSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<ViewSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = ViewSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = ViewPreviousValuesSubscription>() => T
}

export interface ViewPreviousValues {
   id: ID_Output
}

export interface ViewPreviousValuesPromise
   extends Promise<ViewPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
}

export interface ViewPreviousValuesSubscription
   extends Promise<AsyncIterator<ViewPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
}

export interface WelcomeSubscriptionPayload {
   mutation: MutationType
   node: Welcome
   updatedFields: String[]
   previousValues: WelcomePreviousValues
}

export interface WelcomeSubscriptionPayloadPromise
   extends Promise<WelcomeSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = WelcomePromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = WelcomePreviousValuesPromise>() => T
}

export interface WelcomeSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<WelcomeSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = WelcomeSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = WelcomePreviousValuesSubscription>() => T
}

export interface WelcomePreviousValues {
   id: ID_Output
   title: String
   message: String
}

export interface WelcomePreviousValuesPromise
   extends Promise<WelcomePreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   message: () => Promise<String>
}

export interface WelcomePreviousValuesSubscription
   extends Promise<AsyncIterator<WelcomePreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   title: () => Promise<AsyncIterator<String>>
   message: () => Promise<AsyncIterator<String>>
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number
export type ID_Output = string

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string

export type Long = string

/**
 * Model Metadata
 */

export const models: Model[] = [
   {
      name: 'View',
      embedded: false,
   },
   {
      name: 'Welcome',
      embedded: false,
   },
   {
      name: 'Company',
      embedded: false,
   },
   {
      name: 'Test',
      embedded: false,
   },
   {
      name: 'Menu',
      embedded: false,
   },
   {
      name: 'Step',
      embedded: false,
   },
   {
      name: 'ResultStatus',
      embedded: false,
   },
   {
      name: 'TestResult',
      embedded: false,
   },
   {
      name: 'TimeResult',
      embedded: false,
   },
   {
      name: 'StepResult',
      embedded: false,
   },
]

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
   typeDefs,
   models,
   endpoint: `http://localhost:4466`,
})
export const prisma = new Prisma()
