// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql'
import {
   makePrismaClientClass,
   BaseClientOptions,
   Model,
} from 'prisma-client-lib'
import { typeDefs } from './prisma-schema'

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
   U[keyof U]

export type Maybe<T> = T | undefined | null

export interface Exists {
   company: (where?: CompanyWhereInput) => Promise<boolean>
   keyResultStatus: (where?: KeyResultStatusWhereInput) => Promise<boolean>
   keyUserType: (where?: KeyUserTypeWhereInput) => Promise<boolean>
   keys: (where?: KeysWhereInput) => Promise<boolean>
   menu: (where?: MenuWhereInput) => Promise<boolean>
   path: (where?: PathWhereInput) => Promise<boolean>
   step: (where?: StepWhereInput) => Promise<boolean>
   stepResult: (where?: StepResultWhereInput) => Promise<boolean>
   test: (where?: TestWhereInput) => Promise<boolean>
   testResult: (where?: TestResultWhereInput) => Promise<boolean>
   timeResult: (where?: TimeResultWhereInput) => Promise<boolean>
   view: (where?: ViewWhereInput) => Promise<boolean>
   welcome: (where?: WelcomeWhereInput) => Promise<boolean>
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

export interface Fragmentable {
   $fragment<T>(fragment: string | DocumentNode): Promise<T>
}

export interface Prisma {
   $exists: Exists
   $graphql: <T = any>(
      query: string,
      variables?: { [key: string]: any },
   ) => Promise<T>

   /**
    * Queries
    */

   company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise
   companies: (args?: {
      where?: CompanyWhereInput
      orderBy?: CompanyOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Company>
   companiesConnection: (args?: {
      where?: CompanyWhereInput
      orderBy?: CompanyOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => CompanyConnectionPromise
   keyResultStatus: (
      where: KeyResultStatusWhereUniqueInput,
   ) => KeyResultStatusNullablePromise
   keyResultStatuses: (args?: {
      where?: KeyResultStatusWhereInput
      orderBy?: KeyResultStatusOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<KeyResultStatus>
   keyResultStatusesConnection: (args?: {
      where?: KeyResultStatusWhereInput
      orderBy?: KeyResultStatusOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => KeyResultStatusConnectionPromise
   keyUserType: (
      where: KeyUserTypeWhereUniqueInput,
   ) => KeyUserTypeNullablePromise
   keyUserTypes: (args?: {
      where?: KeyUserTypeWhereInput
      orderBy?: KeyUserTypeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<KeyUserType>
   keyUserTypesConnection: (args?: {
      where?: KeyUserTypeWhereInput
      orderBy?: KeyUserTypeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => KeyUserTypeConnectionPromise
   keys: (where: KeysWhereUniqueInput) => KeysNullablePromise
   keyses: (args?: {
      where?: KeysWhereInput
      orderBy?: KeysOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Keys>
   keysesConnection: (args?: {
      where?: KeysWhereInput
      orderBy?: KeysOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => KeysConnectionPromise
   menu: (where: MenuWhereUniqueInput) => MenuNullablePromise
   menus: (args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Menu>
   menusConnection: (args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => MenuConnectionPromise
   path: (where: PathWhereUniqueInput) => PathNullablePromise
   paths: (args?: {
      where?: PathWhereInput
      orderBy?: PathOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Path>
   pathsConnection: (args?: {
      where?: PathWhereInput
      orderBy?: PathOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => PathConnectionPromise
   step: (where: StepWhereUniqueInput) => StepNullablePromise
   steps: (args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Step>
   stepsConnection: (args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => StepConnectionPromise
   stepResult: (where: StepResultWhereUniqueInput) => StepResultNullablePromise
   stepResults: (args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<StepResult>
   stepResultsConnection: (args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => StepResultConnectionPromise
   test: (where: TestWhereUniqueInput) => TestNullablePromise
   tests: (args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Test>
   testsConnection: (args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => TestConnectionPromise
   testResult: (where: TestResultWhereUniqueInput) => TestResultNullablePromise
   testResults: (args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<TestResult>
   testResultsConnection: (args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => TestResultConnectionPromise
   timeResult: (where: TimeResultWhereUniqueInput) => TimeResultNullablePromise
   timeResults: (args?: {
      where?: TimeResultWhereInput
      orderBy?: TimeResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<TimeResult>
   timeResultsConnection: (args?: {
      where?: TimeResultWhereInput
      orderBy?: TimeResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => TimeResultConnectionPromise
   view: (where: ViewWhereUniqueInput) => ViewNullablePromise
   views: (args?: {
      where?: ViewWhereInput
      orderBy?: ViewOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<View>
   viewsConnection: (args?: {
      where?: ViewWhereInput
      orderBy?: ViewOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => ViewConnectionPromise
   welcome: (where: WelcomeWhereUniqueInput) => WelcomeNullablePromise
   welcomes: (args?: {
      where?: WelcomeWhereInput
      orderBy?: WelcomeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Welcome>
   welcomesConnection: (args?: {
      where?: WelcomeWhereInput
      orderBy?: WelcomeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => WelcomeConnectionPromise
   node: (args: { id: ID_Output }) => Node

   /**
    * Mutations
    */

   createCompany: (data: CompanyCreateInput) => CompanyPromise
   updateCompany: (args: {
      data: CompanyUpdateInput
      where: CompanyWhereUniqueInput
   }) => CompanyPromise
   updateManyCompanies: (args: {
      data: CompanyUpdateManyMutationInput
      where?: CompanyWhereInput
   }) => BatchPayloadPromise
   upsertCompany: (args: {
      where: CompanyWhereUniqueInput
      create: CompanyCreateInput
      update: CompanyUpdateInput
   }) => CompanyPromise
   deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise
   deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise
   createKeyResultStatus: (
      data: KeyResultStatusCreateInput,
   ) => KeyResultStatusPromise
   updateKeyResultStatus: (args: {
      data: KeyResultStatusUpdateInput
      where: KeyResultStatusWhereUniqueInput
   }) => KeyResultStatusPromise
   updateManyKeyResultStatuses: (args: {
      data: KeyResultStatusUpdateManyMutationInput
      where?: KeyResultStatusWhereInput
   }) => BatchPayloadPromise
   upsertKeyResultStatus: (args: {
      where: KeyResultStatusWhereUniqueInput
      create: KeyResultStatusCreateInput
      update: KeyResultStatusUpdateInput
   }) => KeyResultStatusPromise
   deleteKeyResultStatus: (
      where: KeyResultStatusWhereUniqueInput,
   ) => KeyResultStatusPromise
   deleteManyKeyResultStatuses: (
      where?: KeyResultStatusWhereInput,
   ) => BatchPayloadPromise
   createKeyUserType: (data: KeyUserTypeCreateInput) => KeyUserTypePromise
   updateKeyUserType: (args: {
      data: KeyUserTypeUpdateInput
      where: KeyUserTypeWhereUniqueInput
   }) => KeyUserTypePromise
   updateManyKeyUserTypes: (args: {
      data: KeyUserTypeUpdateManyMutationInput
      where?: KeyUserTypeWhereInput
   }) => BatchPayloadPromise
   upsertKeyUserType: (args: {
      where: KeyUserTypeWhereUniqueInput
      create: KeyUserTypeCreateInput
      update: KeyUserTypeUpdateInput
   }) => KeyUserTypePromise
   deleteKeyUserType: (where: KeyUserTypeWhereUniqueInput) => KeyUserTypePromise
   deleteManyKeyUserTypes: (
      where?: KeyUserTypeWhereInput,
   ) => BatchPayloadPromise
   createKeys: (data: KeysCreateInput) => KeysPromise
   updateKeys: (args: {
      data: KeysUpdateInput
      where: KeysWhereUniqueInput
   }) => KeysPromise
   upsertKeys: (args: {
      where: KeysWhereUniqueInput
      create: KeysCreateInput
      update: KeysUpdateInput
   }) => KeysPromise
   deleteKeys: (where: KeysWhereUniqueInput) => KeysPromise
   deleteManyKeyses: (where?: KeysWhereInput) => BatchPayloadPromise
   createMenu: (data: MenuCreateInput) => MenuPromise
   updateMenu: (args: {
      data: MenuUpdateInput
      where: MenuWhereUniqueInput
   }) => MenuPromise
   updateManyMenus: (args: {
      data: MenuUpdateManyMutationInput
      where?: MenuWhereInput
   }) => BatchPayloadPromise
   upsertMenu: (args: {
      where: MenuWhereUniqueInput
      create: MenuCreateInput
      update: MenuUpdateInput
   }) => MenuPromise
   deleteMenu: (where: MenuWhereUniqueInput) => MenuPromise
   deleteManyMenus: (where?: MenuWhereInput) => BatchPayloadPromise
   createPath: (data: PathCreateInput) => PathPromise
   updatePath: (args: {
      data: PathUpdateInput
      where: PathWhereUniqueInput
   }) => PathPromise
   upsertPath: (args: {
      where: PathWhereUniqueInput
      create: PathCreateInput
      update: PathUpdateInput
   }) => PathPromise
   deletePath: (where: PathWhereUniqueInput) => PathPromise
   deleteManyPaths: (where?: PathWhereInput) => BatchPayloadPromise
   createStep: (data: StepCreateInput) => StepPromise
   updateStep: (args: {
      data: StepUpdateInput
      where: StepWhereUniqueInput
   }) => StepPromise
   updateManySteps: (args: {
      data: StepUpdateManyMutationInput
      where?: StepWhereInput
   }) => BatchPayloadPromise
   upsertStep: (args: {
      where: StepWhereUniqueInput
      create: StepCreateInput
      update: StepUpdateInput
   }) => StepPromise
   deleteStep: (where: StepWhereUniqueInput) => StepPromise
   deleteManySteps: (where?: StepWhereInput) => BatchPayloadPromise
   createStepResult: (data: StepResultCreateInput) => StepResultPromise
   updateStepResult: (args: {
      data: StepResultUpdateInput
      where: StepResultWhereUniqueInput
   }) => StepResultPromise
   updateManyStepResults: (args: {
      data: StepResultUpdateManyMutationInput
      where?: StepResultWhereInput
   }) => BatchPayloadPromise
   upsertStepResult: (args: {
      where: StepResultWhereUniqueInput
      create: StepResultCreateInput
      update: StepResultUpdateInput
   }) => StepResultPromise
   deleteStepResult: (where: StepResultWhereUniqueInput) => StepResultPromise
   deleteManyStepResults: (where?: StepResultWhereInput) => BatchPayloadPromise
   createTest: (data: TestCreateInput) => TestPromise
   updateTest: (args: {
      data: TestUpdateInput
      where: TestWhereUniqueInput
   }) => TestPromise
   updateManyTests: (args: {
      data: TestUpdateManyMutationInput
      where?: TestWhereInput
   }) => BatchPayloadPromise
   upsertTest: (args: {
      where: TestWhereUniqueInput
      create: TestCreateInput
      update: TestUpdateInput
   }) => TestPromise
   deleteTest: (where: TestWhereUniqueInput) => TestPromise
   deleteManyTests: (where?: TestWhereInput) => BatchPayloadPromise
   createTestResult: (data: TestResultCreateInput) => TestResultPromise
   updateTestResult: (args: {
      data: TestResultUpdateInput
      where: TestResultWhereUniqueInput
   }) => TestResultPromise
   updateManyTestResults: (args: {
      data: TestResultUpdateManyMutationInput
      where?: TestResultWhereInput
   }) => BatchPayloadPromise
   upsertTestResult: (args: {
      where: TestResultWhereUniqueInput
      create: TestResultCreateInput
      update: TestResultUpdateInput
   }) => TestResultPromise
   deleteTestResult: (where: TestResultWhereUniqueInput) => TestResultPromise
   deleteManyTestResults: (where?: TestResultWhereInput) => BatchPayloadPromise
   createTimeResult: (data: TimeResultCreateInput) => TimeResultPromise
   updateTimeResult: (args: {
      data: TimeResultUpdateInput
      where: TimeResultWhereUniqueInput
   }) => TimeResultPromise
   updateManyTimeResults: (args: {
      data: TimeResultUpdateManyMutationInput
      where?: TimeResultWhereInput
   }) => BatchPayloadPromise
   upsertTimeResult: (args: {
      where: TimeResultWhereUniqueInput
      create: TimeResultCreateInput
      update: TimeResultUpdateInput
   }) => TimeResultPromise
   deleteTimeResult: (where: TimeResultWhereUniqueInput) => TimeResultPromise
   deleteManyTimeResults: (where?: TimeResultWhereInput) => BatchPayloadPromise
   createView: (data: ViewCreateInput) => ViewPromise
   updateView: (args: {
      data: ViewUpdateInput
      where: ViewWhereUniqueInput
   }) => ViewPromise
   upsertView: (args: {
      where: ViewWhereUniqueInput
      create: ViewCreateInput
      update: ViewUpdateInput
   }) => ViewPromise
   deleteView: (where: ViewWhereUniqueInput) => ViewPromise
   deleteManyViews: (where?: ViewWhereInput) => BatchPayloadPromise
   createWelcome: (data: WelcomeCreateInput) => WelcomePromise
   updateWelcome: (args: {
      data: WelcomeUpdateInput
      where: WelcomeWhereUniqueInput
   }) => WelcomePromise
   updateManyWelcomes: (args: {
      data: WelcomeUpdateManyMutationInput
      where?: WelcomeWhereInput
   }) => BatchPayloadPromise
   upsertWelcome: (args: {
      where: WelcomeWhereUniqueInput
      create: WelcomeCreateInput
      update: WelcomeUpdateInput
   }) => WelcomePromise
   deleteWelcome: (where: WelcomeWhereUniqueInput) => WelcomePromise
   deleteManyWelcomes: (where?: WelcomeWhereInput) => BatchPayloadPromise

   /**
    * Subscriptions
    */

   $subscribe: Subscription
}

export interface Subscription {
   company: (
      where?: CompanySubscriptionWhereInput,
   ) => CompanySubscriptionPayloadSubscription
   keyResultStatus: (
      where?: KeyResultStatusSubscriptionWhereInput,
   ) => KeyResultStatusSubscriptionPayloadSubscription
   keyUserType: (
      where?: KeyUserTypeSubscriptionWhereInput,
   ) => KeyUserTypeSubscriptionPayloadSubscription
   keys: (
      where?: KeysSubscriptionWhereInput,
   ) => KeysSubscriptionPayloadSubscription
   menu: (
      where?: MenuSubscriptionWhereInput,
   ) => MenuSubscriptionPayloadSubscription
   path: (
      where?: PathSubscriptionWhereInput,
   ) => PathSubscriptionPayloadSubscription
   step: (
      where?: StepSubscriptionWhereInput,
   ) => StepSubscriptionPayloadSubscription
   stepResult: (
      where?: StepResultSubscriptionWhereInput,
   ) => StepResultSubscriptionPayloadSubscription
   test: (
      where?: TestSubscriptionWhereInput,
   ) => TestSubscriptionPayloadSubscription
   testResult: (
      where?: TestResultSubscriptionWhereInput,
   ) => TestResultSubscriptionPayloadSubscription
   timeResult: (
      where?: TimeResultSubscriptionWhereInput,
   ) => TimeResultSubscriptionPayloadSubscription
   view: (
      where?: ViewSubscriptionWhereInput,
   ) => ViewSubscriptionPayloadSubscription
   welcome: (
      where?: WelcomeSubscriptionWhereInput,
   ) => WelcomeSubscriptionPayloadSubscription
}

export interface ClientConstructor<T> {
   new (options?: BaseClientOptions): T
}

/**
 * Types
 */

export type CompanyOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'name_ASC'
   | 'name_DESC'
   | 'abbr_ASC'
   | 'abbr_DESC'
   | 'logo_ASC'
   | 'logo_DESC'

export type TestResultOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'start_ASC'
   | 'start_DESC'
   | 'end_ASC'
   | 'end_DESC'

export type StepOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'question_ASC'
   | 'question_DESC'

export type KeyUserTypeOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'key_ASC'
   | 'key_DESC'

export type MenuOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'root_ASC'
   | 'root_DESC'
   | 'name_ASC'
   | 'name_DESC'

export type PathOrderByInput = 'id_ASC' | 'id_DESC'

export type StepResultOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'start_ASC'
   | 'start_DESC'
   | 'end_ASC'
   | 'end_DESC'

export type KeyResultStatusOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'key_ASC'
   | 'key_DESC'

export type KeysOrderByInput = 'id_ASC' | 'id_DESC'

export type TestOrderByInput = 'id_ASC' | 'id_DESC' | 'title_ASC' | 'title_DESC'

export type TimeResultOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'int_ASC'
   | 'int_DESC'
   | 'text_ASC'
   | 'text_DESC'

export type ViewOrderByInput = 'id_ASC' | 'id_DESC'

export type WelcomeOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'title_ASC'
   | 'title_DESC'
   | 'message_ASC'
   | 'message_DESC'

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED'

export type CompanyWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface CompanyWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   abbr?: Maybe<String>
   abbr_not?: Maybe<String>
   abbr_in?: Maybe<String[] | String>
   abbr_not_in?: Maybe<String[] | String>
   abbr_lt?: Maybe<String>
   abbr_lte?: Maybe<String>
   abbr_gt?: Maybe<String>
   abbr_gte?: Maybe<String>
   abbr_contains?: Maybe<String>
   abbr_not_contains?: Maybe<String>
   abbr_starts_with?: Maybe<String>
   abbr_not_starts_with?: Maybe<String>
   abbr_ends_with?: Maybe<String>
   abbr_not_ends_with?: Maybe<String>
   logo?: Maybe<String>
   logo_not?: Maybe<String>
   logo_in?: Maybe<String[] | String>
   logo_not_in?: Maybe<String[] | String>
   logo_lt?: Maybe<String>
   logo_lte?: Maybe<String>
   logo_gt?: Maybe<String>
   logo_gte?: Maybe<String>
   logo_contains?: Maybe<String>
   logo_not_contains?: Maybe<String>
   logo_starts_with?: Maybe<String>
   logo_not_starts_with?: Maybe<String>
   logo_ends_with?: Maybe<String>
   logo_not_ends_with?: Maybe<String>
   AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>
}

export type KeyResultStatusWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
   key?: Maybe<String>
}>

export interface TestResultWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   parent?: Maybe<TestWhereInput>
   start?: Maybe<DateTimeInput>
   start_not?: Maybe<DateTimeInput>
   start_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_lt?: Maybe<DateTimeInput>
   start_lte?: Maybe<DateTimeInput>
   start_gt?: Maybe<DateTimeInput>
   start_gte?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   end_not?: Maybe<DateTimeInput>
   end_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_lt?: Maybe<DateTimeInput>
   end_lte?: Maybe<DateTimeInput>
   end_gt?: Maybe<DateTimeInput>
   end_gte?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultWhereInput>
   steps_some?: Maybe<StepResultWhereInput>
   status?: Maybe<KeyResultStatusWhereInput>
   AND?: Maybe<TestResultWhereInput[] | TestResultWhereInput>
}

export interface TestWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   steps_some?: Maybe<StepWhereInput>
   menus_some?: Maybe<MenuWhereInput>
   results_some?: Maybe<TestResultWhereInput>
   AND?: Maybe<TestWhereInput[] | TestWhereInput>
}

export interface StepWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   parent?: Maybe<TestWhereInput>
   type_some?: Maybe<KeyUserTypeWhereInput>
   question?: Maybe<String>
   question_not?: Maybe<String>
   question_in?: Maybe<String[] | String>
   question_not_in?: Maybe<String[] | String>
   question_lt?: Maybe<String>
   question_lte?: Maybe<String>
   question_gt?: Maybe<String>
   question_gte?: Maybe<String>
   question_contains?: Maybe<String>
   question_not_contains?: Maybe<String>
   question_starts_with?: Maybe<String>
   question_not_starts_with?: Maybe<String>
   question_ends_with?: Maybe<String>
   question_not_ends_with?: Maybe<String>
   targets_some?: Maybe<MenuWhereInput>
   paths_some?: Maybe<PathWhereInput>
   results_some?: Maybe<StepResultWhereInput>
   AND?: Maybe<StepWhereInput[] | StepWhereInput>
}

export interface KeyUserTypeWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   key?: Maybe<String>
   key_not?: Maybe<String>
   key_in?: Maybe<String[] | String>
   key_not_in?: Maybe<String[] | String>
   key_lt?: Maybe<String>
   key_lte?: Maybe<String>
   key_gt?: Maybe<String>
   key_gte?: Maybe<String>
   key_contains?: Maybe<String>
   key_not_contains?: Maybe<String>
   key_starts_with?: Maybe<String>
   key_not_starts_with?: Maybe<String>
   key_ends_with?: Maybe<String>
   key_not_ends_with?: Maybe<String>
   steps_some?: Maybe<StepWhereInput>
   AND?: Maybe<KeyUserTypeWhereInput[] | KeyUserTypeWhereInput>
}

export interface MenuWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   root?: Maybe<Boolean>
   root_not?: Maybe<Boolean>
   menus_some?: Maybe<MenuWhereInput>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   items_some?: Maybe<MenuWhereInput>
   AND?: Maybe<MenuWhereInput[] | MenuWhereInput>
}

export interface PathWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   parent?: Maybe<StepWhereInput>
   paths_some?: Maybe<MenuWhereInput>
   AND?: Maybe<PathWhereInput[] | PathWhereInput>
}

export interface StepResultWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   parent?: Maybe<StepWhereInput>
   resultParent?: Maybe<TestResultWhereInput>
   start?: Maybe<DateTimeInput>
   start_not?: Maybe<DateTimeInput>
   start_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_lt?: Maybe<DateTimeInput>
   start_lte?: Maybe<DateTimeInput>
   start_gt?: Maybe<DateTimeInput>
   start_gte?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   end_not?: Maybe<DateTimeInput>
   end_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_lt?: Maybe<DateTimeInput>
   end_lte?: Maybe<DateTimeInput>
   end_gt?: Maybe<DateTimeInput>
   end_gte?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultWhereInput>
   path_some?: Maybe<MenuWhereInput>
   status?: Maybe<KeyResultStatusWhereInput>
   AND?: Maybe<StepResultWhereInput[] | StepResultWhereInput>
}

export interface TimeResultWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   int?: Maybe<Int>
   int_not?: Maybe<Int>
   int_in?: Maybe<Int[] | Int>
   int_not_in?: Maybe<Int[] | Int>
   int_lt?: Maybe<Int>
   int_lte?: Maybe<Int>
   int_gt?: Maybe<Int>
   int_gte?: Maybe<Int>
   text?: Maybe<String>
   text_not?: Maybe<String>
   text_in?: Maybe<String[] | String>
   text_not_in?: Maybe<String[] | String>
   text_lt?: Maybe<String>
   text_lte?: Maybe<String>
   text_gt?: Maybe<String>
   text_gte?: Maybe<String>
   text_contains?: Maybe<String>
   text_not_contains?: Maybe<String>
   text_starts_with?: Maybe<String>
   text_not_starts_with?: Maybe<String>
   text_ends_with?: Maybe<String>
   text_not_ends_with?: Maybe<String>
   AND?: Maybe<TimeResultWhereInput[] | TimeResultWhereInput>
}

export interface KeyResultStatusWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   key?: Maybe<String>
   key_not?: Maybe<String>
   key_in?: Maybe<String[] | String>
   key_not_in?: Maybe<String[] | String>
   key_lt?: Maybe<String>
   key_lte?: Maybe<String>
   key_gt?: Maybe<String>
   key_gte?: Maybe<String>
   key_contains?: Maybe<String>
   key_not_contains?: Maybe<String>
   key_starts_with?: Maybe<String>
   key_not_starts_with?: Maybe<String>
   key_ends_with?: Maybe<String>
   key_not_ends_with?: Maybe<String>
   results_some?: Maybe<TestResultWhereInput>
   AND?: Maybe<KeyResultStatusWhereInput[] | KeyResultStatusWhereInput>
}

export type KeyUserTypeWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
   key?: Maybe<String>
}>

export type KeysWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface KeysWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   userType_some?: Maybe<KeyUserTypeWhereInput>
   resultStatus_some?: Maybe<KeyResultStatusWhereInput>
   AND?: Maybe<KeysWhereInput[] | KeysWhereInput>
}

export type MenuWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type PathWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type StepWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type StepResultWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type TestWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type TestResultWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type TimeResultWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export type ViewWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface ViewWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   welcome?: Maybe<WelcomeWhereInput>
   company?: Maybe<CompanyWhereInput>
   menus_some?: Maybe<MenuWhereInput>
   tests_some?: Maybe<TestWhereInput>
   steps_some?: Maybe<StepWhereInput>
   AND?: Maybe<ViewWhereInput[] | ViewWhereInput>
}

export interface WelcomeWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   message?: Maybe<String>
   message_not?: Maybe<String>
   message_in?: Maybe<String[] | String>
   message_not_in?: Maybe<String[] | String>
   message_lt?: Maybe<String>
   message_lte?: Maybe<String>
   message_gt?: Maybe<String>
   message_gte?: Maybe<String>
   message_contains?: Maybe<String>
   message_not_contains?: Maybe<String>
   message_starts_with?: Maybe<String>
   message_not_starts_with?: Maybe<String>
   message_ends_with?: Maybe<String>
   message_not_ends_with?: Maybe<String>
   AND?: Maybe<WelcomeWhereInput[] | WelcomeWhereInput>
}

export type WelcomeWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface CompanyCreateInput {
   id?: Maybe<ID_Input>
   name: String
   abbr?: Maybe<String>
   logo?: Maybe<String>
}

export interface CompanyUpdateInput {
   name?: Maybe<String>
   abbr?: Maybe<String>
   logo?: Maybe<String>
}

export interface CompanyUpdateManyMutationInput {
   name?: Maybe<String>
   abbr?: Maybe<String>
   logo?: Maybe<String>
}

export interface KeyResultStatusCreateInput {
   id?: Maybe<ID_Input>
   key: String
   results?: Maybe<TestResultCreateManyWithoutStatusInput>
}

export interface TestResultCreateManyWithoutStatusInput {
   create?: Maybe<
      TestResultCreateWithoutStatusInput[] | TestResultCreateWithoutStatusInput
   >
   connect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
}

export interface TestResultCreateWithoutStatusInput {
   id?: Maybe<ID_Input>
   parent: TestCreateOneWithoutResultsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   steps?: Maybe<StepResultCreateManyWithoutResultParentInput>
}

export interface TestCreateOneWithoutResultsInput {
   create?: Maybe<TestCreateWithoutResultsInput>
   connect?: Maybe<TestWhereUniqueInput>
}

export interface TestCreateWithoutResultsInput {
   id?: Maybe<ID_Input>
   title: String
   steps?: Maybe<StepCreateManyWithoutParentInput>
   menus?: Maybe<MenuCreateManyInput>
}

export interface StepCreateManyWithoutParentInput {
   create?: Maybe<StepCreateWithoutParentInput[] | StepCreateWithoutParentInput>
   connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
}

export interface StepCreateWithoutParentInput {
   id?: Maybe<ID_Input>
   type?: Maybe<KeyUserTypeCreateManyWithoutStepsInput>
   question: String
   targets?: Maybe<MenuCreateManyInput>
   paths?: Maybe<PathCreateManyWithoutParentInput>
   results?: Maybe<StepResultCreateManyWithoutParentInput>
}

export interface KeyUserTypeCreateManyWithoutStepsInput {
   create?: Maybe<
      KeyUserTypeCreateWithoutStepsInput[] | KeyUserTypeCreateWithoutStepsInput
   >
   connect?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
}

export interface KeyUserTypeCreateWithoutStepsInput {
   id?: Maybe<ID_Input>
   key: String
}

export interface MenuCreateManyInput {
   create?: Maybe<MenuCreateInput[] | MenuCreateInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
}

export interface MenuCreateInput {
   id?: Maybe<ID_Input>
   root?: Maybe<Boolean>
   menus?: Maybe<MenuCreateManyWithoutItemsInput>
   name: String
   items?: Maybe<MenuCreateManyWithoutMenusInput>
}

export interface MenuCreateManyWithoutItemsInput {
   create?: Maybe<MenuCreateWithoutItemsInput[] | MenuCreateWithoutItemsInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
}

export interface MenuCreateWithoutItemsInput {
   id?: Maybe<ID_Input>
   root?: Maybe<Boolean>
   menus?: Maybe<MenuCreateManyWithoutItemsInput>
   name: String
}

export interface MenuCreateManyWithoutMenusInput {
   create?: Maybe<MenuCreateWithoutMenusInput[] | MenuCreateWithoutMenusInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
}

export interface MenuCreateWithoutMenusInput {
   id?: Maybe<ID_Input>
   root?: Maybe<Boolean>
   name: String
   items?: Maybe<MenuCreateManyWithoutMenusInput>
}

export interface PathCreateManyWithoutParentInput {
   create?: Maybe<PathCreateWithoutParentInput[] | PathCreateWithoutParentInput>
   connect?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
}

export interface PathCreateWithoutParentInput {
   id?: Maybe<ID_Input>
   paths?: Maybe<MenuCreateManyInput>
}

export interface StepResultCreateManyWithoutParentInput {
   create?: Maybe<
      StepResultCreateWithoutParentInput[] | StepResultCreateWithoutParentInput
   >
   connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
}

export interface StepResultCreateWithoutParentInput {
   id?: Maybe<ID_Input>
   resultParent: TestResultCreateOneWithoutStepsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   path?: Maybe<MenuCreateManyInput>
   status: KeyResultStatusCreateOneInput
}

export interface TestResultCreateOneWithoutStepsInput {
   create?: Maybe<TestResultCreateWithoutStepsInput>
   connect?: Maybe<TestResultWhereUniqueInput>
}

export interface TestResultCreateWithoutStepsInput {
   id?: Maybe<ID_Input>
   parent: TestCreateOneWithoutResultsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   status: KeyResultStatusCreateOneWithoutResultsInput
}

export interface TimeResultCreateOneInput {
   create?: Maybe<TimeResultCreateInput>
   connect?: Maybe<TimeResultWhereUniqueInput>
}

export interface TimeResultCreateInput {
   id?: Maybe<ID_Input>
   int: Int
   text: String
}

export interface KeyResultStatusCreateOneWithoutResultsInput {
   create?: Maybe<KeyResultStatusCreateWithoutResultsInput>
   connect?: Maybe<KeyResultStatusWhereUniqueInput>
}

export interface KeyResultStatusCreateWithoutResultsInput {
   id?: Maybe<ID_Input>
   key: String
}

export interface KeyResultStatusCreateOneInput {
   create?: Maybe<KeyResultStatusCreateInput>
   connect?: Maybe<KeyResultStatusWhereUniqueInput>
}

export interface StepResultCreateManyWithoutResultParentInput {
   create?: Maybe<
      | StepResultCreateWithoutResultParentInput[]
      | StepResultCreateWithoutResultParentInput
   >
   connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
}

export interface StepResultCreateWithoutResultParentInput {
   id?: Maybe<ID_Input>
   parent: StepCreateOneWithoutResultsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   path?: Maybe<MenuCreateManyInput>
   status: KeyResultStatusCreateOneInput
}

export interface StepCreateOneWithoutResultsInput {
   create?: Maybe<StepCreateWithoutResultsInput>
   connect?: Maybe<StepWhereUniqueInput>
}

export interface StepCreateWithoutResultsInput {
   id?: Maybe<ID_Input>
   parent?: Maybe<TestCreateOneWithoutStepsInput>
   type?: Maybe<KeyUserTypeCreateManyWithoutStepsInput>
   question: String
   targets?: Maybe<MenuCreateManyInput>
   paths?: Maybe<PathCreateManyWithoutParentInput>
}

export interface TestCreateOneWithoutStepsInput {
   create?: Maybe<TestCreateWithoutStepsInput>
   connect?: Maybe<TestWhereUniqueInput>
}

export interface TestCreateWithoutStepsInput {
   id?: Maybe<ID_Input>
   title: String
   menus?: Maybe<MenuCreateManyInput>
   results?: Maybe<TestResultCreateManyWithoutParentInput>
}

export interface TestResultCreateManyWithoutParentInput {
   create?: Maybe<
      TestResultCreateWithoutParentInput[] | TestResultCreateWithoutParentInput
   >
   connect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
}

export interface TestResultCreateWithoutParentInput {
   id?: Maybe<ID_Input>
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   steps?: Maybe<StepResultCreateManyWithoutResultParentInput>
   status: KeyResultStatusCreateOneWithoutResultsInput
}

export interface KeyResultStatusUpdateInput {
   key?: Maybe<String>
   results?: Maybe<TestResultUpdateManyWithoutStatusInput>
}

export interface TestResultUpdateManyWithoutStatusInput {
   create?: Maybe<
      TestResultCreateWithoutStatusInput[] | TestResultCreateWithoutStatusInput
   >
   delete?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   connect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   set?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   disconnect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   update?: Maybe<
      | TestResultUpdateWithWhereUniqueWithoutStatusInput[]
      | TestResultUpdateWithWhereUniqueWithoutStatusInput
   >
   upsert?: Maybe<
      | TestResultUpsertWithWhereUniqueWithoutStatusInput[]
      | TestResultUpsertWithWhereUniqueWithoutStatusInput
   >
   deleteMany?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
   updateMany?: Maybe<
      | TestResultUpdateManyWithWhereNestedInput[]
      | TestResultUpdateManyWithWhereNestedInput
   >
}

export interface TestResultUpdateWithWhereUniqueWithoutStatusInput {
   where: TestResultWhereUniqueInput
   data: TestResultUpdateWithoutStatusDataInput
}

export interface TestResultUpdateWithoutStatusDataInput {
   parent?: Maybe<TestUpdateOneRequiredWithoutResultsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   steps?: Maybe<StepResultUpdateManyWithoutResultParentInput>
}

export interface TestUpdateOneRequiredWithoutResultsInput {
   create?: Maybe<TestCreateWithoutResultsInput>
   update?: Maybe<TestUpdateWithoutResultsDataInput>
   upsert?: Maybe<TestUpsertWithoutResultsInput>
   connect?: Maybe<TestWhereUniqueInput>
}

export interface TestUpdateWithoutResultsDataInput {
   title?: Maybe<String>
   steps?: Maybe<StepUpdateManyWithoutParentInput>
   menus?: Maybe<MenuUpdateManyInput>
}

export interface StepUpdateManyWithoutParentInput {
   create?: Maybe<StepCreateWithoutParentInput[] | StepCreateWithoutParentInput>
   delete?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   set?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   disconnect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   update?: Maybe<
      | StepUpdateWithWhereUniqueWithoutParentInput[]
      | StepUpdateWithWhereUniqueWithoutParentInput
   >
   upsert?: Maybe<
      | StepUpsertWithWhereUniqueWithoutParentInput[]
      | StepUpsertWithWhereUniqueWithoutParentInput
   >
   deleteMany?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
   updateMany?: Maybe<
      StepUpdateManyWithWhereNestedInput[] | StepUpdateManyWithWhereNestedInput
   >
}

export interface StepUpdateWithWhereUniqueWithoutParentInput {
   where: StepWhereUniqueInput
   data: StepUpdateWithoutParentDataInput
}

export interface StepUpdateWithoutParentDataInput {
   type?: Maybe<KeyUserTypeUpdateManyWithoutStepsInput>
   question?: Maybe<String>
   targets?: Maybe<MenuUpdateManyInput>
   paths?: Maybe<PathUpdateManyWithoutParentInput>
   results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface KeyUserTypeUpdateManyWithoutStepsInput {
   create?: Maybe<
      KeyUserTypeCreateWithoutStepsInput[] | KeyUserTypeCreateWithoutStepsInput
   >
   delete?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
   connect?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
   set?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
   disconnect?: Maybe<
      KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput
   >
   update?: Maybe<
      | KeyUserTypeUpdateWithWhereUniqueWithoutStepsInput[]
      | KeyUserTypeUpdateWithWhereUniqueWithoutStepsInput
   >
   upsert?: Maybe<
      | KeyUserTypeUpsertWithWhereUniqueWithoutStepsInput[]
      | KeyUserTypeUpsertWithWhereUniqueWithoutStepsInput
   >
   deleteMany?: Maybe<
      KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput
   >
   updateMany?: Maybe<
      | KeyUserTypeUpdateManyWithWhereNestedInput[]
      | KeyUserTypeUpdateManyWithWhereNestedInput
   >
}

export interface KeyUserTypeUpdateWithWhereUniqueWithoutStepsInput {
   where: KeyUserTypeWhereUniqueInput
   data: KeyUserTypeUpdateWithoutStepsDataInput
}

export interface KeyUserTypeUpdateWithoutStepsDataInput {
   key?: Maybe<String>
}

export interface KeyUserTypeUpsertWithWhereUniqueWithoutStepsInput {
   where: KeyUserTypeWhereUniqueInput
   update: KeyUserTypeUpdateWithoutStepsDataInput
   create: KeyUserTypeCreateWithoutStepsInput
}

export interface KeyUserTypeScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   key?: Maybe<String>
   key_not?: Maybe<String>
   key_in?: Maybe<String[] | String>
   key_not_in?: Maybe<String[] | String>
   key_lt?: Maybe<String>
   key_lte?: Maybe<String>
   key_gt?: Maybe<String>
   key_gte?: Maybe<String>
   key_contains?: Maybe<String>
   key_not_contains?: Maybe<String>
   key_starts_with?: Maybe<String>
   key_not_starts_with?: Maybe<String>
   key_ends_with?: Maybe<String>
   key_not_ends_with?: Maybe<String>
   AND?: Maybe<KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput>
   OR?: Maybe<KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput>
   NOT?: Maybe<KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput>
}

export interface KeyUserTypeUpdateManyWithWhereNestedInput {
   where: KeyUserTypeScalarWhereInput
   data: KeyUserTypeUpdateManyDataInput
}

export interface KeyUserTypeUpdateManyDataInput {
   key?: Maybe<String>
}

export interface MenuUpdateManyInput {
   create?: Maybe<MenuCreateInput[] | MenuCreateInput>
   update?: Maybe<
      | MenuUpdateWithWhereUniqueNestedInput[]
      | MenuUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | MenuUpsertWithWhereUniqueNestedInput[]
      | MenuUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   set?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   disconnect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   deleteMany?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   updateMany?: Maybe<
      MenuUpdateManyWithWhereNestedInput[] | MenuUpdateManyWithWhereNestedInput
   >
}

export interface MenuUpdateWithWhereUniqueNestedInput {
   where: MenuWhereUniqueInput
   data: MenuUpdateDataInput
}

export interface MenuUpdateDataInput {
   root?: Maybe<Boolean>
   menus?: Maybe<MenuUpdateManyWithoutItemsInput>
   name?: Maybe<String>
   items?: Maybe<MenuUpdateManyWithoutMenusInput>
}

export interface MenuUpdateManyWithoutItemsInput {
   create?: Maybe<MenuCreateWithoutItemsInput[] | MenuCreateWithoutItemsInput>
   delete?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   set?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   disconnect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   update?: Maybe<
      | MenuUpdateWithWhereUniqueWithoutItemsInput[]
      | MenuUpdateWithWhereUniqueWithoutItemsInput
   >
   upsert?: Maybe<
      | MenuUpsertWithWhereUniqueWithoutItemsInput[]
      | MenuUpsertWithWhereUniqueWithoutItemsInput
   >
   deleteMany?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   updateMany?: Maybe<
      MenuUpdateManyWithWhereNestedInput[] | MenuUpdateManyWithWhereNestedInput
   >
}

export interface MenuUpdateWithWhereUniqueWithoutItemsInput {
   where: MenuWhereUniqueInput
   data: MenuUpdateWithoutItemsDataInput
}

export interface MenuUpdateWithoutItemsDataInput {
   root?: Maybe<Boolean>
   menus?: Maybe<MenuUpdateManyWithoutItemsInput>
   name?: Maybe<String>
}

export interface MenuUpsertWithWhereUniqueWithoutItemsInput {
   where: MenuWhereUniqueInput
   update: MenuUpdateWithoutItemsDataInput
   create: MenuCreateWithoutItemsInput
}

export interface MenuScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   root?: Maybe<Boolean>
   root_not?: Maybe<Boolean>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   AND?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   OR?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   NOT?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
}

export interface MenuUpdateManyWithWhereNestedInput {
   where: MenuScalarWhereInput
   data: MenuUpdateManyDataInput
}

export interface MenuUpdateManyDataInput {
   root?: Maybe<Boolean>
   name?: Maybe<String>
}

export interface MenuUpdateManyWithoutMenusInput {
   create?: Maybe<MenuCreateWithoutMenusInput[] | MenuCreateWithoutMenusInput>
   delete?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   set?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   disconnect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
   update?: Maybe<
      | MenuUpdateWithWhereUniqueWithoutMenusInput[]
      | MenuUpdateWithWhereUniqueWithoutMenusInput
   >
   upsert?: Maybe<
      | MenuUpsertWithWhereUniqueWithoutMenusInput[]
      | MenuUpsertWithWhereUniqueWithoutMenusInput
   >
   deleteMany?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
   updateMany?: Maybe<
      MenuUpdateManyWithWhereNestedInput[] | MenuUpdateManyWithWhereNestedInput
   >
}

export interface MenuUpdateWithWhereUniqueWithoutMenusInput {
   where: MenuWhereUniqueInput
   data: MenuUpdateWithoutMenusDataInput
}

export interface MenuUpdateWithoutMenusDataInput {
   root?: Maybe<Boolean>
   name?: Maybe<String>
   items?: Maybe<MenuUpdateManyWithoutMenusInput>
}

export interface MenuUpsertWithWhereUniqueWithoutMenusInput {
   where: MenuWhereUniqueInput
   update: MenuUpdateWithoutMenusDataInput
   create: MenuCreateWithoutMenusInput
}

export interface MenuUpsertWithWhereUniqueNestedInput {
   where: MenuWhereUniqueInput
   update: MenuUpdateDataInput
   create: MenuCreateInput
}

export interface PathUpdateManyWithoutParentInput {
   create?: Maybe<PathCreateWithoutParentInput[] | PathCreateWithoutParentInput>
   delete?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
   connect?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
   set?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
   disconnect?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
   update?: Maybe<
      | PathUpdateWithWhereUniqueWithoutParentInput[]
      | PathUpdateWithWhereUniqueWithoutParentInput
   >
   upsert?: Maybe<
      | PathUpsertWithWhereUniqueWithoutParentInput[]
      | PathUpsertWithWhereUniqueWithoutParentInput
   >
   deleteMany?: Maybe<PathScalarWhereInput[] | PathScalarWhereInput>
}

export interface PathUpdateWithWhereUniqueWithoutParentInput {
   where: PathWhereUniqueInput
   data: PathUpdateWithoutParentDataInput
}

export interface PathUpdateWithoutParentDataInput {
   paths?: Maybe<MenuUpdateManyInput>
}

export interface PathUpsertWithWhereUniqueWithoutParentInput {
   where: PathWhereUniqueInput
   update: PathUpdateWithoutParentDataInput
   create: PathCreateWithoutParentInput
}

export interface PathScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   AND?: Maybe<PathScalarWhereInput[] | PathScalarWhereInput>
   OR?: Maybe<PathScalarWhereInput[] | PathScalarWhereInput>
   NOT?: Maybe<PathScalarWhereInput[] | PathScalarWhereInput>
}

export interface StepResultUpdateManyWithoutParentInput {
   create?: Maybe<
      StepResultCreateWithoutParentInput[] | StepResultCreateWithoutParentInput
   >
   delete?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   set?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   disconnect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   update?: Maybe<
      | StepResultUpdateWithWhereUniqueWithoutParentInput[]
      | StepResultUpdateWithWhereUniqueWithoutParentInput
   >
   upsert?: Maybe<
      | StepResultUpsertWithWhereUniqueWithoutParentInput[]
      | StepResultUpsertWithWhereUniqueWithoutParentInput
   >
   deleteMany?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
   updateMany?: Maybe<
      | StepResultUpdateManyWithWhereNestedInput[]
      | StepResultUpdateManyWithWhereNestedInput
   >
}

export interface StepResultUpdateWithWhereUniqueWithoutParentInput {
   where: StepResultWhereUniqueInput
   data: StepResultUpdateWithoutParentDataInput
}

export interface StepResultUpdateWithoutParentDataInput {
   resultParent?: Maybe<TestResultUpdateOneRequiredWithoutStepsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   path?: Maybe<MenuUpdateManyInput>
   status?: Maybe<KeyResultStatusUpdateOneRequiredInput>
}

export interface TestResultUpdateOneRequiredWithoutStepsInput {
   create?: Maybe<TestResultCreateWithoutStepsInput>
   update?: Maybe<TestResultUpdateWithoutStepsDataInput>
   upsert?: Maybe<TestResultUpsertWithoutStepsInput>
   connect?: Maybe<TestResultWhereUniqueInput>
}

export interface TestResultUpdateWithoutStepsDataInput {
   parent?: Maybe<TestUpdateOneRequiredWithoutResultsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   status?: Maybe<KeyResultStatusUpdateOneRequiredWithoutResultsInput>
}

export interface TimeResultUpdateOneInput {
   create?: Maybe<TimeResultCreateInput>
   update?: Maybe<TimeResultUpdateDataInput>
   upsert?: Maybe<TimeResultUpsertNestedInput>
   delete?: Maybe<Boolean>
   disconnect?: Maybe<Boolean>
   connect?: Maybe<TimeResultWhereUniqueInput>
}

export interface TimeResultUpdateDataInput {
   int?: Maybe<Int>
   text?: Maybe<String>
}

export interface TimeResultUpsertNestedInput {
   update: TimeResultUpdateDataInput
   create: TimeResultCreateInput
}

export interface KeyResultStatusUpdateOneRequiredWithoutResultsInput {
   create?: Maybe<KeyResultStatusCreateWithoutResultsInput>
   update?: Maybe<KeyResultStatusUpdateWithoutResultsDataInput>
   upsert?: Maybe<KeyResultStatusUpsertWithoutResultsInput>
   connect?: Maybe<KeyResultStatusWhereUniqueInput>
}

export interface KeyResultStatusUpdateWithoutResultsDataInput {
   key?: Maybe<String>
}

export interface KeyResultStatusUpsertWithoutResultsInput {
   update: KeyResultStatusUpdateWithoutResultsDataInput
   create: KeyResultStatusCreateWithoutResultsInput
}

export interface TestResultUpsertWithoutStepsInput {
   update: TestResultUpdateWithoutStepsDataInput
   create: TestResultCreateWithoutStepsInput
}

export interface KeyResultStatusUpdateOneRequiredInput {
   create?: Maybe<KeyResultStatusCreateInput>
   update?: Maybe<KeyResultStatusUpdateDataInput>
   upsert?: Maybe<KeyResultStatusUpsertNestedInput>
   connect?: Maybe<KeyResultStatusWhereUniqueInput>
}

export interface KeyResultStatusUpdateDataInput {
   key?: Maybe<String>
   results?: Maybe<TestResultUpdateManyWithoutStatusInput>
}

export interface KeyResultStatusUpsertNestedInput {
   update: KeyResultStatusUpdateDataInput
   create: KeyResultStatusCreateInput
}

export interface StepResultUpsertWithWhereUniqueWithoutParentInput {
   where: StepResultWhereUniqueInput
   update: StepResultUpdateWithoutParentDataInput
   create: StepResultCreateWithoutParentInput
}

export interface StepResultScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   start?: Maybe<DateTimeInput>
   start_not?: Maybe<DateTimeInput>
   start_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_lt?: Maybe<DateTimeInput>
   start_lte?: Maybe<DateTimeInput>
   start_gt?: Maybe<DateTimeInput>
   start_gte?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   end_not?: Maybe<DateTimeInput>
   end_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_lt?: Maybe<DateTimeInput>
   end_lte?: Maybe<DateTimeInput>
   end_gt?: Maybe<DateTimeInput>
   end_gte?: Maybe<DateTimeInput>
   AND?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
   OR?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
   NOT?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
}

export interface StepResultUpdateManyWithWhereNestedInput {
   where: StepResultScalarWhereInput
   data: StepResultUpdateManyDataInput
}

export interface StepResultUpdateManyDataInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
}

export interface StepUpsertWithWhereUniqueWithoutParentInput {
   where: StepWhereUniqueInput
   update: StepUpdateWithoutParentDataInput
   create: StepCreateWithoutParentInput
}

export interface StepScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   question?: Maybe<String>
   question_not?: Maybe<String>
   question_in?: Maybe<String[] | String>
   question_not_in?: Maybe<String[] | String>
   question_lt?: Maybe<String>
   question_lte?: Maybe<String>
   question_gt?: Maybe<String>
   question_gte?: Maybe<String>
   question_contains?: Maybe<String>
   question_not_contains?: Maybe<String>
   question_starts_with?: Maybe<String>
   question_not_starts_with?: Maybe<String>
   question_ends_with?: Maybe<String>
   question_not_ends_with?: Maybe<String>
   AND?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
   OR?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
   NOT?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
}

export interface StepUpdateManyWithWhereNestedInput {
   where: StepScalarWhereInput
   data: StepUpdateManyDataInput
}

export interface StepUpdateManyDataInput {
   question?: Maybe<String>
}

export interface TestUpsertWithoutResultsInput {
   update: TestUpdateWithoutResultsDataInput
   create: TestCreateWithoutResultsInput
}

export interface StepResultUpdateManyWithoutResultParentInput {
   create?: Maybe<
      | StepResultCreateWithoutResultParentInput[]
      | StepResultCreateWithoutResultParentInput
   >
   delete?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   set?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   disconnect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
   update?: Maybe<
      | StepResultUpdateWithWhereUniqueWithoutResultParentInput[]
      | StepResultUpdateWithWhereUniqueWithoutResultParentInput
   >
   upsert?: Maybe<
      | StepResultUpsertWithWhereUniqueWithoutResultParentInput[]
      | StepResultUpsertWithWhereUniqueWithoutResultParentInput
   >
   deleteMany?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
   updateMany?: Maybe<
      | StepResultUpdateManyWithWhereNestedInput[]
      | StepResultUpdateManyWithWhereNestedInput
   >
}

export interface StepResultUpdateWithWhereUniqueWithoutResultParentInput {
   where: StepResultWhereUniqueInput
   data: StepResultUpdateWithoutResultParentDataInput
}

export interface StepResultUpdateWithoutResultParentDataInput {
   parent?: Maybe<StepUpdateOneRequiredWithoutResultsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   path?: Maybe<MenuUpdateManyInput>
   status?: Maybe<KeyResultStatusUpdateOneRequiredInput>
}

export interface StepUpdateOneRequiredWithoutResultsInput {
   create?: Maybe<StepCreateWithoutResultsInput>
   update?: Maybe<StepUpdateWithoutResultsDataInput>
   upsert?: Maybe<StepUpsertWithoutResultsInput>
   connect?: Maybe<StepWhereUniqueInput>
}

export interface StepUpdateWithoutResultsDataInput {
   parent?: Maybe<TestUpdateOneWithoutStepsInput>
   type?: Maybe<KeyUserTypeUpdateManyWithoutStepsInput>
   question?: Maybe<String>
   targets?: Maybe<MenuUpdateManyInput>
   paths?: Maybe<PathUpdateManyWithoutParentInput>
}

export interface TestUpdateOneWithoutStepsInput {
   create?: Maybe<TestCreateWithoutStepsInput>
   update?: Maybe<TestUpdateWithoutStepsDataInput>
   upsert?: Maybe<TestUpsertWithoutStepsInput>
   delete?: Maybe<Boolean>
   disconnect?: Maybe<Boolean>
   connect?: Maybe<TestWhereUniqueInput>
}

export interface TestUpdateWithoutStepsDataInput {
   title?: Maybe<String>
   menus?: Maybe<MenuUpdateManyInput>
   results?: Maybe<TestResultUpdateManyWithoutParentInput>
}

export interface TestResultUpdateManyWithoutParentInput {
   create?: Maybe<
      TestResultCreateWithoutParentInput[] | TestResultCreateWithoutParentInput
   >
   delete?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   connect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   set?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   disconnect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
   update?: Maybe<
      | TestResultUpdateWithWhereUniqueWithoutParentInput[]
      | TestResultUpdateWithWhereUniqueWithoutParentInput
   >
   upsert?: Maybe<
      | TestResultUpsertWithWhereUniqueWithoutParentInput[]
      | TestResultUpsertWithWhereUniqueWithoutParentInput
   >
   deleteMany?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
   updateMany?: Maybe<
      | TestResultUpdateManyWithWhereNestedInput[]
      | TestResultUpdateManyWithWhereNestedInput
   >
}

export interface TestResultUpdateWithWhereUniqueWithoutParentInput {
   where: TestResultWhereUniqueInput
   data: TestResultUpdateWithoutParentDataInput
}

export interface TestResultUpdateWithoutParentDataInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   steps?: Maybe<StepResultUpdateManyWithoutResultParentInput>
   status?: Maybe<KeyResultStatusUpdateOneRequiredWithoutResultsInput>
}

export interface TestResultUpsertWithWhereUniqueWithoutParentInput {
   where: TestResultWhereUniqueInput
   update: TestResultUpdateWithoutParentDataInput
   create: TestResultCreateWithoutParentInput
}

export interface TestResultScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   start?: Maybe<DateTimeInput>
   start_not?: Maybe<DateTimeInput>
   start_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   start_lt?: Maybe<DateTimeInput>
   start_lte?: Maybe<DateTimeInput>
   start_gt?: Maybe<DateTimeInput>
   start_gte?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   end_not?: Maybe<DateTimeInput>
   end_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   end_lt?: Maybe<DateTimeInput>
   end_lte?: Maybe<DateTimeInput>
   end_gt?: Maybe<DateTimeInput>
   end_gte?: Maybe<DateTimeInput>
   AND?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
   OR?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
   NOT?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
}

export interface TestResultUpdateManyWithWhereNestedInput {
   where: TestResultScalarWhereInput
   data: TestResultUpdateManyDataInput
}

export interface TestResultUpdateManyDataInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
}

export interface TestUpsertWithoutStepsInput {
   update: TestUpdateWithoutStepsDataInput
   create: TestCreateWithoutStepsInput
}

export interface StepUpsertWithoutResultsInput {
   update: StepUpdateWithoutResultsDataInput
   create: StepCreateWithoutResultsInput
}

export interface StepResultUpsertWithWhereUniqueWithoutResultParentInput {
   where: StepResultWhereUniqueInput
   update: StepResultUpdateWithoutResultParentDataInput
   create: StepResultCreateWithoutResultParentInput
}

export interface TestResultUpsertWithWhereUniqueWithoutStatusInput {
   where: TestResultWhereUniqueInput
   update: TestResultUpdateWithoutStatusDataInput
   create: TestResultCreateWithoutStatusInput
}

export interface KeyResultStatusUpdateManyMutationInput {
   key?: Maybe<String>
}

export interface KeyUserTypeCreateInput {
   id?: Maybe<ID_Input>
   key: String
   steps?: Maybe<StepCreateManyWithoutTypeInput>
}

export interface StepCreateManyWithoutTypeInput {
   create?: Maybe<StepCreateWithoutTypeInput[] | StepCreateWithoutTypeInput>
   connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
}

export interface StepCreateWithoutTypeInput {
   id?: Maybe<ID_Input>
   parent?: Maybe<TestCreateOneWithoutStepsInput>
   question: String
   targets?: Maybe<MenuCreateManyInput>
   paths?: Maybe<PathCreateManyWithoutParentInput>
   results?: Maybe<StepResultCreateManyWithoutParentInput>
}

export interface KeyUserTypeUpdateInput {
   key?: Maybe<String>
   steps?: Maybe<StepUpdateManyWithoutTypeInput>
}

export interface StepUpdateManyWithoutTypeInput {
   create?: Maybe<StepCreateWithoutTypeInput[] | StepCreateWithoutTypeInput>
   delete?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   set?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   disconnect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   update?: Maybe<
      | StepUpdateWithWhereUniqueWithoutTypeInput[]
      | StepUpdateWithWhereUniqueWithoutTypeInput
   >
   upsert?: Maybe<
      | StepUpsertWithWhereUniqueWithoutTypeInput[]
      | StepUpsertWithWhereUniqueWithoutTypeInput
   >
   deleteMany?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
   updateMany?: Maybe<
      StepUpdateManyWithWhereNestedInput[] | StepUpdateManyWithWhereNestedInput
   >
}

export interface StepUpdateWithWhereUniqueWithoutTypeInput {
   where: StepWhereUniqueInput
   data: StepUpdateWithoutTypeDataInput
}

export interface StepUpdateWithoutTypeDataInput {
   parent?: Maybe<TestUpdateOneWithoutStepsInput>
   question?: Maybe<String>
   targets?: Maybe<MenuUpdateManyInput>
   paths?: Maybe<PathUpdateManyWithoutParentInput>
   results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface StepUpsertWithWhereUniqueWithoutTypeInput {
   where: StepWhereUniqueInput
   update: StepUpdateWithoutTypeDataInput
   create: StepCreateWithoutTypeInput
}

export interface KeyUserTypeUpdateManyMutationInput {
   key?: Maybe<String>
}

export interface KeysCreateInput {
   id?: Maybe<ID_Input>
   userType?: Maybe<KeyUserTypeCreateManyInput>
   resultStatus?: Maybe<KeyResultStatusCreateManyInput>
}

export interface KeyUserTypeCreateManyInput {
   create?: Maybe<KeyUserTypeCreateInput[] | KeyUserTypeCreateInput>
   connect?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
}

export interface KeyResultStatusCreateManyInput {
   create?: Maybe<KeyResultStatusCreateInput[] | KeyResultStatusCreateInput>
   connect?: Maybe<
      KeyResultStatusWhereUniqueInput[] | KeyResultStatusWhereUniqueInput
   >
}

export interface KeysUpdateInput {
   userType?: Maybe<KeyUserTypeUpdateManyInput>
   resultStatus?: Maybe<KeyResultStatusUpdateManyInput>
}

export interface KeyUserTypeUpdateManyInput {
   create?: Maybe<KeyUserTypeCreateInput[] | KeyUserTypeCreateInput>
   update?: Maybe<
      | KeyUserTypeUpdateWithWhereUniqueNestedInput[]
      | KeyUserTypeUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | KeyUserTypeUpsertWithWhereUniqueNestedInput[]
      | KeyUserTypeUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
   connect?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
   set?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
   disconnect?: Maybe<
      KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput
   >
   deleteMany?: Maybe<
      KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput
   >
   updateMany?: Maybe<
      | KeyUserTypeUpdateManyWithWhereNestedInput[]
      | KeyUserTypeUpdateManyWithWhereNestedInput
   >
}

export interface KeyUserTypeUpdateWithWhereUniqueNestedInput {
   where: KeyUserTypeWhereUniqueInput
   data: KeyUserTypeUpdateDataInput
}

export interface KeyUserTypeUpdateDataInput {
   key?: Maybe<String>
   steps?: Maybe<StepUpdateManyWithoutTypeInput>
}

export interface KeyUserTypeUpsertWithWhereUniqueNestedInput {
   where: KeyUserTypeWhereUniqueInput
   update: KeyUserTypeUpdateDataInput
   create: KeyUserTypeCreateInput
}

export interface KeyResultStatusUpdateManyInput {
   create?: Maybe<KeyResultStatusCreateInput[] | KeyResultStatusCreateInput>
   update?: Maybe<
      | KeyResultStatusUpdateWithWhereUniqueNestedInput[]
      | KeyResultStatusUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | KeyResultStatusUpsertWithWhereUniqueNestedInput[]
      | KeyResultStatusUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<
      KeyResultStatusWhereUniqueInput[] | KeyResultStatusWhereUniqueInput
   >
   connect?: Maybe<
      KeyResultStatusWhereUniqueInput[] | KeyResultStatusWhereUniqueInput
   >
   set?: Maybe<
      KeyResultStatusWhereUniqueInput[] | KeyResultStatusWhereUniqueInput
   >
   disconnect?: Maybe<
      KeyResultStatusWhereUniqueInput[] | KeyResultStatusWhereUniqueInput
   >
   deleteMany?: Maybe<
      KeyResultStatusScalarWhereInput[] | KeyResultStatusScalarWhereInput
   >
   updateMany?: Maybe<
      | KeyResultStatusUpdateManyWithWhereNestedInput[]
      | KeyResultStatusUpdateManyWithWhereNestedInput
   >
}

export interface KeyResultStatusUpdateWithWhereUniqueNestedInput {
   where: KeyResultStatusWhereUniqueInput
   data: KeyResultStatusUpdateDataInput
}

export interface KeyResultStatusUpsertWithWhereUniqueNestedInput {
   where: KeyResultStatusWhereUniqueInput
   update: KeyResultStatusUpdateDataInput
   create: KeyResultStatusCreateInput
}

export interface KeyResultStatusScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   key?: Maybe<String>
   key_not?: Maybe<String>
   key_in?: Maybe<String[] | String>
   key_not_in?: Maybe<String[] | String>
   key_lt?: Maybe<String>
   key_lte?: Maybe<String>
   key_gt?: Maybe<String>
   key_gte?: Maybe<String>
   key_contains?: Maybe<String>
   key_not_contains?: Maybe<String>
   key_starts_with?: Maybe<String>
   key_not_starts_with?: Maybe<String>
   key_ends_with?: Maybe<String>
   key_not_ends_with?: Maybe<String>
   AND?: Maybe<
      KeyResultStatusScalarWhereInput[] | KeyResultStatusScalarWhereInput
   >
   OR?: Maybe<
      KeyResultStatusScalarWhereInput[] | KeyResultStatusScalarWhereInput
   >
   NOT?: Maybe<
      KeyResultStatusScalarWhereInput[] | KeyResultStatusScalarWhereInput
   >
}

export interface KeyResultStatusUpdateManyWithWhereNestedInput {
   where: KeyResultStatusScalarWhereInput
   data: KeyResultStatusUpdateManyDataInput
}

export interface KeyResultStatusUpdateManyDataInput {
   key?: Maybe<String>
}

export interface MenuUpdateInput {
   root?: Maybe<Boolean>
   menus?: Maybe<MenuUpdateManyWithoutItemsInput>
   name?: Maybe<String>
   items?: Maybe<MenuUpdateManyWithoutMenusInput>
}

export interface MenuUpdateManyMutationInput {
   root?: Maybe<Boolean>
   name?: Maybe<String>
}

export interface PathCreateInput {
   id?: Maybe<ID_Input>
   parent: StepCreateOneWithoutPathsInput
   paths?: Maybe<MenuCreateManyInput>
}

export interface StepCreateOneWithoutPathsInput {
   create?: Maybe<StepCreateWithoutPathsInput>
   connect?: Maybe<StepWhereUniqueInput>
}

export interface StepCreateWithoutPathsInput {
   id?: Maybe<ID_Input>
   parent?: Maybe<TestCreateOneWithoutStepsInput>
   type?: Maybe<KeyUserTypeCreateManyWithoutStepsInput>
   question: String
   targets?: Maybe<MenuCreateManyInput>
   results?: Maybe<StepResultCreateManyWithoutParentInput>
}

export interface PathUpdateInput {
   parent?: Maybe<StepUpdateOneRequiredWithoutPathsInput>
   paths?: Maybe<MenuUpdateManyInput>
}

export interface StepUpdateOneRequiredWithoutPathsInput {
   create?: Maybe<StepCreateWithoutPathsInput>
   update?: Maybe<StepUpdateWithoutPathsDataInput>
   upsert?: Maybe<StepUpsertWithoutPathsInput>
   connect?: Maybe<StepWhereUniqueInput>
}

export interface StepUpdateWithoutPathsDataInput {
   parent?: Maybe<TestUpdateOneWithoutStepsInput>
   type?: Maybe<KeyUserTypeUpdateManyWithoutStepsInput>
   question?: Maybe<String>
   targets?: Maybe<MenuUpdateManyInput>
   results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface StepUpsertWithoutPathsInput {
   update: StepUpdateWithoutPathsDataInput
   create: StepCreateWithoutPathsInput
}

export interface StepCreateInput {
   id?: Maybe<ID_Input>
   parent?: Maybe<TestCreateOneWithoutStepsInput>
   type?: Maybe<KeyUserTypeCreateManyWithoutStepsInput>
   question: String
   targets?: Maybe<MenuCreateManyInput>
   paths?: Maybe<PathCreateManyWithoutParentInput>
   results?: Maybe<StepResultCreateManyWithoutParentInput>
}

export interface StepUpdateInput {
   parent?: Maybe<TestUpdateOneWithoutStepsInput>
   type?: Maybe<KeyUserTypeUpdateManyWithoutStepsInput>
   question?: Maybe<String>
   targets?: Maybe<MenuUpdateManyInput>
   paths?: Maybe<PathUpdateManyWithoutParentInput>
   results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface StepUpdateManyMutationInput {
   question?: Maybe<String>
}

export interface StepResultCreateInput {
   id?: Maybe<ID_Input>
   parent: StepCreateOneWithoutResultsInput
   resultParent: TestResultCreateOneWithoutStepsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   path?: Maybe<MenuCreateManyInput>
   status: KeyResultStatusCreateOneInput
}

export interface StepResultUpdateInput {
   parent?: Maybe<StepUpdateOneRequiredWithoutResultsInput>
   resultParent?: Maybe<TestResultUpdateOneRequiredWithoutStepsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   path?: Maybe<MenuUpdateManyInput>
   status?: Maybe<KeyResultStatusUpdateOneRequiredInput>
}

export interface StepResultUpdateManyMutationInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
}

export interface TestCreateInput {
   id?: Maybe<ID_Input>
   title: String
   steps?: Maybe<StepCreateManyWithoutParentInput>
   menus?: Maybe<MenuCreateManyInput>
   results?: Maybe<TestResultCreateManyWithoutParentInput>
}

export interface TestUpdateInput {
   title?: Maybe<String>
   steps?: Maybe<StepUpdateManyWithoutParentInput>
   menus?: Maybe<MenuUpdateManyInput>
   results?: Maybe<TestResultUpdateManyWithoutParentInput>
}

export interface TestUpdateManyMutationInput {
   title?: Maybe<String>
}

export interface TestResultCreateInput {
   id?: Maybe<ID_Input>
   parent: TestCreateOneWithoutResultsInput
   start: DateTimeInput
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultCreateOneInput>
   steps?: Maybe<StepResultCreateManyWithoutResultParentInput>
   status: KeyResultStatusCreateOneWithoutResultsInput
}

export interface TestResultUpdateInput {
   parent?: Maybe<TestUpdateOneRequiredWithoutResultsInput>
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
   time?: Maybe<TimeResultUpdateOneInput>
   steps?: Maybe<StepResultUpdateManyWithoutResultParentInput>
   status?: Maybe<KeyResultStatusUpdateOneRequiredWithoutResultsInput>
}

export interface TestResultUpdateManyMutationInput {
   start?: Maybe<DateTimeInput>
   end?: Maybe<DateTimeInput>
}

export interface TimeResultUpdateInput {
   int?: Maybe<Int>
   text?: Maybe<String>
}

export interface TimeResultUpdateManyMutationInput {
   int?: Maybe<Int>
   text?: Maybe<String>
}

export interface ViewCreateInput {
   id?: Maybe<ID_Input>
   welcome: WelcomeCreateOneInput
   company: CompanyCreateOneInput
   menus?: Maybe<MenuCreateManyInput>
   tests?: Maybe<TestCreateManyInput>
   steps?: Maybe<StepCreateManyInput>
}

export interface WelcomeCreateOneInput {
   create?: Maybe<WelcomeCreateInput>
   connect?: Maybe<WelcomeWhereUniqueInput>
}

export interface WelcomeCreateInput {
   id?: Maybe<ID_Input>
   title: String
   message: String
}

export interface CompanyCreateOneInput {
   create?: Maybe<CompanyCreateInput>
   connect?: Maybe<CompanyWhereUniqueInput>
}

export interface TestCreateManyInput {
   create?: Maybe<TestCreateInput[] | TestCreateInput>
   connect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
}

export interface StepCreateManyInput {
   create?: Maybe<StepCreateInput[] | StepCreateInput>
   connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
}

export interface ViewUpdateInput {
   welcome?: Maybe<WelcomeUpdateOneRequiredInput>
   company?: Maybe<CompanyUpdateOneRequiredInput>
   menus?: Maybe<MenuUpdateManyInput>
   tests?: Maybe<TestUpdateManyInput>
   steps?: Maybe<StepUpdateManyInput>
}

export interface WelcomeUpdateOneRequiredInput {
   create?: Maybe<WelcomeCreateInput>
   update?: Maybe<WelcomeUpdateDataInput>
   upsert?: Maybe<WelcomeUpsertNestedInput>
   connect?: Maybe<WelcomeWhereUniqueInput>
}

export interface WelcomeUpdateDataInput {
   title?: Maybe<String>
   message?: Maybe<String>
}

export interface WelcomeUpsertNestedInput {
   update: WelcomeUpdateDataInput
   create: WelcomeCreateInput
}

export interface CompanyUpdateOneRequiredInput {
   create?: Maybe<CompanyCreateInput>
   update?: Maybe<CompanyUpdateDataInput>
   upsert?: Maybe<CompanyUpsertNestedInput>
   connect?: Maybe<CompanyWhereUniqueInput>
}

export interface CompanyUpdateDataInput {
   name?: Maybe<String>
   abbr?: Maybe<String>
   logo?: Maybe<String>
}

export interface CompanyUpsertNestedInput {
   update: CompanyUpdateDataInput
   create: CompanyCreateInput
}

export interface TestUpdateManyInput {
   create?: Maybe<TestCreateInput[] | TestCreateInput>
   update?: Maybe<
      | TestUpdateWithWhereUniqueNestedInput[]
      | TestUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | TestUpsertWithWhereUniqueNestedInput[]
      | TestUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
   connect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
   set?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
   disconnect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
   deleteMany?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
   updateMany?: Maybe<
      TestUpdateManyWithWhereNestedInput[] | TestUpdateManyWithWhereNestedInput
   >
}

export interface TestUpdateWithWhereUniqueNestedInput {
   where: TestWhereUniqueInput
   data: TestUpdateDataInput
}

export interface TestUpdateDataInput {
   title?: Maybe<String>
   steps?: Maybe<StepUpdateManyWithoutParentInput>
   menus?: Maybe<MenuUpdateManyInput>
   results?: Maybe<TestResultUpdateManyWithoutParentInput>
}

export interface TestUpsertWithWhereUniqueNestedInput {
   where: TestWhereUniqueInput
   update: TestUpdateDataInput
   create: TestCreateInput
}

export interface TestScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   AND?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
   OR?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
   NOT?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
}

export interface TestUpdateManyWithWhereNestedInput {
   where: TestScalarWhereInput
   data: TestUpdateManyDataInput
}

export interface TestUpdateManyDataInput {
   title?: Maybe<String>
}

export interface StepUpdateManyInput {
   create?: Maybe<StepCreateInput[] | StepCreateInput>
   update?: Maybe<
      | StepUpdateWithWhereUniqueNestedInput[]
      | StepUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | StepUpsertWithWhereUniqueNestedInput[]
      | StepUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   set?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   disconnect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
   deleteMany?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
   updateMany?: Maybe<
      StepUpdateManyWithWhereNestedInput[] | StepUpdateManyWithWhereNestedInput
   >
}

export interface StepUpdateWithWhereUniqueNestedInput {
   where: StepWhereUniqueInput
   data: StepUpdateDataInput
}

export interface StepUpdateDataInput {
   parent?: Maybe<TestUpdateOneWithoutStepsInput>
   type?: Maybe<KeyUserTypeUpdateManyWithoutStepsInput>
   question?: Maybe<String>
   targets?: Maybe<MenuUpdateManyInput>
   paths?: Maybe<PathUpdateManyWithoutParentInput>
   results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface StepUpsertWithWhereUniqueNestedInput {
   where: StepWhereUniqueInput
   update: StepUpdateDataInput
   create: StepCreateInput
}

export interface WelcomeUpdateInput {
   title?: Maybe<String>
   message?: Maybe<String>
}

export interface WelcomeUpdateManyMutationInput {
   title?: Maybe<String>
   message?: Maybe<String>
}

export interface CompanySubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<CompanyWhereInput>
   AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>
}

export interface KeyResultStatusSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<KeyResultStatusWhereInput>
   AND?: Maybe<
      | KeyResultStatusSubscriptionWhereInput[]
      | KeyResultStatusSubscriptionWhereInput
   >
}

export interface KeyUserTypeSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<KeyUserTypeWhereInput>
   AND?: Maybe<
      KeyUserTypeSubscriptionWhereInput[] | KeyUserTypeSubscriptionWhereInput
   >
}

export interface KeysSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<KeysWhereInput>
   AND?: Maybe<KeysSubscriptionWhereInput[] | KeysSubscriptionWhereInput>
}

export interface MenuSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<MenuWhereInput>
   AND?: Maybe<MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput>
}

export interface PathSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<PathWhereInput>
   AND?: Maybe<PathSubscriptionWhereInput[] | PathSubscriptionWhereInput>
}

export interface StepSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<StepWhereInput>
   AND?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>
}

export interface StepResultSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<StepResultWhereInput>
   AND?: Maybe<
      StepResultSubscriptionWhereInput[] | StepResultSubscriptionWhereInput
   >
}

export interface TestSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<TestWhereInput>
   AND?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>
}

export interface TestResultSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<TestResultWhereInput>
   AND?: Maybe<
      TestResultSubscriptionWhereInput[] | TestResultSubscriptionWhereInput
   >
}

export interface TimeResultSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<TimeResultWhereInput>
   AND?: Maybe<
      TimeResultSubscriptionWhereInput[] | TimeResultSubscriptionWhereInput
   >
}

export interface ViewSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<ViewWhereInput>
   AND?: Maybe<ViewSubscriptionWhereInput[] | ViewSubscriptionWhereInput>
}

export interface WelcomeSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<WelcomeWhereInput>
   AND?: Maybe<WelcomeSubscriptionWhereInput[] | WelcomeSubscriptionWhereInput>
}

export interface NodeNode {
   id: ID_Output
}

export interface Company {
   id: ID_Output
   name: String
   abbr?: String
   logo?: String
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
   id: () => Promise<ID_Output>
   name: () => Promise<String>
   abbr: () => Promise<String>
   logo: () => Promise<String>
}

export interface CompanySubscription
   extends Promise<AsyncIterator<Company>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   name: () => Promise<AsyncIterator<String>>
   abbr: () => Promise<AsyncIterator<String>>
   logo: () => Promise<AsyncIterator<String>>
}

export interface CompanyNullablePromise
   extends Promise<Company | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   name: () => Promise<String>
   abbr: () => Promise<String>
   logo: () => Promise<String>
}

export interface CompanyConnection {
   pageInfo: PageInfo
   edges: CompanyEdge[]
}

export interface CompanyConnectionPromise
   extends Promise<CompanyConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<CompanyEdge>>() => T
   aggregate: <T = AggregateCompanyPromise>() => T
}

export interface CompanyConnectionSubscription
   extends Promise<AsyncIterator<CompanyConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T
   aggregate: <T = AggregateCompanySubscription>() => T
}

export interface PageInfo {
   hasNextPage: Boolean
   hasPreviousPage: Boolean
   startCursor?: String
   endCursor?: String
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
   hasNextPage: () => Promise<Boolean>
   hasPreviousPage: () => Promise<Boolean>
   startCursor: () => Promise<String>
   endCursor: () => Promise<String>
}

export interface PageInfoSubscription
   extends Promise<AsyncIterator<PageInfo>>,
      Fragmentable {
   hasNextPage: () => Promise<AsyncIterator<Boolean>>
   hasPreviousPage: () => Promise<AsyncIterator<Boolean>>
   startCursor: () => Promise<AsyncIterator<String>>
   endCursor: () => Promise<AsyncIterator<String>>
}

export interface CompanyEdge {
   node: Company
   cursor: String
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
   node: <T = CompanyPromise>() => T
   cursor: () => Promise<String>
}

export interface CompanyEdgeSubscription
   extends Promise<AsyncIterator<CompanyEdge>>,
      Fragmentable {
   node: <T = CompanySubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateCompany {
   count: Int
}

export interface AggregateCompanyPromise
   extends Promise<AggregateCompany>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateCompanySubscription
   extends Promise<AsyncIterator<AggregateCompany>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface KeyResultStatus {
   id: ID_Output
   key: String
}

export interface KeyResultStatusPromise
   extends Promise<KeyResultStatus>,
      Fragmentable {
   id: () => Promise<ID_Output>
   key: () => Promise<String>
   results: <T = FragmentableArray<TestResult>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface KeyResultStatusSubscription
   extends Promise<AsyncIterator<KeyResultStatus>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   key: () => Promise<AsyncIterator<String>>
   results: <T = Promise<AsyncIterator<TestResultSubscription>>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface KeyResultStatusNullablePromise
   extends Promise<KeyResultStatus | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   key: () => Promise<String>
   results: <T = FragmentableArray<TestResult>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface TestResult {
   id: ID_Output
   start: DateTimeOutput
   end?: DateTimeOutput
}

export interface TestResultPromise extends Promise<TestResult>, Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = TestPromise>() => T
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   time: <T = TimeResultPromise>() => T
   steps: <T = FragmentableArray<StepResult>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: <T = KeyResultStatusPromise>() => T
}

export interface TestResultSubscription
   extends Promise<AsyncIterator<TestResult>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   parent: <T = TestSubscription>() => T
   start: () => Promise<AsyncIterator<DateTimeOutput>>
   end: () => Promise<AsyncIterator<DateTimeOutput>>
   time: <T = TimeResultSubscription>() => T
   steps: <T = Promise<AsyncIterator<StepResultSubscription>>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: <T = KeyResultStatusSubscription>() => T
}

export interface TestResultNullablePromise
   extends Promise<TestResult | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = TestPromise>() => T
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   time: <T = TimeResultPromise>() => T
   steps: <T = FragmentableArray<StepResult>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: <T = KeyResultStatusPromise>() => T
}

export interface Test {
   id: ID_Output
   title: String
}

export interface TestPromise extends Promise<Test>, Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = FragmentableArray<TestResult>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface TestSubscription
   extends Promise<AsyncIterator<Test>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   title: () => Promise<AsyncIterator<String>>
   steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = Promise<AsyncIterator<TestResultSubscription>>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface TestNullablePromise
   extends Promise<Test | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = FragmentableArray<TestResult>>(args?: {
      where?: TestResultWhereInput
      orderBy?: TestResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface Step {
   id: ID_Output
   question: String
}

export interface StepPromise extends Promise<Step>, Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = TestPromise>() => T
   type: <T = FragmentableArray<KeyUserType>>(args?: {
      where?: KeyUserTypeWhereInput
      orderBy?: KeyUserTypeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   question: () => Promise<String>
   targets: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   paths: <T = FragmentableArray<Path>>(args?: {
      where?: PathWhereInput
      orderBy?: PathOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = FragmentableArray<StepResult>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface StepSubscription
   extends Promise<AsyncIterator<Step>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   parent: <T = TestSubscription>() => T
   type: <T = Promise<AsyncIterator<KeyUserTypeSubscription>>>(args?: {
      where?: KeyUserTypeWhereInput
      orderBy?: KeyUserTypeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   question: () => Promise<AsyncIterator<String>>
   targets: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   paths: <T = Promise<AsyncIterator<PathSubscription>>>(args?: {
      where?: PathWhereInput
      orderBy?: PathOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = Promise<AsyncIterator<StepResultSubscription>>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface StepNullablePromise
   extends Promise<Step | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = TestPromise>() => T
   type: <T = FragmentableArray<KeyUserType>>(args?: {
      where?: KeyUserTypeWhereInput
      orderBy?: KeyUserTypeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   question: () => Promise<String>
   targets: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   paths: <T = FragmentableArray<Path>>(args?: {
      where?: PathWhereInput
      orderBy?: PathOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   results: <T = FragmentableArray<StepResult>>(args?: {
      where?: StepResultWhereInput
      orderBy?: StepResultOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface KeyUserType {
   id: ID_Output
   key: String
}

export interface KeyUserTypePromise extends Promise<KeyUserType>, Fragmentable {
   id: () => Promise<ID_Output>
   key: () => Promise<String>
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface KeyUserTypeSubscription
   extends Promise<AsyncIterator<KeyUserType>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   key: () => Promise<AsyncIterator<String>>
   steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface KeyUserTypeNullablePromise
   extends Promise<KeyUserType | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   key: () => Promise<String>
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface Menu {
   id: ID_Output
   root: Boolean
   name: String
}

export interface MenuPromise extends Promise<Menu>, Fragmentable {
   id: () => Promise<ID_Output>
   root: () => Promise<Boolean>
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   name: () => Promise<String>
   items: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface MenuSubscription
   extends Promise<AsyncIterator<Menu>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   root: () => Promise<AsyncIterator<Boolean>>
   menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   name: () => Promise<AsyncIterator<String>>
   items: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface MenuNullablePromise
   extends Promise<Menu | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   root: () => Promise<Boolean>
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   name: () => Promise<String>
   items: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface Path {
   id: ID_Output
}

export interface PathPromise extends Promise<Path>, Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = StepPromise>() => T
   paths: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface PathSubscription
   extends Promise<AsyncIterator<Path>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   parent: <T = StepSubscription>() => T
   paths: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface PathNullablePromise
   extends Promise<Path | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = StepPromise>() => T
   paths: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface StepResult {
   id: ID_Output
   start: DateTimeOutput
   end?: DateTimeOutput
}

export interface StepResultPromise extends Promise<StepResult>, Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = StepPromise>() => T
   resultParent: <T = TestResultPromise>() => T
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   time: <T = TimeResultPromise>() => T
   path: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: <T = KeyResultStatusPromise>() => T
}

export interface StepResultSubscription
   extends Promise<AsyncIterator<StepResult>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   parent: <T = StepSubscription>() => T
   resultParent: <T = TestResultSubscription>() => T
   start: () => Promise<AsyncIterator<DateTimeOutput>>
   end: () => Promise<AsyncIterator<DateTimeOutput>>
   time: <T = TimeResultSubscription>() => T
   path: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: <T = KeyResultStatusSubscription>() => T
}

export interface StepResultNullablePromise
   extends Promise<StepResult | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   parent: <T = StepPromise>() => T
   resultParent: <T = TestResultPromise>() => T
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
   time: <T = TimeResultPromise>() => T
   path: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   status: <T = KeyResultStatusPromise>() => T
}

export interface TimeResult {
   id: ID_Output
   int: Int
   text: String
}

export interface TimeResultPromise extends Promise<TimeResult>, Fragmentable {
   id: () => Promise<ID_Output>
   int: () => Promise<Int>
   text: () => Promise<String>
}

export interface TimeResultSubscription
   extends Promise<AsyncIterator<TimeResult>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   int: () => Promise<AsyncIterator<Int>>
   text: () => Promise<AsyncIterator<String>>
}

export interface TimeResultNullablePromise
   extends Promise<TimeResult | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   int: () => Promise<Int>
   text: () => Promise<String>
}

export interface KeyResultStatusConnection {
   pageInfo: PageInfo
   edges: KeyResultStatusEdge[]
}

export interface KeyResultStatusConnectionPromise
   extends Promise<KeyResultStatusConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<KeyResultStatusEdge>>() => T
   aggregate: <T = AggregateKeyResultStatusPromise>() => T
}

export interface KeyResultStatusConnectionSubscription
   extends Promise<AsyncIterator<KeyResultStatusConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<KeyResultStatusEdgeSubscription>>>() => T
   aggregate: <T = AggregateKeyResultStatusSubscription>() => T
}

export interface KeyResultStatusEdge {
   node: KeyResultStatus
   cursor: String
}

export interface KeyResultStatusEdgePromise
   extends Promise<KeyResultStatusEdge>,
      Fragmentable {
   node: <T = KeyResultStatusPromise>() => T
   cursor: () => Promise<String>
}

export interface KeyResultStatusEdgeSubscription
   extends Promise<AsyncIterator<KeyResultStatusEdge>>,
      Fragmentable {
   node: <T = KeyResultStatusSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateKeyResultStatus {
   count: Int
}

export interface AggregateKeyResultStatusPromise
   extends Promise<AggregateKeyResultStatus>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateKeyResultStatusSubscription
   extends Promise<AsyncIterator<AggregateKeyResultStatus>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface KeyUserTypeConnection {
   pageInfo: PageInfo
   edges: KeyUserTypeEdge[]
}

export interface KeyUserTypeConnectionPromise
   extends Promise<KeyUserTypeConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<KeyUserTypeEdge>>() => T
   aggregate: <T = AggregateKeyUserTypePromise>() => T
}

export interface KeyUserTypeConnectionSubscription
   extends Promise<AsyncIterator<KeyUserTypeConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<KeyUserTypeEdgeSubscription>>>() => T
   aggregate: <T = AggregateKeyUserTypeSubscription>() => T
}

export interface KeyUserTypeEdge {
   node: KeyUserType
   cursor: String
}

export interface KeyUserTypeEdgePromise
   extends Promise<KeyUserTypeEdge>,
      Fragmentable {
   node: <T = KeyUserTypePromise>() => T
   cursor: () => Promise<String>
}

export interface KeyUserTypeEdgeSubscription
   extends Promise<AsyncIterator<KeyUserTypeEdge>>,
      Fragmentable {
   node: <T = KeyUserTypeSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateKeyUserType {
   count: Int
}

export interface AggregateKeyUserTypePromise
   extends Promise<AggregateKeyUserType>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateKeyUserTypeSubscription
   extends Promise<AsyncIterator<AggregateKeyUserType>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface Keys {
   id: ID_Output
}

export interface KeysPromise extends Promise<Keys>, Fragmentable {
   id: () => Promise<ID_Output>
   userType: <T = FragmentableArray<KeyUserType>>(args?: {
      where?: KeyUserTypeWhereInput
      orderBy?: KeyUserTypeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   resultStatus: <T = FragmentableArray<KeyResultStatus>>(args?: {
      where?: KeyResultStatusWhereInput
      orderBy?: KeyResultStatusOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface KeysSubscription
   extends Promise<AsyncIterator<Keys>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   userType: <T = Promise<AsyncIterator<KeyUserTypeSubscription>>>(args?: {
      where?: KeyUserTypeWhereInput
      orderBy?: KeyUserTypeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   resultStatus: <
      T = Promise<AsyncIterator<KeyResultStatusSubscription>>
   >(args?: {
      where?: KeyResultStatusWhereInput
      orderBy?: KeyResultStatusOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface KeysNullablePromise
   extends Promise<Keys | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   userType: <T = FragmentableArray<KeyUserType>>(args?: {
      where?: KeyUserTypeWhereInput
      orderBy?: KeyUserTypeOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   resultStatus: <T = FragmentableArray<KeyResultStatus>>(args?: {
      where?: KeyResultStatusWhereInput
      orderBy?: KeyResultStatusOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface KeysConnection {
   pageInfo: PageInfo
   edges: KeysEdge[]
}

export interface KeysConnectionPromise
   extends Promise<KeysConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<KeysEdge>>() => T
   aggregate: <T = AggregateKeysPromise>() => T
}

export interface KeysConnectionSubscription
   extends Promise<AsyncIterator<KeysConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<KeysEdgeSubscription>>>() => T
   aggregate: <T = AggregateKeysSubscription>() => T
}

export interface KeysEdge {
   node: Keys
   cursor: String
}

export interface KeysEdgePromise extends Promise<KeysEdge>, Fragmentable {
   node: <T = KeysPromise>() => T
   cursor: () => Promise<String>
}

export interface KeysEdgeSubscription
   extends Promise<AsyncIterator<KeysEdge>>,
      Fragmentable {
   node: <T = KeysSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateKeys {
   count: Int
}

export interface AggregateKeysPromise
   extends Promise<AggregateKeys>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateKeysSubscription
   extends Promise<AsyncIterator<AggregateKeys>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface MenuConnection {
   pageInfo: PageInfo
   edges: MenuEdge[]
}

export interface MenuConnectionPromise
   extends Promise<MenuConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<MenuEdge>>() => T
   aggregate: <T = AggregateMenuPromise>() => T
}

export interface MenuConnectionSubscription
   extends Promise<AsyncIterator<MenuConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<MenuEdgeSubscription>>>() => T
   aggregate: <T = AggregateMenuSubscription>() => T
}

export interface MenuEdge {
   node: Menu
   cursor: String
}

export interface MenuEdgePromise extends Promise<MenuEdge>, Fragmentable {
   node: <T = MenuPromise>() => T
   cursor: () => Promise<String>
}

export interface MenuEdgeSubscription
   extends Promise<AsyncIterator<MenuEdge>>,
      Fragmentable {
   node: <T = MenuSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateMenu {
   count: Int
}

export interface AggregateMenuPromise
   extends Promise<AggregateMenu>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateMenuSubscription
   extends Promise<AsyncIterator<AggregateMenu>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface PathConnection {
   pageInfo: PageInfo
   edges: PathEdge[]
}

export interface PathConnectionPromise
   extends Promise<PathConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<PathEdge>>() => T
   aggregate: <T = AggregatePathPromise>() => T
}

export interface PathConnectionSubscription
   extends Promise<AsyncIterator<PathConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<PathEdgeSubscription>>>() => T
   aggregate: <T = AggregatePathSubscription>() => T
}

export interface PathEdge {
   node: Path
   cursor: String
}

export interface PathEdgePromise extends Promise<PathEdge>, Fragmentable {
   node: <T = PathPromise>() => T
   cursor: () => Promise<String>
}

export interface PathEdgeSubscription
   extends Promise<AsyncIterator<PathEdge>>,
      Fragmentable {
   node: <T = PathSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregatePath {
   count: Int
}

export interface AggregatePathPromise
   extends Promise<AggregatePath>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregatePathSubscription
   extends Promise<AsyncIterator<AggregatePath>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface StepConnection {
   pageInfo: PageInfo
   edges: StepEdge[]
}

export interface StepConnectionPromise
   extends Promise<StepConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<StepEdge>>() => T
   aggregate: <T = AggregateStepPromise>() => T
}

export interface StepConnectionSubscription
   extends Promise<AsyncIterator<StepConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<StepEdgeSubscription>>>() => T
   aggregate: <T = AggregateStepSubscription>() => T
}

export interface StepEdge {
   node: Step
   cursor: String
}

export interface StepEdgePromise extends Promise<StepEdge>, Fragmentable {
   node: <T = StepPromise>() => T
   cursor: () => Promise<String>
}

export interface StepEdgeSubscription
   extends Promise<AsyncIterator<StepEdge>>,
      Fragmentable {
   node: <T = StepSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateStep {
   count: Int
}

export interface AggregateStepPromise
   extends Promise<AggregateStep>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateStepSubscription
   extends Promise<AsyncIterator<AggregateStep>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface StepResultConnection {
   pageInfo: PageInfo
   edges: StepResultEdge[]
}

export interface StepResultConnectionPromise
   extends Promise<StepResultConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<StepResultEdge>>() => T
   aggregate: <T = AggregateStepResultPromise>() => T
}

export interface StepResultConnectionSubscription
   extends Promise<AsyncIterator<StepResultConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<StepResultEdgeSubscription>>>() => T
   aggregate: <T = AggregateStepResultSubscription>() => T
}

export interface StepResultEdge {
   node: StepResult
   cursor: String
}

export interface StepResultEdgePromise
   extends Promise<StepResultEdge>,
      Fragmentable {
   node: <T = StepResultPromise>() => T
   cursor: () => Promise<String>
}

export interface StepResultEdgeSubscription
   extends Promise<AsyncIterator<StepResultEdge>>,
      Fragmentable {
   node: <T = StepResultSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateStepResult {
   count: Int
}

export interface AggregateStepResultPromise
   extends Promise<AggregateStepResult>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateStepResultSubscription
   extends Promise<AsyncIterator<AggregateStepResult>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface TestConnection {
   pageInfo: PageInfo
   edges: TestEdge[]
}

export interface TestConnectionPromise
   extends Promise<TestConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<TestEdge>>() => T
   aggregate: <T = AggregateTestPromise>() => T
}

export interface TestConnectionSubscription
   extends Promise<AsyncIterator<TestConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<TestEdgeSubscription>>>() => T
   aggregate: <T = AggregateTestSubscription>() => T
}

export interface TestEdge {
   node: Test
   cursor: String
}

export interface TestEdgePromise extends Promise<TestEdge>, Fragmentable {
   node: <T = TestPromise>() => T
   cursor: () => Promise<String>
}

export interface TestEdgeSubscription
   extends Promise<AsyncIterator<TestEdge>>,
      Fragmentable {
   node: <T = TestSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTest {
   count: Int
}

export interface AggregateTestPromise
   extends Promise<AggregateTest>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateTestSubscription
   extends Promise<AsyncIterator<AggregateTest>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface TestResultConnection {
   pageInfo: PageInfo
   edges: TestResultEdge[]
}

export interface TestResultConnectionPromise
   extends Promise<TestResultConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<TestResultEdge>>() => T
   aggregate: <T = AggregateTestResultPromise>() => T
}

export interface TestResultConnectionSubscription
   extends Promise<AsyncIterator<TestResultConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<TestResultEdgeSubscription>>>() => T
   aggregate: <T = AggregateTestResultSubscription>() => T
}

export interface TestResultEdge {
   node: TestResult
   cursor: String
}

export interface TestResultEdgePromise
   extends Promise<TestResultEdge>,
      Fragmentable {
   node: <T = TestResultPromise>() => T
   cursor: () => Promise<String>
}

export interface TestResultEdgeSubscription
   extends Promise<AsyncIterator<TestResultEdge>>,
      Fragmentable {
   node: <T = TestResultSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTestResult {
   count: Int
}

export interface AggregateTestResultPromise
   extends Promise<AggregateTestResult>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateTestResultSubscription
   extends Promise<AsyncIterator<AggregateTestResult>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface TimeResultConnection {
   pageInfo: PageInfo
   edges: TimeResultEdge[]
}

export interface TimeResultConnectionPromise
   extends Promise<TimeResultConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<TimeResultEdge>>() => T
   aggregate: <T = AggregateTimeResultPromise>() => T
}

export interface TimeResultConnectionSubscription
   extends Promise<AsyncIterator<TimeResultConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<TimeResultEdgeSubscription>>>() => T
   aggregate: <T = AggregateTimeResultSubscription>() => T
}

export interface TimeResultEdge {
   node: TimeResult
   cursor: String
}

export interface TimeResultEdgePromise
   extends Promise<TimeResultEdge>,
      Fragmentable {
   node: <T = TimeResultPromise>() => T
   cursor: () => Promise<String>
}

export interface TimeResultEdgeSubscription
   extends Promise<AsyncIterator<TimeResultEdge>>,
      Fragmentable {
   node: <T = TimeResultSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTimeResult {
   count: Int
}

export interface AggregateTimeResultPromise
   extends Promise<AggregateTimeResult>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateTimeResultSubscription
   extends Promise<AsyncIterator<AggregateTimeResult>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface View {
   id: ID_Output
}

export interface ViewPromise extends Promise<View>, Fragmentable {
   id: () => Promise<ID_Output>
   welcome: <T = WelcomePromise>() => T
   company: <T = CompanyPromise>() => T
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   tests: <T = FragmentableArray<Test>>(args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface ViewSubscription
   extends Promise<AsyncIterator<View>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   welcome: <T = WelcomeSubscription>() => T
   company: <T = CompanySubscription>() => T
   menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   tests: <T = Promise<AsyncIterator<TestSubscription>>>(args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface ViewNullablePromise
   extends Promise<View | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   welcome: <T = WelcomePromise>() => T
   company: <T = CompanyPromise>() => T
   menus: <T = FragmentableArray<Menu>>(args?: {
      where?: MenuWhereInput
      orderBy?: MenuOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   tests: <T = FragmentableArray<Test>>(args?: {
      where?: TestWhereInput
      orderBy?: TestOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   steps: <T = FragmentableArray<Step>>(args?: {
      where?: StepWhereInput
      orderBy?: StepOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
}

export interface Welcome {
   id: ID_Output
   title: String
   message: String
}

export interface WelcomePromise extends Promise<Welcome>, Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   message: () => Promise<String>
}

export interface WelcomeSubscription
   extends Promise<AsyncIterator<Welcome>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   title: () => Promise<AsyncIterator<String>>
   message: () => Promise<AsyncIterator<String>>
}

export interface WelcomeNullablePromise
   extends Promise<Welcome | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   message: () => Promise<String>
}

export interface ViewConnection {
   pageInfo: PageInfo
   edges: ViewEdge[]
}

export interface ViewConnectionPromise
   extends Promise<ViewConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<ViewEdge>>() => T
   aggregate: <T = AggregateViewPromise>() => T
}

export interface ViewConnectionSubscription
   extends Promise<AsyncIterator<ViewConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<ViewEdgeSubscription>>>() => T
   aggregate: <T = AggregateViewSubscription>() => T
}

export interface ViewEdge {
   node: View
   cursor: String
}

export interface ViewEdgePromise extends Promise<ViewEdge>, Fragmentable {
   node: <T = ViewPromise>() => T
   cursor: () => Promise<String>
}

export interface ViewEdgeSubscription
   extends Promise<AsyncIterator<ViewEdge>>,
      Fragmentable {
   node: <T = ViewSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateView {
   count: Int
}

export interface AggregateViewPromise
   extends Promise<AggregateView>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateViewSubscription
   extends Promise<AsyncIterator<AggregateView>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface WelcomeConnection {
   pageInfo: PageInfo
   edges: WelcomeEdge[]
}

export interface WelcomeConnectionPromise
   extends Promise<WelcomeConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<WelcomeEdge>>() => T
   aggregate: <T = AggregateWelcomePromise>() => T
}

export interface WelcomeConnectionSubscription
   extends Promise<AsyncIterator<WelcomeConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<WelcomeEdgeSubscription>>>() => T
   aggregate: <T = AggregateWelcomeSubscription>() => T
}

export interface WelcomeEdge {
   node: Welcome
   cursor: String
}

export interface WelcomeEdgePromise extends Promise<WelcomeEdge>, Fragmentable {
   node: <T = WelcomePromise>() => T
   cursor: () => Promise<String>
}

export interface WelcomeEdgeSubscription
   extends Promise<AsyncIterator<WelcomeEdge>>,
      Fragmentable {
   node: <T = WelcomeSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateWelcome {
   count: Int
}

export interface AggregateWelcomePromise
   extends Promise<AggregateWelcome>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateWelcomeSubscription
   extends Promise<AsyncIterator<AggregateWelcome>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface BatchPayload {
   count: Long
}

export interface BatchPayloadPromise
   extends Promise<BatchPayload>,
      Fragmentable {
   count: () => Promise<Long>
}

export interface BatchPayloadSubscription
   extends Promise<AsyncIterator<BatchPayload>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Long>>
}

export interface CompanySubscriptionPayload {
   mutation: MutationType
   node: Company
   updatedFields: String[]
   previousValues: CompanyPreviousValues
}

export interface CompanySubscriptionPayloadPromise
   extends Promise<CompanySubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = CompanyPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = CompanyPreviousValuesPromise>() => T
}

export interface CompanySubscriptionPayloadSubscription
   extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = CompanySubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = CompanyPreviousValuesSubscription>() => T
}

export interface CompanyPreviousValues {
   id: ID_Output
   name: String
   abbr?: String
   logo?: String
}

export interface CompanyPreviousValuesPromise
   extends Promise<CompanyPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   name: () => Promise<String>
   abbr: () => Promise<String>
   logo: () => Promise<String>
}

export interface CompanyPreviousValuesSubscription
   extends Promise<AsyncIterator<CompanyPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   name: () => Promise<AsyncIterator<String>>
   abbr: () => Promise<AsyncIterator<String>>
   logo: () => Promise<AsyncIterator<String>>
}

export interface KeyResultStatusSubscriptionPayload {
   mutation: MutationType
   node: KeyResultStatus
   updatedFields: String[]
   previousValues: KeyResultStatusPreviousValues
}

export interface KeyResultStatusSubscriptionPayloadPromise
   extends Promise<KeyResultStatusSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = KeyResultStatusPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = KeyResultStatusPreviousValuesPromise>() => T
}

export interface KeyResultStatusSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<KeyResultStatusSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = KeyResultStatusSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = KeyResultStatusPreviousValuesSubscription>() => T
}

export interface KeyResultStatusPreviousValues {
   id: ID_Output
   key: String
}

export interface KeyResultStatusPreviousValuesPromise
   extends Promise<KeyResultStatusPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   key: () => Promise<String>
}

export interface KeyResultStatusPreviousValuesSubscription
   extends Promise<AsyncIterator<KeyResultStatusPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   key: () => Promise<AsyncIterator<String>>
}

export interface KeyUserTypeSubscriptionPayload {
   mutation: MutationType
   node: KeyUserType
   updatedFields: String[]
   previousValues: KeyUserTypePreviousValues
}

export interface KeyUserTypeSubscriptionPayloadPromise
   extends Promise<KeyUserTypeSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = KeyUserTypePromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = KeyUserTypePreviousValuesPromise>() => T
}

export interface KeyUserTypeSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<KeyUserTypeSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = KeyUserTypeSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = KeyUserTypePreviousValuesSubscription>() => T
}

export interface KeyUserTypePreviousValues {
   id: ID_Output
   key: String
}

export interface KeyUserTypePreviousValuesPromise
   extends Promise<KeyUserTypePreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   key: () => Promise<String>
}

export interface KeyUserTypePreviousValuesSubscription
   extends Promise<AsyncIterator<KeyUserTypePreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   key: () => Promise<AsyncIterator<String>>
}

export interface KeysSubscriptionPayload {
   mutation: MutationType
   node: Keys
   updatedFields: String[]
   previousValues: KeysPreviousValues
}

export interface KeysSubscriptionPayloadPromise
   extends Promise<KeysSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = KeysPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = KeysPreviousValuesPromise>() => T
}

export interface KeysSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<KeysSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = KeysSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = KeysPreviousValuesSubscription>() => T
}

export interface KeysPreviousValues {
   id: ID_Output
}

export interface KeysPreviousValuesPromise
   extends Promise<KeysPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
}

export interface KeysPreviousValuesSubscription
   extends Promise<AsyncIterator<KeysPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
}

export interface MenuSubscriptionPayload {
   mutation: MutationType
   node: Menu
   updatedFields: String[]
   previousValues: MenuPreviousValues
}

export interface MenuSubscriptionPayloadPromise
   extends Promise<MenuSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = MenuPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = MenuPreviousValuesPromise>() => T
}

export interface MenuSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<MenuSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = MenuSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = MenuPreviousValuesSubscription>() => T
}

export interface MenuPreviousValues {
   id: ID_Output
   root: Boolean
   name: String
}

export interface MenuPreviousValuesPromise
   extends Promise<MenuPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   root: () => Promise<Boolean>
   name: () => Promise<String>
}

export interface MenuPreviousValuesSubscription
   extends Promise<AsyncIterator<MenuPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   root: () => Promise<AsyncIterator<Boolean>>
   name: () => Promise<AsyncIterator<String>>
}

export interface PathSubscriptionPayload {
   mutation: MutationType
   node: Path
   updatedFields: String[]
   previousValues: PathPreviousValues
}

export interface PathSubscriptionPayloadPromise
   extends Promise<PathSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = PathPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = PathPreviousValuesPromise>() => T
}

export interface PathSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<PathSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = PathSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = PathPreviousValuesSubscription>() => T
}

export interface PathPreviousValues {
   id: ID_Output
}

export interface PathPreviousValuesPromise
   extends Promise<PathPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
}

export interface PathPreviousValuesSubscription
   extends Promise<AsyncIterator<PathPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
}

export interface StepSubscriptionPayload {
   mutation: MutationType
   node: Step
   updatedFields: String[]
   previousValues: StepPreviousValues
}

export interface StepSubscriptionPayloadPromise
   extends Promise<StepSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = StepPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = StepPreviousValuesPromise>() => T
}

export interface StepSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<StepSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = StepSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = StepPreviousValuesSubscription>() => T
}

export interface StepPreviousValues {
   id: ID_Output
   question: String
}

export interface StepPreviousValuesPromise
   extends Promise<StepPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   question: () => Promise<String>
}

export interface StepPreviousValuesSubscription
   extends Promise<AsyncIterator<StepPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   question: () => Promise<AsyncIterator<String>>
}

export interface StepResultSubscriptionPayload {
   mutation: MutationType
   node: StepResult
   updatedFields: String[]
   previousValues: StepResultPreviousValues
}

export interface StepResultSubscriptionPayloadPromise
   extends Promise<StepResultSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = StepResultPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = StepResultPreviousValuesPromise>() => T
}

export interface StepResultSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<StepResultSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = StepResultSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = StepResultPreviousValuesSubscription>() => T
}

export interface StepResultPreviousValues {
   id: ID_Output
   start: DateTimeOutput
   end?: DateTimeOutput
}

export interface StepResultPreviousValuesPromise
   extends Promise<StepResultPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
}

export interface StepResultPreviousValuesSubscription
   extends Promise<AsyncIterator<StepResultPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   start: () => Promise<AsyncIterator<DateTimeOutput>>
   end: () => Promise<AsyncIterator<DateTimeOutput>>
}

export interface TestSubscriptionPayload {
   mutation: MutationType
   node: Test
   updatedFields: String[]
   previousValues: TestPreviousValues
}

export interface TestSubscriptionPayloadPromise
   extends Promise<TestSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = TestPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = TestPreviousValuesPromise>() => T
}

export interface TestSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<TestSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = TestSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = TestPreviousValuesSubscription>() => T
}

export interface TestPreviousValues {
   id: ID_Output
   title: String
}

export interface TestPreviousValuesPromise
   extends Promise<TestPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
}

export interface TestPreviousValuesSubscription
   extends Promise<AsyncIterator<TestPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   title: () => Promise<AsyncIterator<String>>
}

export interface TestResultSubscriptionPayload {
   mutation: MutationType
   node: TestResult
   updatedFields: String[]
   previousValues: TestResultPreviousValues
}

export interface TestResultSubscriptionPayloadPromise
   extends Promise<TestResultSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = TestResultPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = TestResultPreviousValuesPromise>() => T
}

export interface TestResultSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<TestResultSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = TestResultSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = TestResultPreviousValuesSubscription>() => T
}

export interface TestResultPreviousValues {
   id: ID_Output
   start: DateTimeOutput
   end?: DateTimeOutput
}

export interface TestResultPreviousValuesPromise
   extends Promise<TestResultPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   start: () => Promise<DateTimeOutput>
   end: () => Promise<DateTimeOutput>
}

export interface TestResultPreviousValuesSubscription
   extends Promise<AsyncIterator<TestResultPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   start: () => Promise<AsyncIterator<DateTimeOutput>>
   end: () => Promise<AsyncIterator<DateTimeOutput>>
}

export interface TimeResultSubscriptionPayload {
   mutation: MutationType
   node: TimeResult
   updatedFields: String[]
   previousValues: TimeResultPreviousValues
}

export interface TimeResultSubscriptionPayloadPromise
   extends Promise<TimeResultSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = TimeResultPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = TimeResultPreviousValuesPromise>() => T
}

export interface TimeResultSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<TimeResultSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = TimeResultSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = TimeResultPreviousValuesSubscription>() => T
}

export interface TimeResultPreviousValues {
   id: ID_Output
   int: Int
   text: String
}

export interface TimeResultPreviousValuesPromise
   extends Promise<TimeResultPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   int: () => Promise<Int>
   text: () => Promise<String>
}

export interface TimeResultPreviousValuesSubscription
   extends Promise<AsyncIterator<TimeResultPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   int: () => Promise<AsyncIterator<Int>>
   text: () => Promise<AsyncIterator<String>>
}

export interface ViewSubscriptionPayload {
   mutation: MutationType
   node: View
   updatedFields: String[]
   previousValues: ViewPreviousValues
}

export interface ViewSubscriptionPayloadPromise
   extends Promise<ViewSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = ViewPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = ViewPreviousValuesPromise>() => T
}

export interface ViewSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<ViewSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = ViewSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = ViewPreviousValuesSubscription>() => T
}

export interface ViewPreviousValues {
   id: ID_Output
}

export interface ViewPreviousValuesPromise
   extends Promise<ViewPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
}

export interface ViewPreviousValuesSubscription
   extends Promise<AsyncIterator<ViewPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
}

export interface WelcomeSubscriptionPayload {
   mutation: MutationType
   node: Welcome
   updatedFields: String[]
   previousValues: WelcomePreviousValues
}

export interface WelcomeSubscriptionPayloadPromise
   extends Promise<WelcomeSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = WelcomePromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = WelcomePreviousValuesPromise>() => T
}

export interface WelcomeSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<WelcomeSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = WelcomeSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = WelcomePreviousValuesSubscription>() => T
}

export interface WelcomePreviousValues {
   id: ID_Output
   title: String
   message: String
}

export interface WelcomePreviousValuesPromise
   extends Promise<WelcomePreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   title: () => Promise<String>
   message: () => Promise<String>
}

export interface WelcomePreviousValuesSubscription
   extends Promise<AsyncIterator<WelcomePreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   title: () => Promise<AsyncIterator<String>>
   message: () => Promise<AsyncIterator<String>>
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number
export type ID_Output = string

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string

export type Long = string

/**
 * Model Metadata
 */

export const models: Model[] = [
   {
      name: 'View',
      embedded: false,
   },
   {
      name: 'Welcome',
      embedded: false,
   },
   {
      name: 'Company',
      embedded: false,
   },
   {
      name: 'Test',
      embedded: false,
   },
   {
      name: 'Menu',
      embedded: false,
   },
   {
      name: 'Path',
      embedded: false,
   },
   {
      name: 'Keys',
      embedded: false,
   },
   {
      name: 'KeyUserType',
      embedded: false,
   },
   {
      name: 'KeyResultStatus',
      embedded: false,
   },
   {
      name: 'Step',
      embedded: false,
   },
   {
      name: 'TestResult',
      embedded: false,
   },
   {
      name: 'TimeResult',
      embedded: false,
   },
   {
      name: 'StepResult',
      embedded: false,
   },
]

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
   typeDefs,
   models,
   endpoint: `http://localhost:4466`,
})
export const prisma = new Prisma()
