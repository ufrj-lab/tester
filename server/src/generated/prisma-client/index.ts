// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql'
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model,
} from 'prisma-client-lib'
import { typeDefs } from './prisma-schema'

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U]

export type Maybe<T> = T | undefined | null

export interface Exists {
  company: (where?: CompanyWhereInput) => Promise<boolean>
  key: (where?: KeyWhereInput) => Promise<boolean>
  keyLanguage: (where?: KeyLanguageWhereInput) => Promise<boolean>
  keyStepResultStatus: (
    where?: KeyStepResultStatusWhereInput,
  ) => Promise<boolean>
  keyTestResultStatus: (
    where?: KeyTestResultStatusWhereInput,
  ) => Promise<boolean>
  keyUserType: (where?: KeyUserTypeWhereInput) => Promise<boolean>
  menu: (where?: MenuWhereInput) => Promise<boolean>
  message: (where?: MessageWhereInput) => Promise<boolean>
  multiLanguageContent: (
    where?: MultiLanguageContentWhereInput,
  ) => Promise<boolean>
  path: (where?: PathWhereInput) => Promise<boolean>
  step: (where?: StepWhereInput) => Promise<boolean>
  stepResult: (where?: StepResultWhereInput) => Promise<boolean>
  test: (where?: TestWhereInput) => Promise<boolean>
  testResult: (where?: TestResultWhereInput) => Promise<boolean>
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>
}

export interface Prisma {
  $exists: Exists
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any },
  ) => Promise<T>

  /**
   * Queries
   */

  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise
  companies: (args?: {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Company>
  companiesConnection: (args?: {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => CompanyConnectionPromise
  key: (where: KeyWhereUniqueInput) => KeyNullablePromise
  keys: (args?: {
    where?: KeyWhereInput
    orderBy?: KeyOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Key>
  keysConnection: (args?: {
    where?: KeyWhereInput
    orderBy?: KeyOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => KeyConnectionPromise
  keyLanguage: (
    where: KeyLanguageWhereUniqueInput,
  ) => KeyLanguageNullablePromise
  keyLanguages: (args?: {
    where?: KeyLanguageWhereInput
    orderBy?: KeyLanguageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<KeyLanguage>
  keyLanguagesConnection: (args?: {
    where?: KeyLanguageWhereInput
    orderBy?: KeyLanguageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => KeyLanguageConnectionPromise
  keyStepResultStatus: (
    where: KeyStepResultStatusWhereUniqueInput,
  ) => KeyStepResultStatusNullablePromise
  keyStepResultStatuses: (args?: {
    where?: KeyStepResultStatusWhereInput
    orderBy?: KeyStepResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<KeyStepResultStatus>
  keyStepResultStatusesConnection: (args?: {
    where?: KeyStepResultStatusWhereInput
    orderBy?: KeyStepResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => KeyStepResultStatusConnectionPromise
  keyTestResultStatus: (
    where: KeyTestResultStatusWhereUniqueInput,
  ) => KeyTestResultStatusNullablePromise
  keyTestResultStatuses: (args?: {
    where?: KeyTestResultStatusWhereInput
    orderBy?: KeyTestResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<KeyTestResultStatus>
  keyTestResultStatusesConnection: (args?: {
    where?: KeyTestResultStatusWhereInput
    orderBy?: KeyTestResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => KeyTestResultStatusConnectionPromise
  keyUserType: (
    where: KeyUserTypeWhereUniqueInput,
  ) => KeyUserTypeNullablePromise
  keyUserTypes: (args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<KeyUserType>
  keyUserTypesConnection: (args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => KeyUserTypeConnectionPromise
  menu: (where: MenuWhereUniqueInput) => MenuNullablePromise
  menus: (args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Menu>
  menusConnection: (args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => MenuConnectionPromise
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise
  messages: (args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Message>
  messagesConnection: (args?: {
    where?: MessageWhereInput
    orderBy?: MessageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => MessageConnectionPromise
  multiLanguageContent: (
    where: MultiLanguageContentWhereUniqueInput,
  ) => MultiLanguageContentNullablePromise
  multiLanguageContents: (args?: {
    where?: MultiLanguageContentWhereInput
    orderBy?: MultiLanguageContentOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<MultiLanguageContent>
  multiLanguageContentsConnection: (args?: {
    where?: MultiLanguageContentWhereInput
    orderBy?: MultiLanguageContentOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => MultiLanguageContentConnectionPromise
  path: (where: PathWhereUniqueInput) => PathNullablePromise
  paths: (args?: {
    where?: PathWhereInput
    orderBy?: PathOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Path>
  pathsConnection: (args?: {
    where?: PathWhereInput
    orderBy?: PathOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => PathConnectionPromise
  step: (where: StepWhereUniqueInput) => StepNullablePromise
  steps: (args?: {
    where?: StepWhereInput
    orderBy?: StepOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Step>
  stepsConnection: (args?: {
    where?: StepWhereInput
    orderBy?: StepOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => StepConnectionPromise
  stepResult: (where: StepResultWhereUniqueInput) => StepResultNullablePromise
  stepResults: (args?: {
    where?: StepResultWhereInput
    orderBy?: StepResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<StepResult>
  stepResultsConnection: (args?: {
    where?: StepResultWhereInput
    orderBy?: StepResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => StepResultConnectionPromise
  test: (where: TestWhereUniqueInput) => TestNullablePromise
  tests: (args?: {
    where?: TestWhereInput
    orderBy?: TestOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<Test>
  testsConnection: (args?: {
    where?: TestWhereInput
    orderBy?: TestOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => TestConnectionPromise
  testResult: (where: TestResultWhereUniqueInput) => TestResultNullablePromise
  testResults: (args?: {
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => FragmentableArray<TestResult>
  testResultsConnection: (args?: {
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => TestResultConnectionPromise
  node: (args: { id: ID_Output }) => Node

  /**
   * Mutations
   */

  createCompany: (data: CompanyCreateInput) => CompanyPromise
  updateCompany: (args: {
    data: CompanyUpdateInput
    where: CompanyWhereUniqueInput
  }) => CompanyPromise
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput
    where?: CompanyWhereInput
  }) => BatchPayloadPromise
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput
    create: CompanyCreateInput
    update: CompanyUpdateInput
  }) => CompanyPromise
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise
  createKey: (data: KeyCreateInput) => KeyPromise
  updateKey: (args: {
    data: KeyUpdateInput
    where: KeyWhereUniqueInput
  }) => KeyPromise
  upsertKey: (args: {
    where: KeyWhereUniqueInput
    create: KeyCreateInput
    update: KeyUpdateInput
  }) => KeyPromise
  deleteKey: (where: KeyWhereUniqueInput) => KeyPromise
  deleteManyKeys: (where?: KeyWhereInput) => BatchPayloadPromise
  createKeyLanguage: (data: KeyLanguageCreateInput) => KeyLanguagePromise
  updateKeyLanguage: (args: {
    data: KeyLanguageUpdateInput
    where: KeyLanguageWhereUniqueInput
  }) => KeyLanguagePromise
  updateManyKeyLanguages: (args: {
    data: KeyLanguageUpdateManyMutationInput
    where?: KeyLanguageWhereInput
  }) => BatchPayloadPromise
  upsertKeyLanguage: (args: {
    where: KeyLanguageWhereUniqueInput
    create: KeyLanguageCreateInput
    update: KeyLanguageUpdateInput
  }) => KeyLanguagePromise
  deleteKeyLanguage: (where: KeyLanguageWhereUniqueInput) => KeyLanguagePromise
  deleteManyKeyLanguages: (where?: KeyLanguageWhereInput) => BatchPayloadPromise
  createKeyStepResultStatus: (
    data: KeyStepResultStatusCreateInput,
  ) => KeyStepResultStatusPromise
  updateKeyStepResultStatus: (args: {
    data: KeyStepResultStatusUpdateInput
    where: KeyStepResultStatusWhereUniqueInput
  }) => KeyStepResultStatusPromise
  updateManyKeyStepResultStatuses: (args: {
    data: KeyStepResultStatusUpdateManyMutationInput
    where?: KeyStepResultStatusWhereInput
  }) => BatchPayloadPromise
  upsertKeyStepResultStatus: (args: {
    where: KeyStepResultStatusWhereUniqueInput
    create: KeyStepResultStatusCreateInput
    update: KeyStepResultStatusUpdateInput
  }) => KeyStepResultStatusPromise
  deleteKeyStepResultStatus: (
    where: KeyStepResultStatusWhereUniqueInput,
  ) => KeyStepResultStatusPromise
  deleteManyKeyStepResultStatuses: (
    where?: KeyStepResultStatusWhereInput,
  ) => BatchPayloadPromise
  createKeyTestResultStatus: (
    data: KeyTestResultStatusCreateInput,
  ) => KeyTestResultStatusPromise
  updateKeyTestResultStatus: (args: {
    data: KeyTestResultStatusUpdateInput
    where: KeyTestResultStatusWhereUniqueInput
  }) => KeyTestResultStatusPromise
  updateManyKeyTestResultStatuses: (args: {
    data: KeyTestResultStatusUpdateManyMutationInput
    where?: KeyTestResultStatusWhereInput
  }) => BatchPayloadPromise
  upsertKeyTestResultStatus: (args: {
    where: KeyTestResultStatusWhereUniqueInput
    create: KeyTestResultStatusCreateInput
    update: KeyTestResultStatusUpdateInput
  }) => KeyTestResultStatusPromise
  deleteKeyTestResultStatus: (
    where: KeyTestResultStatusWhereUniqueInput,
  ) => KeyTestResultStatusPromise
  deleteManyKeyTestResultStatuses: (
    where?: KeyTestResultStatusWhereInput,
  ) => BatchPayloadPromise
  createKeyUserType: (data: KeyUserTypeCreateInput) => KeyUserTypePromise
  updateKeyUserType: (args: {
    data: KeyUserTypeUpdateInput
    where: KeyUserTypeWhereUniqueInput
  }) => KeyUserTypePromise
  updateManyKeyUserTypes: (args: {
    data: KeyUserTypeUpdateManyMutationInput
    where?: KeyUserTypeWhereInput
  }) => BatchPayloadPromise
  upsertKeyUserType: (args: {
    where: KeyUserTypeWhereUniqueInput
    create: KeyUserTypeCreateInput
    update: KeyUserTypeUpdateInput
  }) => KeyUserTypePromise
  deleteKeyUserType: (where: KeyUserTypeWhereUniqueInput) => KeyUserTypePromise
  deleteManyKeyUserTypes: (where?: KeyUserTypeWhereInput) => BatchPayloadPromise
  createMenu: (data: MenuCreateInput) => MenuPromise
  updateMenu: (args: {
    data: MenuUpdateInput
    where: MenuWhereUniqueInput
  }) => MenuPromise
  updateManyMenus: (args: {
    data: MenuUpdateManyMutationInput
    where?: MenuWhereInput
  }) => BatchPayloadPromise
  upsertMenu: (args: {
    where: MenuWhereUniqueInput
    create: MenuCreateInput
    update: MenuUpdateInput
  }) => MenuPromise
  deleteMenu: (where: MenuWhereUniqueInput) => MenuPromise
  deleteManyMenus: (where?: MenuWhereInput) => BatchPayloadPromise
  createMessage: (data: MessageCreateInput) => MessagePromise
  updateMessage: (args: {
    data: MessageUpdateInput
    where: MessageWhereUniqueInput
  }) => MessagePromise
  upsertMessage: (args: {
    where: MessageWhereUniqueInput
    create: MessageCreateInput
    update: MessageUpdateInput
  }) => MessagePromise
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise
  createMultiLanguageContent: (
    data: MultiLanguageContentCreateInput,
  ) => MultiLanguageContentPromise
  updateMultiLanguageContent: (args: {
    data: MultiLanguageContentUpdateInput
    where: MultiLanguageContentWhereUniqueInput
  }) => MultiLanguageContentPromise
  updateManyMultiLanguageContents: (args: {
    data: MultiLanguageContentUpdateManyMutationInput
    where?: MultiLanguageContentWhereInput
  }) => BatchPayloadPromise
  upsertMultiLanguageContent: (args: {
    where: MultiLanguageContentWhereUniqueInput
    create: MultiLanguageContentCreateInput
    update: MultiLanguageContentUpdateInput
  }) => MultiLanguageContentPromise
  deleteMultiLanguageContent: (
    where: MultiLanguageContentWhereUniqueInput,
  ) => MultiLanguageContentPromise
  deleteManyMultiLanguageContents: (
    where?: MultiLanguageContentWhereInput,
  ) => BatchPayloadPromise
  createPath: (data: PathCreateInput) => PathPromise
  updatePath: (args: {
    data: PathUpdateInput
    where: PathWhereUniqueInput
  }) => PathPromise
  upsertPath: (args: {
    where: PathWhereUniqueInput
    create: PathCreateInput
    update: PathUpdateInput
  }) => PathPromise
  deletePath: (where: PathWhereUniqueInput) => PathPromise
  deleteManyPaths: (where?: PathWhereInput) => BatchPayloadPromise
  createStep: (data: StepCreateInput) => StepPromise
  updateStep: (args: {
    data: StepUpdateInput
    where: StepWhereUniqueInput
  }) => StepPromise
  upsertStep: (args: {
    where: StepWhereUniqueInput
    create: StepCreateInput
    update: StepUpdateInput
  }) => StepPromise
  deleteStep: (where: StepWhereUniqueInput) => StepPromise
  deleteManySteps: (where?: StepWhereInput) => BatchPayloadPromise
  createStepResult: (data: StepResultCreateInput) => StepResultPromise
  updateStepResult: (args: {
    data: StepResultUpdateInput
    where: StepResultWhereUniqueInput
  }) => StepResultPromise
  updateManyStepResults: (args: {
    data: StepResultUpdateManyMutationInput
    where?: StepResultWhereInput
  }) => BatchPayloadPromise
  upsertStepResult: (args: {
    where: StepResultWhereUniqueInput
    create: StepResultCreateInput
    update: StepResultUpdateInput
  }) => StepResultPromise
  deleteStepResult: (where: StepResultWhereUniqueInput) => StepResultPromise
  deleteManyStepResults: (where?: StepResultWhereInput) => BatchPayloadPromise
  createTest: (data: TestCreateInput) => TestPromise
  updateTest: (args: {
    data: TestUpdateInput
    where: TestWhereUniqueInput
  }) => TestPromise
  upsertTest: (args: {
    where: TestWhereUniqueInput
    create: TestCreateInput
    update: TestUpdateInput
  }) => TestPromise
  deleteTest: (where: TestWhereUniqueInput) => TestPromise
  deleteManyTests: (where?: TestWhereInput) => BatchPayloadPromise
  createTestResult: (data: TestResultCreateInput) => TestResultPromise
  updateTestResult: (args: {
    data: TestResultUpdateInput
    where: TestResultWhereUniqueInput
  }) => TestResultPromise
  updateManyTestResults: (args: {
    data: TestResultUpdateManyMutationInput
    where?: TestResultWhereInput
  }) => BatchPayloadPromise
  upsertTestResult: (args: {
    where: TestResultWhereUniqueInput
    create: TestResultCreateInput
    update: TestResultUpdateInput
  }) => TestResultPromise
  deleteTestResult: (where: TestResultWhereUniqueInput) => TestResultPromise
  deleteManyTestResults: (where?: TestResultWhereInput) => BatchPayloadPromise

  /**
   * Subscriptions
   */

  $subscribe: Subscription
}

export interface Subscription {
  company: (
    where?: CompanySubscriptionWhereInput,
  ) => CompanySubscriptionPayloadSubscription
  key: (where?: KeySubscriptionWhereInput) => KeySubscriptionPayloadSubscription
  keyLanguage: (
    where?: KeyLanguageSubscriptionWhereInput,
  ) => KeyLanguageSubscriptionPayloadSubscription
  keyStepResultStatus: (
    where?: KeyStepResultStatusSubscriptionWhereInput,
  ) => KeyStepResultStatusSubscriptionPayloadSubscription
  keyTestResultStatus: (
    where?: KeyTestResultStatusSubscriptionWhereInput,
  ) => KeyTestResultStatusSubscriptionPayloadSubscription
  keyUserType: (
    where?: KeyUserTypeSubscriptionWhereInput,
  ) => KeyUserTypeSubscriptionPayloadSubscription
  menu: (
    where?: MenuSubscriptionWhereInput,
  ) => MenuSubscriptionPayloadSubscription
  message: (
    where?: MessageSubscriptionWhereInput,
  ) => MessageSubscriptionPayloadSubscription
  multiLanguageContent: (
    where?: MultiLanguageContentSubscriptionWhereInput,
  ) => MultiLanguageContentSubscriptionPayloadSubscription
  path: (
    where?: PathSubscriptionWhereInput,
  ) => PathSubscriptionPayloadSubscription
  step: (
    where?: StepSubscriptionWhereInput,
  ) => StepSubscriptionPayloadSubscription
  stepResult: (
    where?: StepResultSubscriptionWhereInput,
  ) => StepResultSubscriptionPayloadSubscription
  test: (
    where?: TestSubscriptionWhereInput,
  ) => TestSubscriptionPayloadSubscription
  testResult: (
    where?: TestResultSubscriptionWhereInput,
  ) => TestResultSubscriptionPayloadSubscription
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T
}

/**
 * Types
 */

export type TestOrderByInput = 'id_ASC' | 'id_DESC'

export type KeyUserTypeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'key_ASC'
  | 'key_DESC'

export type KeyLanguageOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'key_ASC'
  | 'key_DESC'

export type StepOrderByInput = 'id_ASC' | 'id_DESC'

export type MenuOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'order_ASC'
  | 'order_DESC'
  | 'root_ASC'
  | 'root_DESC'

export type PathOrderByInput = 'id_ASC' | 'id_DESC'

export type StepResultOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'start_ASC'
  | 'start_DESC'
  | 'end_ASC'
  | 'end_DESC'
  | 'time_ASC'
  | 'time_DESC'

export type TestResultOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'start_ASC'
  | 'start_DESC'
  | 'end_ASC'
  | 'end_DESC'
  | 'time_ASC'
  | 'time_DESC'

export type KeyTestResultStatusOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'key_ASC'
  | 'key_DESC'

export type KeyStepResultStatusOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'key_ASC'
  | 'key_DESC'

export type CompanyOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'abbr_ASC'
  | 'abbr_DESC'

export type KeyOrderByInput = 'id_ASC' | 'id_DESC'

export type MessageOrderByInput = 'id_ASC' | 'id_DESC'

export type MultiLanguageContentOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'pt_ASC'
  | 'pt_DESC'
  | 'en_ASC'
  | 'en_DESC'

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED'

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
  name?: Maybe<String>
}>

export interface TestWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  publics_some?: Maybe<KeyUserTypeWhereInput>
  languages_some?: Maybe<KeyLanguageWhereInput>
  instruction?: Maybe<MessageWhereInput>
  company?: Maybe<CompanyWhereInput>
  title?: Maybe<MultiLanguageContentWhereInput>
  steps_some?: Maybe<StepWhereInput>
  menus_some?: Maybe<MenuWhereInput>
  results_some?: Maybe<TestResultWhereInput>
  keys?: Maybe<KeyWhereInput>
  AND?: Maybe<TestWhereInput[] | TestWhereInput>
}

export interface KeyUserTypeWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  key?: Maybe<String>
  key_not?: Maybe<String>
  key_in?: Maybe<String[] | String>
  key_not_in?: Maybe<String[] | String>
  key_lt?: Maybe<String>
  key_lte?: Maybe<String>
  key_gt?: Maybe<String>
  key_gte?: Maybe<String>
  key_contains?: Maybe<String>
  key_not_contains?: Maybe<String>
  key_starts_with?: Maybe<String>
  key_not_starts_with?: Maybe<String>
  key_ends_with?: Maybe<String>
  key_not_ends_with?: Maybe<String>
  AND?: Maybe<KeyUserTypeWhereInput[] | KeyUserTypeWhereInput>
}

export interface KeyLanguageWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  key?: Maybe<String>
  key_not?: Maybe<String>
  key_in?: Maybe<String[] | String>
  key_not_in?: Maybe<String[] | String>
  key_lt?: Maybe<String>
  key_lte?: Maybe<String>
  key_gt?: Maybe<String>
  key_gte?: Maybe<String>
  key_contains?: Maybe<String>
  key_not_contains?: Maybe<String>
  key_starts_with?: Maybe<String>
  key_not_starts_with?: Maybe<String>
  key_ends_with?: Maybe<String>
  key_not_ends_with?: Maybe<String>
  AND?: Maybe<KeyLanguageWhereInput[] | KeyLanguageWhereInput>
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  title?: Maybe<MultiLanguageContentWhereInput>
  message?: Maybe<MultiLanguageContentWhereInput>
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>
}

export interface MultiLanguageContentWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  pt?: Maybe<String>
  pt_not?: Maybe<String>
  pt_in?: Maybe<String[] | String>
  pt_not_in?: Maybe<String[] | String>
  pt_lt?: Maybe<String>
  pt_lte?: Maybe<String>
  pt_gt?: Maybe<String>
  pt_gte?: Maybe<String>
  pt_contains?: Maybe<String>
  pt_not_contains?: Maybe<String>
  pt_starts_with?: Maybe<String>
  pt_not_starts_with?: Maybe<String>
  pt_ends_with?: Maybe<String>
  pt_not_ends_with?: Maybe<String>
  en?: Maybe<String>
  en_not?: Maybe<String>
  en_in?: Maybe<String[] | String>
  en_not_in?: Maybe<String[] | String>
  en_lt?: Maybe<String>
  en_lte?: Maybe<String>
  en_gt?: Maybe<String>
  en_gte?: Maybe<String>
  en_contains?: Maybe<String>
  en_not_contains?: Maybe<String>
  en_starts_with?: Maybe<String>
  en_not_starts_with?: Maybe<String>
  en_ends_with?: Maybe<String>
  en_not_ends_with?: Maybe<String>
  AND?: Maybe<MultiLanguageContentWhereInput[] | MultiLanguageContentWhereInput>
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  name?: Maybe<String>
  name_not?: Maybe<String>
  name_in?: Maybe<String[] | String>
  name_not_in?: Maybe<String[] | String>
  name_lt?: Maybe<String>
  name_lte?: Maybe<String>
  name_gt?: Maybe<String>
  name_gte?: Maybe<String>
  name_contains?: Maybe<String>
  name_not_contains?: Maybe<String>
  name_starts_with?: Maybe<String>
  name_not_starts_with?: Maybe<String>
  name_ends_with?: Maybe<String>
  name_not_ends_with?: Maybe<String>
  abbr?: Maybe<String>
  abbr_not?: Maybe<String>
  abbr_in?: Maybe<String[] | String>
  abbr_not_in?: Maybe<String[] | String>
  abbr_lt?: Maybe<String>
  abbr_lte?: Maybe<String>
  abbr_gt?: Maybe<String>
  abbr_gte?: Maybe<String>
  abbr_contains?: Maybe<String>
  abbr_not_contains?: Maybe<String>
  abbr_starts_with?: Maybe<String>
  abbr_not_starts_with?: Maybe<String>
  abbr_ends_with?: Maybe<String>
  abbr_not_ends_with?: Maybe<String>
  welcome?: Maybe<MessageWhereInput>
  tests_some?: Maybe<TestWhereInput>
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>
}

export interface StepWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  type_some?: Maybe<KeyUserTypeWhereInput>
  question?: Maybe<MultiLanguageContentWhereInput>
  targets_some?: Maybe<MenuWhereInput>
  paths_some?: Maybe<PathWhereInput>
  results_some?: Maybe<StepResultWhereInput>
  AND?: Maybe<StepWhereInput[] | StepWhereInput>
}

export interface MenuWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  order?: Maybe<Int>
  order_not?: Maybe<Int>
  order_in?: Maybe<Int[] | Int>
  order_not_in?: Maybe<Int[] | Int>
  order_lt?: Maybe<Int>
  order_lte?: Maybe<Int>
  order_gt?: Maybe<Int>
  order_gte?: Maybe<Int>
  root?: Maybe<Boolean>
  root_not?: Maybe<Boolean>
  menus_some?: Maybe<MenuWhereInput>
  name?: Maybe<MultiLanguageContentWhereInput>
  items_some?: Maybe<MenuWhereInput>
  AND?: Maybe<MenuWhereInput[] | MenuWhereInput>
}

export interface PathWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  items_some?: Maybe<MenuWhereInput>
  AND?: Maybe<PathWhereInput[] | PathWhereInput>
}

export interface StepResultWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  parent?: Maybe<StepWhereInput>
  result?: Maybe<TestResultWhereInput>
  start?: Maybe<DateTimeInput>
  start_not?: Maybe<DateTimeInput>
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  start_lt?: Maybe<DateTimeInput>
  start_lte?: Maybe<DateTimeInput>
  start_gt?: Maybe<DateTimeInput>
  start_gte?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  end_not?: Maybe<DateTimeInput>
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  end_lt?: Maybe<DateTimeInput>
  end_lte?: Maybe<DateTimeInput>
  end_gt?: Maybe<DateTimeInput>
  end_gte?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  time_not?: Maybe<Int>
  time_in?: Maybe<Int[] | Int>
  time_not_in?: Maybe<Int[] | Int>
  time_lt?: Maybe<Int>
  time_lte?: Maybe<Int>
  time_gt?: Maybe<Int>
  time_gte?: Maybe<Int>
  path_some?: Maybe<MenuWhereInput>
  status?: Maybe<KeyStepResultStatusWhereInput>
  AND?: Maybe<StepResultWhereInput[] | StepResultWhereInput>
}

export interface TestResultWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  parent?: Maybe<TestWhereInput>
  start?: Maybe<DateTimeInput>
  start_not?: Maybe<DateTimeInput>
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  start_lt?: Maybe<DateTimeInput>
  start_lte?: Maybe<DateTimeInput>
  start_gt?: Maybe<DateTimeInput>
  start_gte?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  end_not?: Maybe<DateTimeInput>
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  end_lt?: Maybe<DateTimeInput>
  end_lte?: Maybe<DateTimeInput>
  end_gt?: Maybe<DateTimeInput>
  end_gte?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  time_not?: Maybe<Int>
  time_in?: Maybe<Int[] | Int>
  time_not_in?: Maybe<Int[] | Int>
  time_lt?: Maybe<Int>
  time_lte?: Maybe<Int>
  time_gt?: Maybe<Int>
  time_gte?: Maybe<Int>
  steps_some?: Maybe<StepResultWhereInput>
  status?: Maybe<KeyTestResultStatusWhereInput>
  AND?: Maybe<TestResultWhereInput[] | TestResultWhereInput>
}

export interface KeyTestResultStatusWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  key?: Maybe<String>
  key_not?: Maybe<String>
  key_in?: Maybe<String[] | String>
  key_not_in?: Maybe<String[] | String>
  key_lt?: Maybe<String>
  key_lte?: Maybe<String>
  key_gt?: Maybe<String>
  key_gte?: Maybe<String>
  key_contains?: Maybe<String>
  key_not_contains?: Maybe<String>
  key_starts_with?: Maybe<String>
  key_not_starts_with?: Maybe<String>
  key_ends_with?: Maybe<String>
  key_not_ends_with?: Maybe<String>
  AND?: Maybe<KeyTestResultStatusWhereInput[] | KeyTestResultStatusWhereInput>
}

export interface KeyStepResultStatusWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  key?: Maybe<String>
  key_not?: Maybe<String>
  key_in?: Maybe<String[] | String>
  key_not_in?: Maybe<String[] | String>
  key_lt?: Maybe<String>
  key_lte?: Maybe<String>
  key_gt?: Maybe<String>
  key_gte?: Maybe<String>
  key_contains?: Maybe<String>
  key_not_contains?: Maybe<String>
  key_starts_with?: Maybe<String>
  key_not_starts_with?: Maybe<String>
  key_ends_with?: Maybe<String>
  key_not_ends_with?: Maybe<String>
  AND?: Maybe<KeyStepResultStatusWhereInput[] | KeyStepResultStatusWhereInput>
}

export interface KeyWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  userTypes_some?: Maybe<KeyUserTypeWhereInput>
  testResultStatus_some?: Maybe<KeyTestResultStatusWhereInput>
  stepResultStatus_some?: Maybe<KeyStepResultStatusWhereInput>
  languages_some?: Maybe<KeyLanguageWhereInput>
  AND?: Maybe<KeyWhereInput[] | KeyWhereInput>
}

export type KeyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type KeyLanguageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
  key?: Maybe<String>
}>

export type KeyStepResultStatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
  key?: Maybe<String>
}>

export type KeyTestResultStatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
  key?: Maybe<String>
}>

export type KeyUserTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
  key?: Maybe<String>
}>

export type MenuWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type MultiLanguageContentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type PathWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type StepWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type StepResultWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type TestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export type TestResultWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>
}>

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>
  name: String
  abbr?: Maybe<String>
  welcome: MessageCreateOneInput
  tests?: Maybe<TestCreateManyWithoutCompanyInput>
}

export interface MessageCreateOneInput {
  create?: Maybe<MessageCreateInput>
  connect?: Maybe<MessageWhereUniqueInput>
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>
  title: MultiLanguageContentCreateOneInput
  message: MultiLanguageContentCreateOneInput
}

export interface MultiLanguageContentCreateOneInput {
  create?: Maybe<MultiLanguageContentCreateInput>
  connect?: Maybe<MultiLanguageContentWhereUniqueInput>
}

export interface MultiLanguageContentCreateInput {
  id?: Maybe<ID_Input>
  pt: String
  en?: Maybe<String>
}

export interface TestCreateManyWithoutCompanyInput {
  create?: Maybe<
    TestCreateWithoutCompanyInput[] | TestCreateWithoutCompanyInput
  >
  connect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
}

export interface TestCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>
  publics?: Maybe<KeyUserTypeCreateManyInput>
  languages?: Maybe<KeyLanguageCreateManyInput>
  instruction: MessageCreateOneInput
  title: MultiLanguageContentCreateOneInput
  steps?: Maybe<StepCreateManyInput>
  menus?: Maybe<MenuCreateManyInput>
  results?: Maybe<TestResultCreateManyWithoutParentInput>
  keys: KeyCreateOneInput
}

export interface KeyUserTypeCreateManyInput {
  create?: Maybe<KeyUserTypeCreateInput[] | KeyUserTypeCreateInput>
  connect?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
}

export interface KeyUserTypeCreateInput {
  id?: Maybe<ID_Input>
  key: String
}

export interface KeyLanguageCreateManyInput {
  create?: Maybe<KeyLanguageCreateInput[] | KeyLanguageCreateInput>
  connect?: Maybe<KeyLanguageWhereUniqueInput[] | KeyLanguageWhereUniqueInput>
}

export interface KeyLanguageCreateInput {
  id?: Maybe<ID_Input>
  key: String
}

export interface StepCreateManyInput {
  create?: Maybe<StepCreateInput[] | StepCreateInput>
  connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
}

export interface StepCreateInput {
  id?: Maybe<ID_Input>
  type?: Maybe<KeyUserTypeCreateManyInput>
  question: MultiLanguageContentCreateOneInput
  targets?: Maybe<MenuCreateManyInput>
  paths?: Maybe<PathCreateManyInput>
  results?: Maybe<StepResultCreateManyWithoutParentInput>
}

export interface MenuCreateManyInput {
  create?: Maybe<MenuCreateInput[] | MenuCreateInput>
  connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
}

export interface MenuCreateInput {
  id?: Maybe<ID_Input>
  order?: Maybe<Int>
  root?: Maybe<Boolean>
  menus?: Maybe<MenuCreateManyWithoutItemsInput>
  name: MultiLanguageContentCreateOneInput
  items?: Maybe<MenuCreateManyWithoutMenusInput>
}

export interface MenuCreateManyWithoutItemsInput {
  create?: Maybe<MenuCreateWithoutItemsInput[] | MenuCreateWithoutItemsInput>
  connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
}

export interface MenuCreateWithoutItemsInput {
  id?: Maybe<ID_Input>
  order?: Maybe<Int>
  root?: Maybe<Boolean>
  menus?: Maybe<MenuCreateManyWithoutItemsInput>
  name: MultiLanguageContentCreateOneInput
}

export interface MenuCreateManyWithoutMenusInput {
  create?: Maybe<MenuCreateWithoutMenusInput[] | MenuCreateWithoutMenusInput>
  connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
}

export interface MenuCreateWithoutMenusInput {
  id?: Maybe<ID_Input>
  order?: Maybe<Int>
  root?: Maybe<Boolean>
  name: MultiLanguageContentCreateOneInput
  items?: Maybe<MenuCreateManyWithoutMenusInput>
}

export interface PathCreateManyInput {
  create?: Maybe<PathCreateInput[] | PathCreateInput>
  connect?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
}

export interface PathCreateInput {
  id?: Maybe<ID_Input>
  items?: Maybe<MenuCreateManyInput>
}

export interface StepResultCreateManyWithoutParentInput {
  create?: Maybe<
    StepResultCreateWithoutParentInput[] | StepResultCreateWithoutParentInput
  >
  connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
}

export interface StepResultCreateWithoutParentInput {
  id?: Maybe<ID_Input>
  result: TestResultCreateOneWithoutStepsInput
  start: DateTimeInput
  end: DateTimeInput
  time: Int
  path?: Maybe<MenuCreateManyInput>
  status: KeyStepResultStatusCreateOneInput
}

export interface TestResultCreateOneWithoutStepsInput {
  create?: Maybe<TestResultCreateWithoutStepsInput>
  connect?: Maybe<TestResultWhereUniqueInput>
}

export interface TestResultCreateWithoutStepsInput {
  id?: Maybe<ID_Input>
  parent: TestCreateOneWithoutResultsInput
  start: DateTimeInput
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  status: KeyTestResultStatusCreateOneInput
}

export interface TestCreateOneWithoutResultsInput {
  create?: Maybe<TestCreateWithoutResultsInput>
  connect?: Maybe<TestWhereUniqueInput>
}

export interface TestCreateWithoutResultsInput {
  id?: Maybe<ID_Input>
  publics?: Maybe<KeyUserTypeCreateManyInput>
  languages?: Maybe<KeyLanguageCreateManyInput>
  instruction: MessageCreateOneInput
  company: CompanyCreateOneWithoutTestsInput
  title: MultiLanguageContentCreateOneInput
  steps?: Maybe<StepCreateManyInput>
  menus?: Maybe<MenuCreateManyInput>
  keys: KeyCreateOneInput
}

export interface CompanyCreateOneWithoutTestsInput {
  create?: Maybe<CompanyCreateWithoutTestsInput>
  connect?: Maybe<CompanyWhereUniqueInput>
}

export interface CompanyCreateWithoutTestsInput {
  id?: Maybe<ID_Input>
  name: String
  abbr?: Maybe<String>
  welcome: MessageCreateOneInput
}

export interface KeyCreateOneInput {
  create?: Maybe<KeyCreateInput>
  connect?: Maybe<KeyWhereUniqueInput>
}

export interface KeyCreateInput {
  id?: Maybe<ID_Input>
  userTypes?: Maybe<KeyUserTypeCreateManyInput>
  testResultStatus?: Maybe<KeyTestResultStatusCreateManyInput>
  stepResultStatus?: Maybe<KeyStepResultStatusCreateManyInput>
  languages?: Maybe<KeyLanguageCreateManyInput>
}

export interface KeyTestResultStatusCreateManyInput {
  create?: Maybe<
    KeyTestResultStatusCreateInput[] | KeyTestResultStatusCreateInput
  >
  connect?: Maybe<
    KeyTestResultStatusWhereUniqueInput[] | KeyTestResultStatusWhereUniqueInput
  >
}

export interface KeyTestResultStatusCreateInput {
  id?: Maybe<ID_Input>
  key: String
}

export interface KeyStepResultStatusCreateManyInput {
  create?: Maybe<
    KeyStepResultStatusCreateInput[] | KeyStepResultStatusCreateInput
  >
  connect?: Maybe<
    KeyStepResultStatusWhereUniqueInput[] | KeyStepResultStatusWhereUniqueInput
  >
}

export interface KeyStepResultStatusCreateInput {
  id?: Maybe<ID_Input>
  key: String
}

export interface KeyTestResultStatusCreateOneInput {
  create?: Maybe<KeyTestResultStatusCreateInput>
  connect?: Maybe<KeyTestResultStatusWhereUniqueInput>
}

export interface KeyStepResultStatusCreateOneInput {
  create?: Maybe<KeyStepResultStatusCreateInput>
  connect?: Maybe<KeyStepResultStatusWhereUniqueInput>
}

export interface TestResultCreateManyWithoutParentInput {
  create?: Maybe<
    TestResultCreateWithoutParentInput[] | TestResultCreateWithoutParentInput
  >
  connect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
}

export interface TestResultCreateWithoutParentInput {
  id?: Maybe<ID_Input>
  start: DateTimeInput
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  steps?: Maybe<StepResultCreateManyWithoutResultInput>
  status: KeyTestResultStatusCreateOneInput
}

export interface StepResultCreateManyWithoutResultInput {
  create?: Maybe<
    StepResultCreateWithoutResultInput[] | StepResultCreateWithoutResultInput
  >
  connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
}

export interface StepResultCreateWithoutResultInput {
  id?: Maybe<ID_Input>
  parent: StepCreateOneWithoutResultsInput
  start: DateTimeInput
  end: DateTimeInput
  time: Int
  path?: Maybe<MenuCreateManyInput>
  status: KeyStepResultStatusCreateOneInput
}

export interface StepCreateOneWithoutResultsInput {
  create?: Maybe<StepCreateWithoutResultsInput>
  connect?: Maybe<StepWhereUniqueInput>
}

export interface StepCreateWithoutResultsInput {
  id?: Maybe<ID_Input>
  type?: Maybe<KeyUserTypeCreateManyInput>
  question: MultiLanguageContentCreateOneInput
  targets?: Maybe<MenuCreateManyInput>
  paths?: Maybe<PathCreateManyInput>
}

export interface CompanyUpdateInput {
  name?: Maybe<String>
  abbr?: Maybe<String>
  welcome?: Maybe<MessageUpdateOneRequiredInput>
  tests?: Maybe<TestUpdateManyWithoutCompanyInput>
}

export interface MessageUpdateOneRequiredInput {
  create?: Maybe<MessageCreateInput>
  update?: Maybe<MessageUpdateDataInput>
  upsert?: Maybe<MessageUpsertNestedInput>
  connect?: Maybe<MessageWhereUniqueInput>
}

export interface MessageUpdateDataInput {
  title?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  message?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
}

export interface MultiLanguageContentUpdateOneRequiredInput {
  create?: Maybe<MultiLanguageContentCreateInput>
  update?: Maybe<MultiLanguageContentUpdateDataInput>
  upsert?: Maybe<MultiLanguageContentUpsertNestedInput>
  connect?: Maybe<MultiLanguageContentWhereUniqueInput>
}

export interface MultiLanguageContentUpdateDataInput {
  pt?: Maybe<String>
  en?: Maybe<String>
}

export interface MultiLanguageContentUpsertNestedInput {
  update: MultiLanguageContentUpdateDataInput
  create: MultiLanguageContentCreateInput
}

export interface MessageUpsertNestedInput {
  update: MessageUpdateDataInput
  create: MessageCreateInput
}

export interface TestUpdateManyWithoutCompanyInput {
  create?: Maybe<
    TestCreateWithoutCompanyInput[] | TestCreateWithoutCompanyInput
  >
  delete?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
  connect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
  set?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
  disconnect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>
  update?: Maybe<
    | TestUpdateWithWhereUniqueWithoutCompanyInput[]
    | TestUpdateWithWhereUniqueWithoutCompanyInput
  >
  upsert?: Maybe<
    | TestUpsertWithWhereUniqueWithoutCompanyInput[]
    | TestUpsertWithWhereUniqueWithoutCompanyInput
  >
  deleteMany?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
}

export interface TestUpdateWithWhereUniqueWithoutCompanyInput {
  where: TestWhereUniqueInput
  data: TestUpdateWithoutCompanyDataInput
}

export interface TestUpdateWithoutCompanyDataInput {
  publics?: Maybe<KeyUserTypeUpdateManyInput>
  languages?: Maybe<KeyLanguageUpdateManyInput>
  instruction?: Maybe<MessageUpdateOneRequiredInput>
  title?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  steps?: Maybe<StepUpdateManyInput>
  menus?: Maybe<MenuUpdateManyInput>
  results?: Maybe<TestResultUpdateManyWithoutParentInput>
  keys?: Maybe<KeyUpdateOneRequiredInput>
}

export interface KeyUserTypeUpdateManyInput {
  create?: Maybe<KeyUserTypeCreateInput[] | KeyUserTypeCreateInput>
  update?: Maybe<
    | KeyUserTypeUpdateWithWhereUniqueNestedInput[]
    | KeyUserTypeUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | KeyUserTypeUpsertWithWhereUniqueNestedInput[]
    | KeyUserTypeUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
  connect?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
  set?: Maybe<KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput>
  disconnect?: Maybe<
    KeyUserTypeWhereUniqueInput[] | KeyUserTypeWhereUniqueInput
  >
  deleteMany?: Maybe<
    KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput
  >
  updateMany?: Maybe<
    | KeyUserTypeUpdateManyWithWhereNestedInput[]
    | KeyUserTypeUpdateManyWithWhereNestedInput
  >
}

export interface KeyUserTypeUpdateWithWhereUniqueNestedInput {
  where: KeyUserTypeWhereUniqueInput
  data: KeyUserTypeUpdateDataInput
}

export interface KeyUserTypeUpdateDataInput {
  key?: Maybe<String>
}

export interface KeyUserTypeUpsertWithWhereUniqueNestedInput {
  where: KeyUserTypeWhereUniqueInput
  update: KeyUserTypeUpdateDataInput
  create: KeyUserTypeCreateInput
}

export interface KeyUserTypeScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  key?: Maybe<String>
  key_not?: Maybe<String>
  key_in?: Maybe<String[] | String>
  key_not_in?: Maybe<String[] | String>
  key_lt?: Maybe<String>
  key_lte?: Maybe<String>
  key_gt?: Maybe<String>
  key_gte?: Maybe<String>
  key_contains?: Maybe<String>
  key_not_contains?: Maybe<String>
  key_starts_with?: Maybe<String>
  key_not_starts_with?: Maybe<String>
  key_ends_with?: Maybe<String>
  key_not_ends_with?: Maybe<String>
  AND?: Maybe<KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput>
  OR?: Maybe<KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput>
  NOT?: Maybe<KeyUserTypeScalarWhereInput[] | KeyUserTypeScalarWhereInput>
}

export interface KeyUserTypeUpdateManyWithWhereNestedInput {
  where: KeyUserTypeScalarWhereInput
  data: KeyUserTypeUpdateManyDataInput
}

export interface KeyUserTypeUpdateManyDataInput {
  key?: Maybe<String>
}

export interface KeyLanguageUpdateManyInput {
  create?: Maybe<KeyLanguageCreateInput[] | KeyLanguageCreateInput>
  update?: Maybe<
    | KeyLanguageUpdateWithWhereUniqueNestedInput[]
    | KeyLanguageUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | KeyLanguageUpsertWithWhereUniqueNestedInput[]
    | KeyLanguageUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<KeyLanguageWhereUniqueInput[] | KeyLanguageWhereUniqueInput>
  connect?: Maybe<KeyLanguageWhereUniqueInput[] | KeyLanguageWhereUniqueInput>
  set?: Maybe<KeyLanguageWhereUniqueInput[] | KeyLanguageWhereUniqueInput>
  disconnect?: Maybe<
    KeyLanguageWhereUniqueInput[] | KeyLanguageWhereUniqueInput
  >
  deleteMany?: Maybe<
    KeyLanguageScalarWhereInput[] | KeyLanguageScalarWhereInput
  >
  updateMany?: Maybe<
    | KeyLanguageUpdateManyWithWhereNestedInput[]
    | KeyLanguageUpdateManyWithWhereNestedInput
  >
}

export interface KeyLanguageUpdateWithWhereUniqueNestedInput {
  where: KeyLanguageWhereUniqueInput
  data: KeyLanguageUpdateDataInput
}

export interface KeyLanguageUpdateDataInput {
  key?: Maybe<String>
}

export interface KeyLanguageUpsertWithWhereUniqueNestedInput {
  where: KeyLanguageWhereUniqueInput
  update: KeyLanguageUpdateDataInput
  create: KeyLanguageCreateInput
}

export interface KeyLanguageScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  key?: Maybe<String>
  key_not?: Maybe<String>
  key_in?: Maybe<String[] | String>
  key_not_in?: Maybe<String[] | String>
  key_lt?: Maybe<String>
  key_lte?: Maybe<String>
  key_gt?: Maybe<String>
  key_gte?: Maybe<String>
  key_contains?: Maybe<String>
  key_not_contains?: Maybe<String>
  key_starts_with?: Maybe<String>
  key_not_starts_with?: Maybe<String>
  key_ends_with?: Maybe<String>
  key_not_ends_with?: Maybe<String>
  AND?: Maybe<KeyLanguageScalarWhereInput[] | KeyLanguageScalarWhereInput>
  OR?: Maybe<KeyLanguageScalarWhereInput[] | KeyLanguageScalarWhereInput>
  NOT?: Maybe<KeyLanguageScalarWhereInput[] | KeyLanguageScalarWhereInput>
}

export interface KeyLanguageUpdateManyWithWhereNestedInput {
  where: KeyLanguageScalarWhereInput
  data: KeyLanguageUpdateManyDataInput
}

export interface KeyLanguageUpdateManyDataInput {
  key?: Maybe<String>
}

export interface StepUpdateManyInput {
  create?: Maybe<StepCreateInput[] | StepCreateInput>
  update?: Maybe<
    | StepUpdateWithWhereUniqueNestedInput[]
    | StepUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | StepUpsertWithWhereUniqueNestedInput[]
    | StepUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
  connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
  set?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
  disconnect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>
  deleteMany?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
}

export interface StepUpdateWithWhereUniqueNestedInput {
  where: StepWhereUniqueInput
  data: StepUpdateDataInput
}

export interface StepUpdateDataInput {
  type?: Maybe<KeyUserTypeUpdateManyInput>
  question?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  targets?: Maybe<MenuUpdateManyInput>
  paths?: Maybe<PathUpdateManyInput>
  results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface MenuUpdateManyInput {
  create?: Maybe<MenuCreateInput[] | MenuCreateInput>
  update?: Maybe<
    | MenuUpdateWithWhereUniqueNestedInput[]
    | MenuUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | MenuUpsertWithWhereUniqueNestedInput[]
    | MenuUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  set?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  disconnect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  deleteMany?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
  updateMany?: Maybe<
    MenuUpdateManyWithWhereNestedInput[] | MenuUpdateManyWithWhereNestedInput
  >
}

export interface MenuUpdateWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput
  data: MenuUpdateDataInput
}

export interface MenuUpdateDataInput {
  order?: Maybe<Int>
  root?: Maybe<Boolean>
  menus?: Maybe<MenuUpdateManyWithoutItemsInput>
  name?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  items?: Maybe<MenuUpdateManyWithoutMenusInput>
}

export interface MenuUpdateManyWithoutItemsInput {
  create?: Maybe<MenuCreateWithoutItemsInput[] | MenuCreateWithoutItemsInput>
  delete?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  set?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  disconnect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  update?: Maybe<
    | MenuUpdateWithWhereUniqueWithoutItemsInput[]
    | MenuUpdateWithWhereUniqueWithoutItemsInput
  >
  upsert?: Maybe<
    | MenuUpsertWithWhereUniqueWithoutItemsInput[]
    | MenuUpsertWithWhereUniqueWithoutItemsInput
  >
  deleteMany?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
  updateMany?: Maybe<
    MenuUpdateManyWithWhereNestedInput[] | MenuUpdateManyWithWhereNestedInput
  >
}

export interface MenuUpdateWithWhereUniqueWithoutItemsInput {
  where: MenuWhereUniqueInput
  data: MenuUpdateWithoutItemsDataInput
}

export interface MenuUpdateWithoutItemsDataInput {
  order?: Maybe<Int>
  root?: Maybe<Boolean>
  menus?: Maybe<MenuUpdateManyWithoutItemsInput>
  name?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
}

export interface MenuUpsertWithWhereUniqueWithoutItemsInput {
  where: MenuWhereUniqueInput
  update: MenuUpdateWithoutItemsDataInput
  create: MenuCreateWithoutItemsInput
}

export interface MenuScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  order?: Maybe<Int>
  order_not?: Maybe<Int>
  order_in?: Maybe<Int[] | Int>
  order_not_in?: Maybe<Int[] | Int>
  order_lt?: Maybe<Int>
  order_lte?: Maybe<Int>
  order_gt?: Maybe<Int>
  order_gte?: Maybe<Int>
  root?: Maybe<Boolean>
  root_not?: Maybe<Boolean>
  AND?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
  OR?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
  NOT?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
}

export interface MenuUpdateManyWithWhereNestedInput {
  where: MenuScalarWhereInput
  data: MenuUpdateManyDataInput
}

export interface MenuUpdateManyDataInput {
  order?: Maybe<Int>
  root?: Maybe<Boolean>
}

export interface MenuUpdateManyWithoutMenusInput {
  create?: Maybe<MenuCreateWithoutMenusInput[] | MenuCreateWithoutMenusInput>
  delete?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  connect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  set?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  disconnect?: Maybe<MenuWhereUniqueInput[] | MenuWhereUniqueInput>
  update?: Maybe<
    | MenuUpdateWithWhereUniqueWithoutMenusInput[]
    | MenuUpdateWithWhereUniqueWithoutMenusInput
  >
  upsert?: Maybe<
    | MenuUpsertWithWhereUniqueWithoutMenusInput[]
    | MenuUpsertWithWhereUniqueWithoutMenusInput
  >
  deleteMany?: Maybe<MenuScalarWhereInput[] | MenuScalarWhereInput>
  updateMany?: Maybe<
    MenuUpdateManyWithWhereNestedInput[] | MenuUpdateManyWithWhereNestedInput
  >
}

export interface MenuUpdateWithWhereUniqueWithoutMenusInput {
  where: MenuWhereUniqueInput
  data: MenuUpdateWithoutMenusDataInput
}

export interface MenuUpdateWithoutMenusDataInput {
  order?: Maybe<Int>
  root?: Maybe<Boolean>
  name?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  items?: Maybe<MenuUpdateManyWithoutMenusInput>
}

export interface MenuUpsertWithWhereUniqueWithoutMenusInput {
  where: MenuWhereUniqueInput
  update: MenuUpdateWithoutMenusDataInput
  create: MenuCreateWithoutMenusInput
}

export interface MenuUpsertWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput
  update: MenuUpdateDataInput
  create: MenuCreateInput
}

export interface PathUpdateManyInput {
  create?: Maybe<PathCreateInput[] | PathCreateInput>
  update?: Maybe<
    | PathUpdateWithWhereUniqueNestedInput[]
    | PathUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | PathUpsertWithWhereUniqueNestedInput[]
    | PathUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
  connect?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
  set?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
  disconnect?: Maybe<PathWhereUniqueInput[] | PathWhereUniqueInput>
  deleteMany?: Maybe<PathScalarWhereInput[] | PathScalarWhereInput>
}

export interface PathUpdateWithWhereUniqueNestedInput {
  where: PathWhereUniqueInput
  data: PathUpdateDataInput
}

export interface PathUpdateDataInput {
  items?: Maybe<MenuUpdateManyInput>
}

export interface PathUpsertWithWhereUniqueNestedInput {
  where: PathWhereUniqueInput
  update: PathUpdateDataInput
  create: PathCreateInput
}

export interface PathScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  AND?: Maybe<PathScalarWhereInput[] | PathScalarWhereInput>
  OR?: Maybe<PathScalarWhereInput[] | PathScalarWhereInput>
  NOT?: Maybe<PathScalarWhereInput[] | PathScalarWhereInput>
}

export interface StepResultUpdateManyWithoutParentInput {
  create?: Maybe<
    StepResultCreateWithoutParentInput[] | StepResultCreateWithoutParentInput
  >
  delete?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
  connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
  set?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
  disconnect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
  update?: Maybe<
    | StepResultUpdateWithWhereUniqueWithoutParentInput[]
    | StepResultUpdateWithWhereUniqueWithoutParentInput
  >
  upsert?: Maybe<
    | StepResultUpsertWithWhereUniqueWithoutParentInput[]
    | StepResultUpsertWithWhereUniqueWithoutParentInput
  >
  deleteMany?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
  updateMany?: Maybe<
    | StepResultUpdateManyWithWhereNestedInput[]
    | StepResultUpdateManyWithWhereNestedInput
  >
}

export interface StepResultUpdateWithWhereUniqueWithoutParentInput {
  where: StepResultWhereUniqueInput
  data: StepResultUpdateWithoutParentDataInput
}

export interface StepResultUpdateWithoutParentDataInput {
  result?: Maybe<TestResultUpdateOneRequiredWithoutStepsInput>
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  path?: Maybe<MenuUpdateManyInput>
  status?: Maybe<KeyStepResultStatusUpdateOneRequiredInput>
}

export interface TestResultUpdateOneRequiredWithoutStepsInput {
  create?: Maybe<TestResultCreateWithoutStepsInput>
  update?: Maybe<TestResultUpdateWithoutStepsDataInput>
  upsert?: Maybe<TestResultUpsertWithoutStepsInput>
  connect?: Maybe<TestResultWhereUniqueInput>
}

export interface TestResultUpdateWithoutStepsDataInput {
  parent?: Maybe<TestUpdateOneRequiredWithoutResultsInput>
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  status?: Maybe<KeyTestResultStatusUpdateOneRequiredInput>
}

export interface TestUpdateOneRequiredWithoutResultsInput {
  create?: Maybe<TestCreateWithoutResultsInput>
  update?: Maybe<TestUpdateWithoutResultsDataInput>
  upsert?: Maybe<TestUpsertWithoutResultsInput>
  connect?: Maybe<TestWhereUniqueInput>
}

export interface TestUpdateWithoutResultsDataInput {
  publics?: Maybe<KeyUserTypeUpdateManyInput>
  languages?: Maybe<KeyLanguageUpdateManyInput>
  instruction?: Maybe<MessageUpdateOneRequiredInput>
  company?: Maybe<CompanyUpdateOneRequiredWithoutTestsInput>
  title?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  steps?: Maybe<StepUpdateManyInput>
  menus?: Maybe<MenuUpdateManyInput>
  keys?: Maybe<KeyUpdateOneRequiredInput>
}

export interface CompanyUpdateOneRequiredWithoutTestsInput {
  create?: Maybe<CompanyCreateWithoutTestsInput>
  update?: Maybe<CompanyUpdateWithoutTestsDataInput>
  upsert?: Maybe<CompanyUpsertWithoutTestsInput>
  connect?: Maybe<CompanyWhereUniqueInput>
}

export interface CompanyUpdateWithoutTestsDataInput {
  name?: Maybe<String>
  abbr?: Maybe<String>
  welcome?: Maybe<MessageUpdateOneRequiredInput>
}

export interface CompanyUpsertWithoutTestsInput {
  update: CompanyUpdateWithoutTestsDataInput
  create: CompanyCreateWithoutTestsInput
}

export interface KeyUpdateOneRequiredInput {
  create?: Maybe<KeyCreateInput>
  update?: Maybe<KeyUpdateDataInput>
  upsert?: Maybe<KeyUpsertNestedInput>
  connect?: Maybe<KeyWhereUniqueInput>
}

export interface KeyUpdateDataInput {
  userTypes?: Maybe<KeyUserTypeUpdateManyInput>
  testResultStatus?: Maybe<KeyTestResultStatusUpdateManyInput>
  stepResultStatus?: Maybe<KeyStepResultStatusUpdateManyInput>
  languages?: Maybe<KeyLanguageUpdateManyInput>
}

export interface KeyTestResultStatusUpdateManyInput {
  create?: Maybe<
    KeyTestResultStatusCreateInput[] | KeyTestResultStatusCreateInput
  >
  update?: Maybe<
    | KeyTestResultStatusUpdateWithWhereUniqueNestedInput[]
    | KeyTestResultStatusUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | KeyTestResultStatusUpsertWithWhereUniqueNestedInput[]
    | KeyTestResultStatusUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<
    KeyTestResultStatusWhereUniqueInput[] | KeyTestResultStatusWhereUniqueInput
  >
  connect?: Maybe<
    KeyTestResultStatusWhereUniqueInput[] | KeyTestResultStatusWhereUniqueInput
  >
  set?: Maybe<
    KeyTestResultStatusWhereUniqueInput[] | KeyTestResultStatusWhereUniqueInput
  >
  disconnect?: Maybe<
    KeyTestResultStatusWhereUniqueInput[] | KeyTestResultStatusWhereUniqueInput
  >
  deleteMany?: Maybe<
    KeyTestResultStatusScalarWhereInput[] | KeyTestResultStatusScalarWhereInput
  >
  updateMany?: Maybe<
    | KeyTestResultStatusUpdateManyWithWhereNestedInput[]
    | KeyTestResultStatusUpdateManyWithWhereNestedInput
  >
}

export interface KeyTestResultStatusUpdateWithWhereUniqueNestedInput {
  where: KeyTestResultStatusWhereUniqueInput
  data: KeyTestResultStatusUpdateDataInput
}

export interface KeyTestResultStatusUpdateDataInput {
  key?: Maybe<String>
}

export interface KeyTestResultStatusUpsertWithWhereUniqueNestedInput {
  where: KeyTestResultStatusWhereUniqueInput
  update: KeyTestResultStatusUpdateDataInput
  create: KeyTestResultStatusCreateInput
}

export interface KeyTestResultStatusScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  key?: Maybe<String>
  key_not?: Maybe<String>
  key_in?: Maybe<String[] | String>
  key_not_in?: Maybe<String[] | String>
  key_lt?: Maybe<String>
  key_lte?: Maybe<String>
  key_gt?: Maybe<String>
  key_gte?: Maybe<String>
  key_contains?: Maybe<String>
  key_not_contains?: Maybe<String>
  key_starts_with?: Maybe<String>
  key_not_starts_with?: Maybe<String>
  key_ends_with?: Maybe<String>
  key_not_ends_with?: Maybe<String>
  AND?: Maybe<
    KeyTestResultStatusScalarWhereInput[] | KeyTestResultStatusScalarWhereInput
  >
  OR?: Maybe<
    KeyTestResultStatusScalarWhereInput[] | KeyTestResultStatusScalarWhereInput
  >
  NOT?: Maybe<
    KeyTestResultStatusScalarWhereInput[] | KeyTestResultStatusScalarWhereInput
  >
}

export interface KeyTestResultStatusUpdateManyWithWhereNestedInput {
  where: KeyTestResultStatusScalarWhereInput
  data: KeyTestResultStatusUpdateManyDataInput
}

export interface KeyTestResultStatusUpdateManyDataInput {
  key?: Maybe<String>
}

export interface KeyStepResultStatusUpdateManyInput {
  create?: Maybe<
    KeyStepResultStatusCreateInput[] | KeyStepResultStatusCreateInput
  >
  update?: Maybe<
    | KeyStepResultStatusUpdateWithWhereUniqueNestedInput[]
    | KeyStepResultStatusUpdateWithWhereUniqueNestedInput
  >
  upsert?: Maybe<
    | KeyStepResultStatusUpsertWithWhereUniqueNestedInput[]
    | KeyStepResultStatusUpsertWithWhereUniqueNestedInput
  >
  delete?: Maybe<
    KeyStepResultStatusWhereUniqueInput[] | KeyStepResultStatusWhereUniqueInput
  >
  connect?: Maybe<
    KeyStepResultStatusWhereUniqueInput[] | KeyStepResultStatusWhereUniqueInput
  >
  set?: Maybe<
    KeyStepResultStatusWhereUniqueInput[] | KeyStepResultStatusWhereUniqueInput
  >
  disconnect?: Maybe<
    KeyStepResultStatusWhereUniqueInput[] | KeyStepResultStatusWhereUniqueInput
  >
  deleteMany?: Maybe<
    KeyStepResultStatusScalarWhereInput[] | KeyStepResultStatusScalarWhereInput
  >
  updateMany?: Maybe<
    | KeyStepResultStatusUpdateManyWithWhereNestedInput[]
    | KeyStepResultStatusUpdateManyWithWhereNestedInput
  >
}

export interface KeyStepResultStatusUpdateWithWhereUniqueNestedInput {
  where: KeyStepResultStatusWhereUniqueInput
  data: KeyStepResultStatusUpdateDataInput
}

export interface KeyStepResultStatusUpdateDataInput {
  key?: Maybe<String>
}

export interface KeyStepResultStatusUpsertWithWhereUniqueNestedInput {
  where: KeyStepResultStatusWhereUniqueInput
  update: KeyStepResultStatusUpdateDataInput
  create: KeyStepResultStatusCreateInput
}

export interface KeyStepResultStatusScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  key?: Maybe<String>
  key_not?: Maybe<String>
  key_in?: Maybe<String[] | String>
  key_not_in?: Maybe<String[] | String>
  key_lt?: Maybe<String>
  key_lte?: Maybe<String>
  key_gt?: Maybe<String>
  key_gte?: Maybe<String>
  key_contains?: Maybe<String>
  key_not_contains?: Maybe<String>
  key_starts_with?: Maybe<String>
  key_not_starts_with?: Maybe<String>
  key_ends_with?: Maybe<String>
  key_not_ends_with?: Maybe<String>
  AND?: Maybe<
    KeyStepResultStatusScalarWhereInput[] | KeyStepResultStatusScalarWhereInput
  >
  OR?: Maybe<
    KeyStepResultStatusScalarWhereInput[] | KeyStepResultStatusScalarWhereInput
  >
  NOT?: Maybe<
    KeyStepResultStatusScalarWhereInput[] | KeyStepResultStatusScalarWhereInput
  >
}

export interface KeyStepResultStatusUpdateManyWithWhereNestedInput {
  where: KeyStepResultStatusScalarWhereInput
  data: KeyStepResultStatusUpdateManyDataInput
}

export interface KeyStepResultStatusUpdateManyDataInput {
  key?: Maybe<String>
}

export interface KeyUpsertNestedInput {
  update: KeyUpdateDataInput
  create: KeyCreateInput
}

export interface TestUpsertWithoutResultsInput {
  update: TestUpdateWithoutResultsDataInput
  create: TestCreateWithoutResultsInput
}

export interface KeyTestResultStatusUpdateOneRequiredInput {
  create?: Maybe<KeyTestResultStatusCreateInput>
  update?: Maybe<KeyTestResultStatusUpdateDataInput>
  upsert?: Maybe<KeyTestResultStatusUpsertNestedInput>
  connect?: Maybe<KeyTestResultStatusWhereUniqueInput>
}

export interface KeyTestResultStatusUpsertNestedInput {
  update: KeyTestResultStatusUpdateDataInput
  create: KeyTestResultStatusCreateInput
}

export interface TestResultUpsertWithoutStepsInput {
  update: TestResultUpdateWithoutStepsDataInput
  create: TestResultCreateWithoutStepsInput
}

export interface KeyStepResultStatusUpdateOneRequiredInput {
  create?: Maybe<KeyStepResultStatusCreateInput>
  update?: Maybe<KeyStepResultStatusUpdateDataInput>
  upsert?: Maybe<KeyStepResultStatusUpsertNestedInput>
  connect?: Maybe<KeyStepResultStatusWhereUniqueInput>
}

export interface KeyStepResultStatusUpsertNestedInput {
  update: KeyStepResultStatusUpdateDataInput
  create: KeyStepResultStatusCreateInput
}

export interface StepResultUpsertWithWhereUniqueWithoutParentInput {
  where: StepResultWhereUniqueInput
  update: StepResultUpdateWithoutParentDataInput
  create: StepResultCreateWithoutParentInput
}

export interface StepResultScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  start?: Maybe<DateTimeInput>
  start_not?: Maybe<DateTimeInput>
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  start_lt?: Maybe<DateTimeInput>
  start_lte?: Maybe<DateTimeInput>
  start_gt?: Maybe<DateTimeInput>
  start_gte?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  end_not?: Maybe<DateTimeInput>
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  end_lt?: Maybe<DateTimeInput>
  end_lte?: Maybe<DateTimeInput>
  end_gt?: Maybe<DateTimeInput>
  end_gte?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  time_not?: Maybe<Int>
  time_in?: Maybe<Int[] | Int>
  time_not_in?: Maybe<Int[] | Int>
  time_lt?: Maybe<Int>
  time_lte?: Maybe<Int>
  time_gt?: Maybe<Int>
  time_gte?: Maybe<Int>
  AND?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
  OR?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
  NOT?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
}

export interface StepResultUpdateManyWithWhereNestedInput {
  where: StepResultScalarWhereInput
  data: StepResultUpdateManyDataInput
}

export interface StepResultUpdateManyDataInput {
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
}

export interface StepUpsertWithWhereUniqueNestedInput {
  where: StepWhereUniqueInput
  update: StepUpdateDataInput
  create: StepCreateInput
}

export interface StepScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  AND?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
  OR?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
  NOT?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>
}

export interface TestResultUpdateManyWithoutParentInput {
  create?: Maybe<
    TestResultCreateWithoutParentInput[] | TestResultCreateWithoutParentInput
  >
  delete?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
  connect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
  set?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
  disconnect?: Maybe<TestResultWhereUniqueInput[] | TestResultWhereUniqueInput>
  update?: Maybe<
    | TestResultUpdateWithWhereUniqueWithoutParentInput[]
    | TestResultUpdateWithWhereUniqueWithoutParentInput
  >
  upsert?: Maybe<
    | TestResultUpsertWithWhereUniqueWithoutParentInput[]
    | TestResultUpsertWithWhereUniqueWithoutParentInput
  >
  deleteMany?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
  updateMany?: Maybe<
    | TestResultUpdateManyWithWhereNestedInput[]
    | TestResultUpdateManyWithWhereNestedInput
  >
}

export interface TestResultUpdateWithWhereUniqueWithoutParentInput {
  where: TestResultWhereUniqueInput
  data: TestResultUpdateWithoutParentDataInput
}

export interface TestResultUpdateWithoutParentDataInput {
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  steps?: Maybe<StepResultUpdateManyWithoutResultInput>
  status?: Maybe<KeyTestResultStatusUpdateOneRequiredInput>
}

export interface StepResultUpdateManyWithoutResultInput {
  create?: Maybe<
    StepResultCreateWithoutResultInput[] | StepResultCreateWithoutResultInput
  >
  delete?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
  connect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
  set?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
  disconnect?: Maybe<StepResultWhereUniqueInput[] | StepResultWhereUniqueInput>
  update?: Maybe<
    | StepResultUpdateWithWhereUniqueWithoutResultInput[]
    | StepResultUpdateWithWhereUniqueWithoutResultInput
  >
  upsert?: Maybe<
    | StepResultUpsertWithWhereUniqueWithoutResultInput[]
    | StepResultUpsertWithWhereUniqueWithoutResultInput
  >
  deleteMany?: Maybe<StepResultScalarWhereInput[] | StepResultScalarWhereInput>
  updateMany?: Maybe<
    | StepResultUpdateManyWithWhereNestedInput[]
    | StepResultUpdateManyWithWhereNestedInput
  >
}

export interface StepResultUpdateWithWhereUniqueWithoutResultInput {
  where: StepResultWhereUniqueInput
  data: StepResultUpdateWithoutResultDataInput
}

export interface StepResultUpdateWithoutResultDataInput {
  parent?: Maybe<StepUpdateOneRequiredWithoutResultsInput>
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  path?: Maybe<MenuUpdateManyInput>
  status?: Maybe<KeyStepResultStatusUpdateOneRequiredInput>
}

export interface StepUpdateOneRequiredWithoutResultsInput {
  create?: Maybe<StepCreateWithoutResultsInput>
  update?: Maybe<StepUpdateWithoutResultsDataInput>
  upsert?: Maybe<StepUpsertWithoutResultsInput>
  connect?: Maybe<StepWhereUniqueInput>
}

export interface StepUpdateWithoutResultsDataInput {
  type?: Maybe<KeyUserTypeUpdateManyInput>
  question?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  targets?: Maybe<MenuUpdateManyInput>
  paths?: Maybe<PathUpdateManyInput>
}

export interface StepUpsertWithoutResultsInput {
  update: StepUpdateWithoutResultsDataInput
  create: StepCreateWithoutResultsInput
}

export interface StepResultUpsertWithWhereUniqueWithoutResultInput {
  where: StepResultWhereUniqueInput
  update: StepResultUpdateWithoutResultDataInput
  create: StepResultCreateWithoutResultInput
}

export interface TestResultUpsertWithWhereUniqueWithoutParentInput {
  where: TestResultWhereUniqueInput
  update: TestResultUpdateWithoutParentDataInput
  create: TestResultCreateWithoutParentInput
}

export interface TestResultScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  start?: Maybe<DateTimeInput>
  start_not?: Maybe<DateTimeInput>
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  start_lt?: Maybe<DateTimeInput>
  start_lte?: Maybe<DateTimeInput>
  start_gt?: Maybe<DateTimeInput>
  start_gte?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  end_not?: Maybe<DateTimeInput>
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
  end_lt?: Maybe<DateTimeInput>
  end_lte?: Maybe<DateTimeInput>
  end_gt?: Maybe<DateTimeInput>
  end_gte?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  time_not?: Maybe<Int>
  time_in?: Maybe<Int[] | Int>
  time_not_in?: Maybe<Int[] | Int>
  time_lt?: Maybe<Int>
  time_lte?: Maybe<Int>
  time_gt?: Maybe<Int>
  time_gte?: Maybe<Int>
  AND?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
  OR?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
  NOT?: Maybe<TestResultScalarWhereInput[] | TestResultScalarWhereInput>
}

export interface TestResultUpdateManyWithWhereNestedInput {
  where: TestResultScalarWhereInput
  data: TestResultUpdateManyDataInput
}

export interface TestResultUpdateManyDataInput {
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
}

export interface TestUpsertWithWhereUniqueWithoutCompanyInput {
  where: TestWhereUniqueInput
  update: TestUpdateWithoutCompanyDataInput
  create: TestCreateWithoutCompanyInput
}

export interface TestScalarWhereInput {
  id?: Maybe<ID_Input>
  id_not?: Maybe<ID_Input>
  id_in?: Maybe<ID_Input[] | ID_Input>
  id_not_in?: Maybe<ID_Input[] | ID_Input>
  id_lt?: Maybe<ID_Input>
  id_lte?: Maybe<ID_Input>
  id_gt?: Maybe<ID_Input>
  id_gte?: Maybe<ID_Input>
  id_contains?: Maybe<ID_Input>
  id_not_contains?: Maybe<ID_Input>
  id_starts_with?: Maybe<ID_Input>
  id_not_starts_with?: Maybe<ID_Input>
  id_ends_with?: Maybe<ID_Input>
  id_not_ends_with?: Maybe<ID_Input>
  AND?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
  OR?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
  NOT?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>
  abbr?: Maybe<String>
}

export interface KeyUpdateInput {
  userTypes?: Maybe<KeyUserTypeUpdateManyInput>
  testResultStatus?: Maybe<KeyTestResultStatusUpdateManyInput>
  stepResultStatus?: Maybe<KeyStepResultStatusUpdateManyInput>
  languages?: Maybe<KeyLanguageUpdateManyInput>
}

export interface KeyLanguageUpdateInput {
  key?: Maybe<String>
}

export interface KeyLanguageUpdateManyMutationInput {
  key?: Maybe<String>
}

export interface KeyStepResultStatusUpdateInput {
  key?: Maybe<String>
}

export interface KeyStepResultStatusUpdateManyMutationInput {
  key?: Maybe<String>
}

export interface KeyTestResultStatusUpdateInput {
  key?: Maybe<String>
}

export interface KeyTestResultStatusUpdateManyMutationInput {
  key?: Maybe<String>
}

export interface KeyUserTypeUpdateInput {
  key?: Maybe<String>
}

export interface KeyUserTypeUpdateManyMutationInput {
  key?: Maybe<String>
}

export interface MenuUpdateInput {
  order?: Maybe<Int>
  root?: Maybe<Boolean>
  menus?: Maybe<MenuUpdateManyWithoutItemsInput>
  name?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  items?: Maybe<MenuUpdateManyWithoutMenusInput>
}

export interface MenuUpdateManyMutationInput {
  order?: Maybe<Int>
  root?: Maybe<Boolean>
}

export interface MessageUpdateInput {
  title?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  message?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
}

export interface MultiLanguageContentUpdateInput {
  pt?: Maybe<String>
  en?: Maybe<String>
}

export interface MultiLanguageContentUpdateManyMutationInput {
  pt?: Maybe<String>
  en?: Maybe<String>
}

export interface PathUpdateInput {
  items?: Maybe<MenuUpdateManyInput>
}

export interface StepUpdateInput {
  type?: Maybe<KeyUserTypeUpdateManyInput>
  question?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  targets?: Maybe<MenuUpdateManyInput>
  paths?: Maybe<PathUpdateManyInput>
  results?: Maybe<StepResultUpdateManyWithoutParentInput>
}

export interface StepResultCreateInput {
  id?: Maybe<ID_Input>
  parent: StepCreateOneWithoutResultsInput
  result: TestResultCreateOneWithoutStepsInput
  start: DateTimeInput
  end: DateTimeInput
  time: Int
  path?: Maybe<MenuCreateManyInput>
  status: KeyStepResultStatusCreateOneInput
}

export interface StepResultUpdateInput {
  parent?: Maybe<StepUpdateOneRequiredWithoutResultsInput>
  result?: Maybe<TestResultUpdateOneRequiredWithoutStepsInput>
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  path?: Maybe<MenuUpdateManyInput>
  status?: Maybe<KeyStepResultStatusUpdateOneRequiredInput>
}

export interface StepResultUpdateManyMutationInput {
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
}

export interface TestCreateInput {
  id?: Maybe<ID_Input>
  publics?: Maybe<KeyUserTypeCreateManyInput>
  languages?: Maybe<KeyLanguageCreateManyInput>
  instruction: MessageCreateOneInput
  company: CompanyCreateOneWithoutTestsInput
  title: MultiLanguageContentCreateOneInput
  steps?: Maybe<StepCreateManyInput>
  menus?: Maybe<MenuCreateManyInput>
  results?: Maybe<TestResultCreateManyWithoutParentInput>
  keys: KeyCreateOneInput
}

export interface TestUpdateInput {
  publics?: Maybe<KeyUserTypeUpdateManyInput>
  languages?: Maybe<KeyLanguageUpdateManyInput>
  instruction?: Maybe<MessageUpdateOneRequiredInput>
  company?: Maybe<CompanyUpdateOneRequiredWithoutTestsInput>
  title?: Maybe<MultiLanguageContentUpdateOneRequiredInput>
  steps?: Maybe<StepUpdateManyInput>
  menus?: Maybe<MenuUpdateManyInput>
  results?: Maybe<TestResultUpdateManyWithoutParentInput>
  keys?: Maybe<KeyUpdateOneRequiredInput>
}

export interface TestResultCreateInput {
  id?: Maybe<ID_Input>
  parent: TestCreateOneWithoutResultsInput
  start: DateTimeInput
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  steps?: Maybe<StepResultCreateManyWithoutResultInput>
  status: KeyTestResultStatusCreateOneInput
}

export interface TestResultUpdateInput {
  parent?: Maybe<TestUpdateOneRequiredWithoutResultsInput>
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
  steps?: Maybe<StepResultUpdateManyWithoutResultInput>
  status?: Maybe<KeyTestResultStatusUpdateOneRequiredInput>
}

export interface TestResultUpdateManyMutationInput {
  start?: Maybe<DateTimeInput>
  end?: Maybe<DateTimeInput>
  time?: Maybe<Int>
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<CompanyWhereInput>
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>
}

export interface KeySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<KeyWhereInput>
  AND?: Maybe<KeySubscriptionWhereInput[] | KeySubscriptionWhereInput>
}

export interface KeyLanguageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<KeyLanguageWhereInput>
  AND?: Maybe<
    KeyLanguageSubscriptionWhereInput[] | KeyLanguageSubscriptionWhereInput
  >
}

export interface KeyStepResultStatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<KeyStepResultStatusWhereInput>
  AND?: Maybe<
    | KeyStepResultStatusSubscriptionWhereInput[]
    | KeyStepResultStatusSubscriptionWhereInput
  >
}

export interface KeyTestResultStatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<KeyTestResultStatusWhereInput>
  AND?: Maybe<
    | KeyTestResultStatusSubscriptionWhereInput[]
    | KeyTestResultStatusSubscriptionWhereInput
  >
}

export interface KeyUserTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<KeyUserTypeWhereInput>
  AND?: Maybe<
    KeyUserTypeSubscriptionWhereInput[] | KeyUserTypeSubscriptionWhereInput
  >
}

export interface MenuSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<MenuWhereInput>
  AND?: Maybe<MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput>
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<MessageWhereInput>
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>
}

export interface MultiLanguageContentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<MultiLanguageContentWhereInput>
  AND?: Maybe<
    | MultiLanguageContentSubscriptionWhereInput[]
    | MultiLanguageContentSubscriptionWhereInput
  >
}

export interface PathSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<PathWhereInput>
  AND?: Maybe<PathSubscriptionWhereInput[] | PathSubscriptionWhereInput>
}

export interface StepSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<StepWhereInput>
  AND?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>
}

export interface StepResultSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<StepResultWhereInput>
  AND?: Maybe<
    StepResultSubscriptionWhereInput[] | StepResultSubscriptionWhereInput
  >
}

export interface TestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<TestWhereInput>
  AND?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>
}

export interface TestResultSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>
  updatedFields_contains?: Maybe<String>
  updatedFields_contains_every?: Maybe<String[] | String>
  updatedFields_contains_some?: Maybe<String[] | String>
  node?: Maybe<TestResultWhereInput>
  AND?: Maybe<
    TestResultSubscriptionWhereInput[] | TestResultSubscriptionWhereInput
  >
}

export interface NodeNode {
  id: ID_Output
}

export interface Company {
  id: ID_Output
  name: String
  abbr?: String
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>
  name: () => Promise<String>
  abbr: () => Promise<String>
  welcome: <T = MessagePromise>() => T
  tests: <T = FragmentableArray<Test>>(args?: {
    where?: TestWhereInput
    orderBy?: TestOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  name: () => Promise<AsyncIterator<String>>
  abbr: () => Promise<AsyncIterator<String>>
  welcome: <T = MessageSubscription>() => T
  tests: <T = Promise<AsyncIterator<TestSubscription>>>(args?: {
    where?: TestWhereInput
    orderBy?: TestOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  name: () => Promise<String>
  abbr: () => Promise<String>
  welcome: <T = MessagePromise>() => T
  tests: <T = FragmentableArray<Test>>(args?: {
    where?: TestWhereInput
    orderBy?: TestOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface Message {
  id: ID_Output
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>
  title: <T = MultiLanguageContentPromise>() => T
  message: <T = MultiLanguageContentPromise>() => T
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  title: <T = MultiLanguageContentSubscription>() => T
  message: <T = MultiLanguageContentSubscription>() => T
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  title: <T = MultiLanguageContentPromise>() => T
  message: <T = MultiLanguageContentPromise>() => T
}

export interface MultiLanguageContent {
  id: ID_Output
  pt: String
  en?: String
}

export interface MultiLanguageContentPromise
  extends Promise<MultiLanguageContent>,
    Fragmentable {
  id: () => Promise<ID_Output>
  pt: () => Promise<String>
  en: () => Promise<String>
}

export interface MultiLanguageContentSubscription
  extends Promise<AsyncIterator<MultiLanguageContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  pt: () => Promise<AsyncIterator<String>>
  en: () => Promise<AsyncIterator<String>>
}

export interface MultiLanguageContentNullablePromise
  extends Promise<MultiLanguageContent | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  pt: () => Promise<String>
  en: () => Promise<String>
}

export interface Test {
  id: ID_Output
}

export interface TestPromise extends Promise<Test>, Fragmentable {
  id: () => Promise<ID_Output>
  publics: <T = FragmentableArray<KeyUserType>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  languages: <T = FragmentableArray<KeyLanguage>>(args?: {
    where?: KeyLanguageWhereInput
    orderBy?: KeyLanguageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  instruction: <T = MessagePromise>() => T
  company: <T = CompanyPromise>() => T
  title: <T = MultiLanguageContentPromise>() => T
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput
    orderBy?: StepOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  menus: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  results: <T = FragmentableArray<TestResult>>(args?: {
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  keys: <T = KeyPromise>() => T
}

export interface TestSubscription
  extends Promise<AsyncIterator<Test>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  publics: <T = Promise<AsyncIterator<KeyUserTypeSubscription>>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  languages: <T = Promise<AsyncIterator<KeyLanguageSubscription>>>(args?: {
    where?: KeyLanguageWhereInput
    orderBy?: KeyLanguageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  instruction: <T = MessageSubscription>() => T
  company: <T = CompanySubscription>() => T
  title: <T = MultiLanguageContentSubscription>() => T
  steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
    where?: StepWhereInput
    orderBy?: StepOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  results: <T = Promise<AsyncIterator<TestResultSubscription>>>(args?: {
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  keys: <T = KeySubscription>() => T
}

export interface TestNullablePromise
  extends Promise<Test | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  publics: <T = FragmentableArray<KeyUserType>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  languages: <T = FragmentableArray<KeyLanguage>>(args?: {
    where?: KeyLanguageWhereInput
    orderBy?: KeyLanguageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  instruction: <T = MessagePromise>() => T
  company: <T = CompanyPromise>() => T
  title: <T = MultiLanguageContentPromise>() => T
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput
    orderBy?: StepOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  menus: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  results: <T = FragmentableArray<TestResult>>(args?: {
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  keys: <T = KeyPromise>() => T
}

export interface KeyUserType {
  id: ID_Output
  key: String
}

export interface KeyUserTypePromise extends Promise<KeyUserType>, Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyUserTypeSubscription
  extends Promise<AsyncIterator<KeyUserType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  key: () => Promise<AsyncIterator<String>>
}

export interface KeyUserTypeNullablePromise
  extends Promise<KeyUserType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyLanguage {
  id: ID_Output
  key: String
}

export interface KeyLanguagePromise extends Promise<KeyLanguage>, Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyLanguageSubscription
  extends Promise<AsyncIterator<KeyLanguage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  key: () => Promise<AsyncIterator<String>>
}

export interface KeyLanguageNullablePromise
  extends Promise<KeyLanguage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface Step {
  id: ID_Output
}

export interface StepPromise extends Promise<Step>, Fragmentable {
  id: () => Promise<ID_Output>
  type: <T = FragmentableArray<KeyUserType>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  question: <T = MultiLanguageContentPromise>() => T
  targets: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  paths: <T = FragmentableArray<Path>>(args?: {
    where?: PathWhereInput
    orderBy?: PathOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  results: <T = FragmentableArray<StepResult>>(args?: {
    where?: StepResultWhereInput
    orderBy?: StepResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface StepSubscription
  extends Promise<AsyncIterator<Step>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  type: <T = Promise<AsyncIterator<KeyUserTypeSubscription>>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  question: <T = MultiLanguageContentSubscription>() => T
  targets: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  paths: <T = Promise<AsyncIterator<PathSubscription>>>(args?: {
    where?: PathWhereInput
    orderBy?: PathOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  results: <T = Promise<AsyncIterator<StepResultSubscription>>>(args?: {
    where?: StepResultWhereInput
    orderBy?: StepResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface StepNullablePromise
  extends Promise<Step | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  type: <T = FragmentableArray<KeyUserType>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  question: <T = MultiLanguageContentPromise>() => T
  targets: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  paths: <T = FragmentableArray<Path>>(args?: {
    where?: PathWhereInput
    orderBy?: PathOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  results: <T = FragmentableArray<StepResult>>(args?: {
    where?: StepResultWhereInput
    orderBy?: StepResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface Menu {
  id: ID_Output
  order?: Int
  root: Boolean
}

export interface MenuPromise extends Promise<Menu>, Fragmentable {
  id: () => Promise<ID_Output>
  order: () => Promise<Int>
  root: () => Promise<Boolean>
  menus: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  name: <T = MultiLanguageContentPromise>() => T
  items: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface MenuSubscription
  extends Promise<AsyncIterator<Menu>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  order: () => Promise<AsyncIterator<Int>>
  root: () => Promise<AsyncIterator<Boolean>>
  menus: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  name: <T = MultiLanguageContentSubscription>() => T
  items: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface MenuNullablePromise
  extends Promise<Menu | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  order: () => Promise<Int>
  root: () => Promise<Boolean>
  menus: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  name: <T = MultiLanguageContentPromise>() => T
  items: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface Path {
  id: ID_Output
}

export interface PathPromise extends Promise<Path>, Fragmentable {
  id: () => Promise<ID_Output>
  items: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface PathSubscription
  extends Promise<AsyncIterator<Path>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  items: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface PathNullablePromise
  extends Promise<Path | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  items: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface StepResult {
  id: ID_Output
  start: DateTimeOutput
  end: DateTimeOutput
  time: Int
}

export interface StepResultPromise extends Promise<StepResult>, Fragmentable {
  id: () => Promise<ID_Output>
  parent: <T = StepPromise>() => T
  result: <T = TestResultPromise>() => T
  start: () => Promise<DateTimeOutput>
  end: () => Promise<DateTimeOutput>
  time: () => Promise<Int>
  path: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  status: <T = KeyStepResultStatusPromise>() => T
}

export interface StepResultSubscription
  extends Promise<AsyncIterator<StepResult>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  parent: <T = StepSubscription>() => T
  result: <T = TestResultSubscription>() => T
  start: () => Promise<AsyncIterator<DateTimeOutput>>
  end: () => Promise<AsyncIterator<DateTimeOutput>>
  time: () => Promise<AsyncIterator<Int>>
  path: <T = Promise<AsyncIterator<MenuSubscription>>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  status: <T = KeyStepResultStatusSubscription>() => T
}

export interface StepResultNullablePromise
  extends Promise<StepResult | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  parent: <T = StepPromise>() => T
  result: <T = TestResultPromise>() => T
  start: () => Promise<DateTimeOutput>
  end: () => Promise<DateTimeOutput>
  time: () => Promise<Int>
  path: <T = FragmentableArray<Menu>>(args?: {
    where?: MenuWhereInput
    orderBy?: MenuOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  status: <T = KeyStepResultStatusPromise>() => T
}

export interface TestResult {
  id: ID_Output
  start: DateTimeOutput
  end?: DateTimeOutput
  time?: Int
}

export interface TestResultPromise extends Promise<TestResult>, Fragmentable {
  id: () => Promise<ID_Output>
  parent: <T = TestPromise>() => T
  start: () => Promise<DateTimeOutput>
  end: () => Promise<DateTimeOutput>
  time: () => Promise<Int>
  steps: <T = FragmentableArray<StepResult>>(args?: {
    where?: StepResultWhereInput
    orderBy?: StepResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  status: <T = KeyTestResultStatusPromise>() => T
}

export interface TestResultSubscription
  extends Promise<AsyncIterator<TestResult>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  parent: <T = TestSubscription>() => T
  start: () => Promise<AsyncIterator<DateTimeOutput>>
  end: () => Promise<AsyncIterator<DateTimeOutput>>
  time: () => Promise<AsyncIterator<Int>>
  steps: <T = Promise<AsyncIterator<StepResultSubscription>>>(args?: {
    where?: StepResultWhereInput
    orderBy?: StepResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  status: <T = KeyTestResultStatusSubscription>() => T
}

export interface TestResultNullablePromise
  extends Promise<TestResult | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  parent: <T = TestPromise>() => T
  start: () => Promise<DateTimeOutput>
  end: () => Promise<DateTimeOutput>
  time: () => Promise<Int>
  steps: <T = FragmentableArray<StepResult>>(args?: {
    where?: StepResultWhereInput
    orderBy?: StepResultOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  status: <T = KeyTestResultStatusPromise>() => T
}

export interface KeyTestResultStatus {
  id: ID_Output
  key: String
}

export interface KeyTestResultStatusPromise
  extends Promise<KeyTestResultStatus>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyTestResultStatusSubscription
  extends Promise<AsyncIterator<KeyTestResultStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  key: () => Promise<AsyncIterator<String>>
}

export interface KeyTestResultStatusNullablePromise
  extends Promise<KeyTestResultStatus | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyStepResultStatus {
  id: ID_Output
  key: String
}

export interface KeyStepResultStatusPromise
  extends Promise<KeyStepResultStatus>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyStepResultStatusSubscription
  extends Promise<AsyncIterator<KeyStepResultStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  key: () => Promise<AsyncIterator<String>>
}

export interface KeyStepResultStatusNullablePromise
  extends Promise<KeyStepResultStatus | null>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface Key {
  id: ID_Output
}

export interface KeyPromise extends Promise<Key>, Fragmentable {
  id: () => Promise<ID_Output>
  userTypes: <T = FragmentableArray<KeyUserType>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  testResultStatus: <T = FragmentableArray<KeyTestResultStatus>>(args?: {
    where?: KeyTestResultStatusWhereInput
    orderBy?: KeyTestResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  stepResultStatus: <T = FragmentableArray<KeyStepResultStatus>>(args?: {
    where?: KeyStepResultStatusWhereInput
    orderBy?: KeyStepResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  languages: <T = FragmentableArray<KeyLanguage>>(args?: {
    where?: KeyLanguageWhereInput
    orderBy?: KeyLanguageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface KeySubscription
  extends Promise<AsyncIterator<Key>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  userTypes: <T = Promise<AsyncIterator<KeyUserTypeSubscription>>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  testResultStatus: <
    T = Promise<AsyncIterator<KeyTestResultStatusSubscription>>
  >(args?: {
    where?: KeyTestResultStatusWhereInput
    orderBy?: KeyTestResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  stepResultStatus: <
    T = Promise<AsyncIterator<KeyStepResultStatusSubscription>>
  >(args?: {
    where?: KeyStepResultStatusWhereInput
    orderBy?: KeyStepResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  languages: <T = Promise<AsyncIterator<KeyLanguageSubscription>>>(args?: {
    where?: KeyLanguageWhereInput
    orderBy?: KeyLanguageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface KeyNullablePromise extends Promise<Key | null>, Fragmentable {
  id: () => Promise<ID_Output>
  userTypes: <T = FragmentableArray<KeyUserType>>(args?: {
    where?: KeyUserTypeWhereInput
    orderBy?: KeyUserTypeOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  testResultStatus: <T = FragmentableArray<KeyTestResultStatus>>(args?: {
    where?: KeyTestResultStatusWhereInput
    orderBy?: KeyTestResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  stepResultStatus: <T = FragmentableArray<KeyStepResultStatus>>(args?: {
    where?: KeyStepResultStatusWhereInput
    orderBy?: KeyStepResultStatusOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
  languages: <T = FragmentableArray<KeyLanguage>>(args?: {
    where?: KeyLanguageWhereInput
    orderBy?: KeyLanguageOrderByInput
    skip?: Int
    after?: String
    before?: String
    first?: Int
    last?: Int
  }) => T
}

export interface CompanyConnection {
  pageInfo: PageInfo
  edges: CompanyEdge[]
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<CompanyEdge>>() => T
  aggregate: <T = AggregateCompanyPromise>() => T
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T
  aggregate: <T = AggregateCompanySubscription>() => T
}

export interface PageInfo {
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor?: String
  endCursor?: String
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>
  hasPreviousPage: () => Promise<Boolean>
  startCursor: () => Promise<String>
  endCursor: () => Promise<String>
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>
  startCursor: () => Promise<AsyncIterator<String>>
  endCursor: () => Promise<AsyncIterator<String>>
}

export interface CompanyEdge {
  node: Company
  cursor: String
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T
  cursor: () => Promise<String>
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateCompany {
  count: Int
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface KeyConnection {
  pageInfo: PageInfo
  edges: KeyEdge[]
}

export interface KeyConnectionPromise
  extends Promise<KeyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<KeyEdge>>() => T
  aggregate: <T = AggregateKeyPromise>() => T
}

export interface KeyConnectionSubscription
  extends Promise<AsyncIterator<KeyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<KeyEdgeSubscription>>>() => T
  aggregate: <T = AggregateKeySubscription>() => T
}

export interface KeyEdge {
  node: Key
  cursor: String
}

export interface KeyEdgePromise extends Promise<KeyEdge>, Fragmentable {
  node: <T = KeyPromise>() => T
  cursor: () => Promise<String>
}

export interface KeyEdgeSubscription
  extends Promise<AsyncIterator<KeyEdge>>,
    Fragmentable {
  node: <T = KeySubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateKey {
  count: Int
}

export interface AggregateKeyPromise
  extends Promise<AggregateKey>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateKeySubscription
  extends Promise<AsyncIterator<AggregateKey>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface KeyLanguageConnection {
  pageInfo: PageInfo
  edges: KeyLanguageEdge[]
}

export interface KeyLanguageConnectionPromise
  extends Promise<KeyLanguageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<KeyLanguageEdge>>() => T
  aggregate: <T = AggregateKeyLanguagePromise>() => T
}

export interface KeyLanguageConnectionSubscription
  extends Promise<AsyncIterator<KeyLanguageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<KeyLanguageEdgeSubscription>>>() => T
  aggregate: <T = AggregateKeyLanguageSubscription>() => T
}

export interface KeyLanguageEdge {
  node: KeyLanguage
  cursor: String
}

export interface KeyLanguageEdgePromise
  extends Promise<KeyLanguageEdge>,
    Fragmentable {
  node: <T = KeyLanguagePromise>() => T
  cursor: () => Promise<String>
}

export interface KeyLanguageEdgeSubscription
  extends Promise<AsyncIterator<KeyLanguageEdge>>,
    Fragmentable {
  node: <T = KeyLanguageSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateKeyLanguage {
  count: Int
}

export interface AggregateKeyLanguagePromise
  extends Promise<AggregateKeyLanguage>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateKeyLanguageSubscription
  extends Promise<AsyncIterator<AggregateKeyLanguage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface KeyStepResultStatusConnection {
  pageInfo: PageInfo
  edges: KeyStepResultStatusEdge[]
}

export interface KeyStepResultStatusConnectionPromise
  extends Promise<KeyStepResultStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<KeyStepResultStatusEdge>>() => T
  aggregate: <T = AggregateKeyStepResultStatusPromise>() => T
}

export interface KeyStepResultStatusConnectionSubscription
  extends Promise<AsyncIterator<KeyStepResultStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <
    T = Promise<AsyncIterator<KeyStepResultStatusEdgeSubscription>>
  >() => T
  aggregate: <T = AggregateKeyStepResultStatusSubscription>() => T
}

export interface KeyStepResultStatusEdge {
  node: KeyStepResultStatus
  cursor: String
}

export interface KeyStepResultStatusEdgePromise
  extends Promise<KeyStepResultStatusEdge>,
    Fragmentable {
  node: <T = KeyStepResultStatusPromise>() => T
  cursor: () => Promise<String>
}

export interface KeyStepResultStatusEdgeSubscription
  extends Promise<AsyncIterator<KeyStepResultStatusEdge>>,
    Fragmentable {
  node: <T = KeyStepResultStatusSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateKeyStepResultStatus {
  count: Int
}

export interface AggregateKeyStepResultStatusPromise
  extends Promise<AggregateKeyStepResultStatus>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateKeyStepResultStatusSubscription
  extends Promise<AsyncIterator<AggregateKeyStepResultStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface KeyTestResultStatusConnection {
  pageInfo: PageInfo
  edges: KeyTestResultStatusEdge[]
}

export interface KeyTestResultStatusConnectionPromise
  extends Promise<KeyTestResultStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<KeyTestResultStatusEdge>>() => T
  aggregate: <T = AggregateKeyTestResultStatusPromise>() => T
}

export interface KeyTestResultStatusConnectionSubscription
  extends Promise<AsyncIterator<KeyTestResultStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <
    T = Promise<AsyncIterator<KeyTestResultStatusEdgeSubscription>>
  >() => T
  aggregate: <T = AggregateKeyTestResultStatusSubscription>() => T
}

export interface KeyTestResultStatusEdge {
  node: KeyTestResultStatus
  cursor: String
}

export interface KeyTestResultStatusEdgePromise
  extends Promise<KeyTestResultStatusEdge>,
    Fragmentable {
  node: <T = KeyTestResultStatusPromise>() => T
  cursor: () => Promise<String>
}

export interface KeyTestResultStatusEdgeSubscription
  extends Promise<AsyncIterator<KeyTestResultStatusEdge>>,
    Fragmentable {
  node: <T = KeyTestResultStatusSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateKeyTestResultStatus {
  count: Int
}

export interface AggregateKeyTestResultStatusPromise
  extends Promise<AggregateKeyTestResultStatus>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateKeyTestResultStatusSubscription
  extends Promise<AsyncIterator<AggregateKeyTestResultStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface KeyUserTypeConnection {
  pageInfo: PageInfo
  edges: KeyUserTypeEdge[]
}

export interface KeyUserTypeConnectionPromise
  extends Promise<KeyUserTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<KeyUserTypeEdge>>() => T
  aggregate: <T = AggregateKeyUserTypePromise>() => T
}

export interface KeyUserTypeConnectionSubscription
  extends Promise<AsyncIterator<KeyUserTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<KeyUserTypeEdgeSubscription>>>() => T
  aggregate: <T = AggregateKeyUserTypeSubscription>() => T
}

export interface KeyUserTypeEdge {
  node: KeyUserType
  cursor: String
}

export interface KeyUserTypeEdgePromise
  extends Promise<KeyUserTypeEdge>,
    Fragmentable {
  node: <T = KeyUserTypePromise>() => T
  cursor: () => Promise<String>
}

export interface KeyUserTypeEdgeSubscription
  extends Promise<AsyncIterator<KeyUserTypeEdge>>,
    Fragmentable {
  node: <T = KeyUserTypeSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateKeyUserType {
  count: Int
}

export interface AggregateKeyUserTypePromise
  extends Promise<AggregateKeyUserType>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateKeyUserTypeSubscription
  extends Promise<AsyncIterator<AggregateKeyUserType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface MenuConnection {
  pageInfo: PageInfo
  edges: MenuEdge[]
}

export interface MenuConnectionPromise
  extends Promise<MenuConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<MenuEdge>>() => T
  aggregate: <T = AggregateMenuPromise>() => T
}

export interface MenuConnectionSubscription
  extends Promise<AsyncIterator<MenuConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<MenuEdgeSubscription>>>() => T
  aggregate: <T = AggregateMenuSubscription>() => T
}

export interface MenuEdge {
  node: Menu
  cursor: String
}

export interface MenuEdgePromise extends Promise<MenuEdge>, Fragmentable {
  node: <T = MenuPromise>() => T
  cursor: () => Promise<String>
}

export interface MenuEdgeSubscription
  extends Promise<AsyncIterator<MenuEdge>>,
    Fragmentable {
  node: <T = MenuSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateMenu {
  count: Int
}

export interface AggregateMenuPromise
  extends Promise<AggregateMenu>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateMenuSubscription
  extends Promise<AsyncIterator<AggregateMenu>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface MessageConnection {
  pageInfo: PageInfo
  edges: MessageEdge[]
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<MessageEdge>>() => T
  aggregate: <T = AggregateMessagePromise>() => T
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T
  aggregate: <T = AggregateMessageSubscription>() => T
}

export interface MessageEdge {
  node: Message
  cursor: String
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T
  cursor: () => Promise<String>
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateMessage {
  count: Int
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface MultiLanguageContentConnection {
  pageInfo: PageInfo
  edges: MultiLanguageContentEdge[]
}

export interface MultiLanguageContentConnectionPromise
  extends Promise<MultiLanguageContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<MultiLanguageContentEdge>>() => T
  aggregate: <T = AggregateMultiLanguageContentPromise>() => T
}

export interface MultiLanguageContentConnectionSubscription
  extends Promise<AsyncIterator<MultiLanguageContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <
    T = Promise<AsyncIterator<MultiLanguageContentEdgeSubscription>>
  >() => T
  aggregate: <T = AggregateMultiLanguageContentSubscription>() => T
}

export interface MultiLanguageContentEdge {
  node: MultiLanguageContent
  cursor: String
}

export interface MultiLanguageContentEdgePromise
  extends Promise<MultiLanguageContentEdge>,
    Fragmentable {
  node: <T = MultiLanguageContentPromise>() => T
  cursor: () => Promise<String>
}

export interface MultiLanguageContentEdgeSubscription
  extends Promise<AsyncIterator<MultiLanguageContentEdge>>,
    Fragmentable {
  node: <T = MultiLanguageContentSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateMultiLanguageContent {
  count: Int
}

export interface AggregateMultiLanguageContentPromise
  extends Promise<AggregateMultiLanguageContent>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateMultiLanguageContentSubscription
  extends Promise<AsyncIterator<AggregateMultiLanguageContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface PathConnection {
  pageInfo: PageInfo
  edges: PathEdge[]
}

export interface PathConnectionPromise
  extends Promise<PathConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<PathEdge>>() => T
  aggregate: <T = AggregatePathPromise>() => T
}

export interface PathConnectionSubscription
  extends Promise<AsyncIterator<PathConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<PathEdgeSubscription>>>() => T
  aggregate: <T = AggregatePathSubscription>() => T
}

export interface PathEdge {
  node: Path
  cursor: String
}

export interface PathEdgePromise extends Promise<PathEdge>, Fragmentable {
  node: <T = PathPromise>() => T
  cursor: () => Promise<String>
}

export interface PathEdgeSubscription
  extends Promise<AsyncIterator<PathEdge>>,
    Fragmentable {
  node: <T = PathSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregatePath {
  count: Int
}

export interface AggregatePathPromise
  extends Promise<AggregatePath>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregatePathSubscription
  extends Promise<AsyncIterator<AggregatePath>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface StepConnection {
  pageInfo: PageInfo
  edges: StepEdge[]
}

export interface StepConnectionPromise
  extends Promise<StepConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<StepEdge>>() => T
  aggregate: <T = AggregateStepPromise>() => T
}

export interface StepConnectionSubscription
  extends Promise<AsyncIterator<StepConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<StepEdgeSubscription>>>() => T
  aggregate: <T = AggregateStepSubscription>() => T
}

export interface StepEdge {
  node: Step
  cursor: String
}

export interface StepEdgePromise extends Promise<StepEdge>, Fragmentable {
  node: <T = StepPromise>() => T
  cursor: () => Promise<String>
}

export interface StepEdgeSubscription
  extends Promise<AsyncIterator<StepEdge>>,
    Fragmentable {
  node: <T = StepSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateStep {
  count: Int
}

export interface AggregateStepPromise
  extends Promise<AggregateStep>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateStepSubscription
  extends Promise<AsyncIterator<AggregateStep>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface StepResultConnection {
  pageInfo: PageInfo
  edges: StepResultEdge[]
}

export interface StepResultConnectionPromise
  extends Promise<StepResultConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<StepResultEdge>>() => T
  aggregate: <T = AggregateStepResultPromise>() => T
}

export interface StepResultConnectionSubscription
  extends Promise<AsyncIterator<StepResultConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<StepResultEdgeSubscription>>>() => T
  aggregate: <T = AggregateStepResultSubscription>() => T
}

export interface StepResultEdge {
  node: StepResult
  cursor: String
}

export interface StepResultEdgePromise
  extends Promise<StepResultEdge>,
    Fragmentable {
  node: <T = StepResultPromise>() => T
  cursor: () => Promise<String>
}

export interface StepResultEdgeSubscription
  extends Promise<AsyncIterator<StepResultEdge>>,
    Fragmentable {
  node: <T = StepResultSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateStepResult {
  count: Int
}

export interface AggregateStepResultPromise
  extends Promise<AggregateStepResult>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateStepResultSubscription
  extends Promise<AsyncIterator<AggregateStepResult>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface TestConnection {
  pageInfo: PageInfo
  edges: TestEdge[]
}

export interface TestConnectionPromise
  extends Promise<TestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<TestEdge>>() => T
  aggregate: <T = AggregateTestPromise>() => T
}

export interface TestConnectionSubscription
  extends Promise<AsyncIterator<TestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<TestEdgeSubscription>>>() => T
  aggregate: <T = AggregateTestSubscription>() => T
}

export interface TestEdge {
  node: Test
  cursor: String
}

export interface TestEdgePromise extends Promise<TestEdge>, Fragmentable {
  node: <T = TestPromise>() => T
  cursor: () => Promise<String>
}

export interface TestEdgeSubscription
  extends Promise<AsyncIterator<TestEdge>>,
    Fragmentable {
  node: <T = TestSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTest {
  count: Int
}

export interface AggregateTestPromise
  extends Promise<AggregateTest>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateTestSubscription
  extends Promise<AsyncIterator<AggregateTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface TestResultConnection {
  pageInfo: PageInfo
  edges: TestResultEdge[]
}

export interface TestResultConnectionPromise
  extends Promise<TestResultConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T
  edges: <T = FragmentableArray<TestResultEdge>>() => T
  aggregate: <T = AggregateTestResultPromise>() => T
}

export interface TestResultConnectionSubscription
  extends Promise<AsyncIterator<TestResultConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T
  edges: <T = Promise<AsyncIterator<TestResultEdgeSubscription>>>() => T
  aggregate: <T = AggregateTestResultSubscription>() => T
}

export interface TestResultEdge {
  node: TestResult
  cursor: String
}

export interface TestResultEdgePromise
  extends Promise<TestResultEdge>,
    Fragmentable {
  node: <T = TestResultPromise>() => T
  cursor: () => Promise<String>
}

export interface TestResultEdgeSubscription
  extends Promise<AsyncIterator<TestResultEdge>>,
    Fragmentable {
  node: <T = TestResultSubscription>() => T
  cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTestResult {
  count: Int
}

export interface AggregateTestResultPromise
  extends Promise<AggregateTestResult>,
    Fragmentable {
  count: () => Promise<Int>
}

export interface AggregateTestResultSubscription
  extends Promise<AsyncIterator<AggregateTestResult>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>
}

export interface BatchPayload {
  count: Long
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>
}

export interface CompanySubscriptionPayload {
  mutation: MutationType
  node: Company
  updatedFields: String[]
  previousValues: CompanyPreviousValues
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = CompanyPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = CompanyPreviousValuesPromise>() => T
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = CompanySubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = CompanyPreviousValuesSubscription>() => T
}

export interface CompanyPreviousValues {
  id: ID_Output
  name: String
  abbr?: String
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  name: () => Promise<String>
  abbr: () => Promise<String>
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  name: () => Promise<AsyncIterator<String>>
  abbr: () => Promise<AsyncIterator<String>>
}

export interface KeySubscriptionPayload {
  mutation: MutationType
  node: Key
  updatedFields: String[]
  previousValues: KeyPreviousValues
}

export interface KeySubscriptionPayloadPromise
  extends Promise<KeySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = KeyPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = KeyPreviousValuesPromise>() => T
}

export interface KeySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = KeySubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = KeyPreviousValuesSubscription>() => T
}

export interface KeyPreviousValues {
  id: ID_Output
}

export interface KeyPreviousValuesPromise
  extends Promise<KeyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
}

export interface KeyPreviousValuesSubscription
  extends Promise<AsyncIterator<KeyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
}

export interface KeyLanguageSubscriptionPayload {
  mutation: MutationType
  node: KeyLanguage
  updatedFields: String[]
  previousValues: KeyLanguagePreviousValues
}

export interface KeyLanguageSubscriptionPayloadPromise
  extends Promise<KeyLanguageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = KeyLanguagePromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = KeyLanguagePreviousValuesPromise>() => T
}

export interface KeyLanguageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeyLanguageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = KeyLanguageSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = KeyLanguagePreviousValuesSubscription>() => T
}

export interface KeyLanguagePreviousValues {
  id: ID_Output
  key: String
}

export interface KeyLanguagePreviousValuesPromise
  extends Promise<KeyLanguagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyLanguagePreviousValuesSubscription
  extends Promise<AsyncIterator<KeyLanguagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  key: () => Promise<AsyncIterator<String>>
}

export interface KeyStepResultStatusSubscriptionPayload {
  mutation: MutationType
  node: KeyStepResultStatus
  updatedFields: String[]
  previousValues: KeyStepResultStatusPreviousValues
}

export interface KeyStepResultStatusSubscriptionPayloadPromise
  extends Promise<KeyStepResultStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = KeyStepResultStatusPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = KeyStepResultStatusPreviousValuesPromise>() => T
}

export interface KeyStepResultStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeyStepResultStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = KeyStepResultStatusSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = KeyStepResultStatusPreviousValuesSubscription>() => T
}

export interface KeyStepResultStatusPreviousValues {
  id: ID_Output
  key: String
}

export interface KeyStepResultStatusPreviousValuesPromise
  extends Promise<KeyStepResultStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyStepResultStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<KeyStepResultStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  key: () => Promise<AsyncIterator<String>>
}

export interface KeyTestResultStatusSubscriptionPayload {
  mutation: MutationType
  node: KeyTestResultStatus
  updatedFields: String[]
  previousValues: KeyTestResultStatusPreviousValues
}

export interface KeyTestResultStatusSubscriptionPayloadPromise
  extends Promise<KeyTestResultStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = KeyTestResultStatusPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = KeyTestResultStatusPreviousValuesPromise>() => T
}

export interface KeyTestResultStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeyTestResultStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = KeyTestResultStatusSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = KeyTestResultStatusPreviousValuesSubscription>() => T
}

export interface KeyTestResultStatusPreviousValues {
  id: ID_Output
  key: String
}

export interface KeyTestResultStatusPreviousValuesPromise
  extends Promise<KeyTestResultStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyTestResultStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<KeyTestResultStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  key: () => Promise<AsyncIterator<String>>
}

export interface KeyUserTypeSubscriptionPayload {
  mutation: MutationType
  node: KeyUserType
  updatedFields: String[]
  previousValues: KeyUserTypePreviousValues
}

export interface KeyUserTypeSubscriptionPayloadPromise
  extends Promise<KeyUserTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = KeyUserTypePromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = KeyUserTypePreviousValuesPromise>() => T
}

export interface KeyUserTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeyUserTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = KeyUserTypeSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = KeyUserTypePreviousValuesSubscription>() => T
}

export interface KeyUserTypePreviousValues {
  id: ID_Output
  key: String
}

export interface KeyUserTypePreviousValuesPromise
  extends Promise<KeyUserTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  key: () => Promise<String>
}

export interface KeyUserTypePreviousValuesSubscription
  extends Promise<AsyncIterator<KeyUserTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  key: () => Promise<AsyncIterator<String>>
}

export interface MenuSubscriptionPayload {
  mutation: MutationType
  node: Menu
  updatedFields: String[]
  previousValues: MenuPreviousValues
}

export interface MenuSubscriptionPayloadPromise
  extends Promise<MenuSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = MenuPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = MenuPreviousValuesPromise>() => T
}

export interface MenuSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = MenuSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = MenuPreviousValuesSubscription>() => T
}

export interface MenuPreviousValues {
  id: ID_Output
  order?: Int
  root: Boolean
}

export interface MenuPreviousValuesPromise
  extends Promise<MenuPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  order: () => Promise<Int>
  root: () => Promise<Boolean>
}

export interface MenuPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  order: () => Promise<AsyncIterator<Int>>
  root: () => Promise<AsyncIterator<Boolean>>
}

export interface MessageSubscriptionPayload {
  mutation: MutationType
  node: Message
  updatedFields: String[]
  previousValues: MessagePreviousValues
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = MessagePromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = MessagePreviousValuesPromise>() => T
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = MessageSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = MessagePreviousValuesSubscription>() => T
}

export interface MessagePreviousValues {
  id: ID_Output
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
}

export interface MultiLanguageContentSubscriptionPayload {
  mutation: MutationType
  node: MultiLanguageContent
  updatedFields: String[]
  previousValues: MultiLanguageContentPreviousValues
}

export interface MultiLanguageContentSubscriptionPayloadPromise
  extends Promise<MultiLanguageContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = MultiLanguageContentPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = MultiLanguageContentPreviousValuesPromise>() => T
}

export interface MultiLanguageContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MultiLanguageContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = MultiLanguageContentSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = MultiLanguageContentPreviousValuesSubscription>() => T
}

export interface MultiLanguageContentPreviousValues {
  id: ID_Output
  pt: String
  en?: String
}

export interface MultiLanguageContentPreviousValuesPromise
  extends Promise<MultiLanguageContentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  pt: () => Promise<String>
  en: () => Promise<String>
}

export interface MultiLanguageContentPreviousValuesSubscription
  extends Promise<AsyncIterator<MultiLanguageContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  pt: () => Promise<AsyncIterator<String>>
  en: () => Promise<AsyncIterator<String>>
}

export interface PathSubscriptionPayload {
  mutation: MutationType
  node: Path
  updatedFields: String[]
  previousValues: PathPreviousValues
}

export interface PathSubscriptionPayloadPromise
  extends Promise<PathSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = PathPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = PathPreviousValuesPromise>() => T
}

export interface PathSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PathSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = PathSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = PathPreviousValuesSubscription>() => T
}

export interface PathPreviousValues {
  id: ID_Output
}

export interface PathPreviousValuesPromise
  extends Promise<PathPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
}

export interface PathPreviousValuesSubscription
  extends Promise<AsyncIterator<PathPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
}

export interface StepSubscriptionPayload {
  mutation: MutationType
  node: Step
  updatedFields: String[]
  previousValues: StepPreviousValues
}

export interface StepSubscriptionPayloadPromise
  extends Promise<StepSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = StepPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = StepPreviousValuesPromise>() => T
}

export interface StepSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = StepSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = StepPreviousValuesSubscription>() => T
}

export interface StepPreviousValues {
  id: ID_Output
}

export interface StepPreviousValuesPromise
  extends Promise<StepPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
}

export interface StepPreviousValuesSubscription
  extends Promise<AsyncIterator<StepPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
}

export interface StepResultSubscriptionPayload {
  mutation: MutationType
  node: StepResult
  updatedFields: String[]
  previousValues: StepResultPreviousValues
}

export interface StepResultSubscriptionPayloadPromise
  extends Promise<StepResultSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = StepResultPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = StepResultPreviousValuesPromise>() => T
}

export interface StepResultSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepResultSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = StepResultSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = StepResultPreviousValuesSubscription>() => T
}

export interface StepResultPreviousValues {
  id: ID_Output
  start: DateTimeOutput
  end: DateTimeOutput
  time: Int
}

export interface StepResultPreviousValuesPromise
  extends Promise<StepResultPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  start: () => Promise<DateTimeOutput>
  end: () => Promise<DateTimeOutput>
  time: () => Promise<Int>
}

export interface StepResultPreviousValuesSubscription
  extends Promise<AsyncIterator<StepResultPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  start: () => Promise<AsyncIterator<DateTimeOutput>>
  end: () => Promise<AsyncIterator<DateTimeOutput>>
  time: () => Promise<AsyncIterator<Int>>
}

export interface TestSubscriptionPayload {
  mutation: MutationType
  node: Test
  updatedFields: String[]
  previousValues: TestPreviousValues
}

export interface TestSubscriptionPayloadPromise
  extends Promise<TestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = TestPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = TestPreviousValuesPromise>() => T
}

export interface TestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = TestSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = TestPreviousValuesSubscription>() => T
}

export interface TestPreviousValues {
  id: ID_Output
}

export interface TestPreviousValuesPromise
  extends Promise<TestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
}

export interface TestPreviousValuesSubscription
  extends Promise<AsyncIterator<TestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
}

export interface TestResultSubscriptionPayload {
  mutation: MutationType
  node: TestResult
  updatedFields: String[]
  previousValues: TestResultPreviousValues
}

export interface TestResultSubscriptionPayloadPromise
  extends Promise<TestResultSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>
  node: <T = TestResultPromise>() => T
  updatedFields: () => Promise<String[]>
  previousValues: <T = TestResultPreviousValuesPromise>() => T
}

export interface TestResultSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestResultSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>
  node: <T = TestResultSubscription>() => T
  updatedFields: () => Promise<AsyncIterator<String[]>>
  previousValues: <T = TestResultPreviousValuesSubscription>() => T
}

export interface TestResultPreviousValues {
  id: ID_Output
  start: DateTimeOutput
  end?: DateTimeOutput
  time?: Int
}

export interface TestResultPreviousValuesPromise
  extends Promise<TestResultPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>
  start: () => Promise<DateTimeOutput>
  end: () => Promise<DateTimeOutput>
  time: () => Promise<Int>
}

export interface TestResultPreviousValuesSubscription
  extends Promise<AsyncIterator<TestResultPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>
  start: () => Promise<AsyncIterator<DateTimeOutput>>
  end: () => Promise<AsyncIterator<DateTimeOutput>>
  time: () => Promise<AsyncIterator<Int>>
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number
export type ID_Output = string

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string

export type Long = string

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'Key',
    embedded: false,
  },
  {
    name: 'KeyUserType',
    embedded: false,
  },
  {
    name: 'KeyLanguage',
    embedded: false,
  },
  {
    name: 'KeyTestResultStatus',
    embedded: false,
  },
  {
    name: 'KeyStepResultStatus',
    embedded: false,
  },
  {
    name: 'MultiLanguageContent',
    embedded: false,
  },
  {
    name: 'Message',
    embedded: false,
  },
  {
    name: 'Company',
    embedded: false,
  },
  {
    name: 'Test',
    embedded: false,
  },
  {
    name: 'Menu',
    embedded: false,
  },
  {
    name: 'Path',
    embedded: false,
  },
  {
    name: 'Step',
    embedded: false,
  },
  {
    name: 'TestResult',
    embedded: false,
  },
  {
    name: 'StepResult',
    embedded: false,
  },
]

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env['PRISMA_ENDPOINT']}`,
})
export const prisma = new Prisma()
