### This file was autogenerated by Nexus 0.11.6
### Do not make changes to this file directly

type Company {
   abbr: String
   id: ID!
   logo: String
   name: String!
}

input CompanyWhereInput {
   abbr: String
   abbr_contains: String
   abbr_ends_with: String
   abbr_gt: String
   abbr_gte: String
   abbr_in: [String!]
   abbr_lt: String
   abbr_lte: String
   abbr_not: String
   abbr_not_contains: String
   abbr_not_ends_with: String
   abbr_not_in: [String!]
   abbr_not_starts_with: String
   abbr_starts_with: String
   AND: [CompanyWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   logo: String
   logo_contains: String
   logo_ends_with: String
   logo_gt: String
   logo_gte: String
   logo_in: [String!]
   logo_lt: String
   logo_lte: String
   logo_not: String
   logo_not_contains: String
   logo_not_ends_with: String
   logo_not_in: [String!]
   logo_not_starts_with: String
   logo_starts_with: String
   name: String
   name_contains: String
   name_ends_with: String
   name_gt: String
   name_gte: String
   name_in: [String!]
   name_lt: String
   name_lte: String
   name_not: String
   name_not_contains: String
   name_not_ends_with: String
   name_not_in: [String!]
   name_not_starts_with: String
   name_starts_with: String
   NOT: [CompanyWhereInput!]
   OR: [CompanyWhereInput!]
}

scalar DateTime

type Menu {
   id: ID!
   items(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   menu: Menu
   name: String!
}

input MenuCreateInput {
   id: ID
   items: MenuCreateManyWithoutMenuInput
   menu: MenuCreateOneWithoutItemsInput
   name: String!
}

input MenuCreateManyInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateInput!]
}

input MenuCreateManyWithoutMenuInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateWithoutMenuInput!]
}

input MenuCreateOneInput {
   connect: MenuWhereUniqueInput
   create: MenuCreateInput
}

input MenuCreateOneWithoutItemsInput {
   connect: MenuWhereUniqueInput
   create: MenuCreateWithoutItemsInput
}

input MenuCreateWithoutItemsInput {
   id: ID
   menu: MenuCreateOneWithoutItemsInput
   name: String!
}

input MenuCreateWithoutMenuInput {
   id: ID
   items: MenuCreateManyWithoutMenuInput
   name: String!
}

enum MenuOrderByInput {
   createdAt_ASC
   createdAt_DESC
   id_ASC
   id_DESC
   name_ASC
   name_DESC
   updatedAt_ASC
   updatedAt_DESC
}

input MenuScalarWhereInput {
   AND: [MenuScalarWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   name: String
   name_contains: String
   name_ends_with: String
   name_gt: String
   name_gte: String
   name_in: [String!]
   name_lt: String
   name_lte: String
   name_not: String
   name_not_contains: String
   name_not_ends_with: String
   name_not_in: [String!]
   name_not_starts_with: String
   name_starts_with: String
   NOT: [MenuScalarWhereInput!]
   OR: [MenuScalarWhereInput!]
}

input MenuUpdateDataInput {
   items: MenuUpdateManyWithoutMenuInput
   menu: MenuUpdateOneWithoutItemsInput
   name: String
}

input MenuUpdateManyDataInput {
   name: String
}

input MenuUpdateManyInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateInput!]
   delete: [MenuWhereUniqueInput!]
   deleteMany: [MenuScalarWhereInput!]
   disconnect: [MenuWhereUniqueInput!]
   set: [MenuWhereUniqueInput!]
   update: [MenuUpdateWithWhereUniqueNestedInput!]
   updateMany: [MenuUpdateManyWithWhereNestedInput!]
   upsert: [MenuUpsertWithWhereUniqueNestedInput!]
}

input MenuUpdateManyWithoutMenuInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateWithoutMenuInput!]
   delete: [MenuWhereUniqueInput!]
   deleteMany: [MenuScalarWhereInput!]
   disconnect: [MenuWhereUniqueInput!]
   set: [MenuWhereUniqueInput!]
   update: [MenuUpdateWithWhereUniqueWithoutMenuInput!]
   updateMany: [MenuUpdateManyWithWhereNestedInput!]
   upsert: [MenuUpsertWithWhereUniqueWithoutMenuInput!]
}

input MenuUpdateManyWithWhereNestedInput {
   data: MenuUpdateManyDataInput!
   where: MenuScalarWhereInput!
}

input MenuUpdateOneRequiredInput {
   connect: MenuWhereUniqueInput
   create: MenuCreateInput
   update: MenuUpdateDataInput
   upsert: MenuUpsertNestedInput
}

input MenuUpdateOneWithoutItemsInput {
   connect: MenuWhereUniqueInput
   create: MenuCreateWithoutItemsInput
   delete: Boolean
   disconnect: Boolean
   update: MenuUpdateWithoutItemsDataInput
   upsert: MenuUpsertWithoutItemsInput
}

input MenuUpdateWithoutItemsDataInput {
   menu: MenuUpdateOneWithoutItemsInput
   name: String
}

input MenuUpdateWithoutMenuDataInput {
   items: MenuUpdateManyWithoutMenuInput
   name: String
}

input MenuUpdateWithWhereUniqueNestedInput {
   data: MenuUpdateDataInput!
   where: MenuWhereUniqueInput!
}

input MenuUpdateWithWhereUniqueWithoutMenuInput {
   data: MenuUpdateWithoutMenuDataInput!
   where: MenuWhereUniqueInput!
}

input MenuUpsertNestedInput {
   create: MenuCreateInput!
   update: MenuUpdateDataInput!
}

input MenuUpsertWithoutItemsInput {
   create: MenuCreateWithoutItemsInput!
   update: MenuUpdateWithoutItemsDataInput!
}

input MenuUpsertWithWhereUniqueNestedInput {
   create: MenuCreateInput!
   update: MenuUpdateDataInput!
   where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueWithoutMenuInput {
   create: MenuCreateWithoutMenuInput!
   update: MenuUpdateWithoutMenuDataInput!
   where: MenuWhereUniqueInput!
}

input MenuWhereInput {
   AND: [MenuWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   items_every: MenuWhereInput
   items_none: MenuWhereInput
   items_some: MenuWhereInput
   menu: MenuWhereInput
   name: String
   name_contains: String
   name_ends_with: String
   name_gt: String
   name_gte: String
   name_in: [String!]
   name_lt: String
   name_lte: String
   name_not: String
   name_not_contains: String
   name_not_ends_with: String
   name_not_in: [String!]
   name_not_starts_with: String
   name_starts_with: String
   NOT: [MenuWhereInput!]
   OR: [MenuWhereInput!]
}

input MenuWhereUniqueInput {
   id: ID
}

type Mutation {
   createStepResult(data: StepResultCreateInput!): StepResult!
   createTestResult(data: TestResultCreateInput!): TestResult!
   updateStepResult(
      data: StepResultUpdateInput!
      where: StepResultWhereUniqueInput!
   ): StepResult
   updateTestResult(
      data: TestResultUpdateInput!
      where: TestResultWhereUniqueInput!
   ): TestResult
}

type Query {
   results(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: TestResultOrderByInput
      skip: Int
      where: TestResultWhereInput
   ): [TestResult!]!
   test(where: TestWhereUniqueInput!): Test
   views(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: ViewOrderByInput
      skip: Int
      where: ViewWhereInput
   ): [View!]!
}

enum ResultStatus {
   ABORTED
   FAIL
   PARTIAL
   SUCESSES
}

type Step {
   id: ID!
   path(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   question: String!
   results(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepResultOrderByInput
      skip: Int
      where: StepResultWhereInput
   ): [StepResult!]
   target: Menu!
}

input StepCreateInput {
   id: ID
   path: MenuCreateManyInput
   question: String!
   results: StepResultCreateManyWithoutParentInput
   target: MenuCreateOneInput!
}

input StepCreateManyInput {
   connect: [StepWhereUniqueInput!]
   create: [StepCreateInput!]
}

input StepCreateOneWithoutResultsInput {
   connect: StepWhereUniqueInput
   create: StepCreateWithoutResultsInput
}

input StepCreateWithoutResultsInput {
   id: ID
   path: MenuCreateManyInput
   question: String!
   target: MenuCreateOneInput!
}

enum StepOrderByInput {
   createdAt_ASC
   createdAt_DESC
   id_ASC
   id_DESC
   question_ASC
   question_DESC
   updatedAt_ASC
   updatedAt_DESC
}

type StepResult {
   end: DateTime
   id: ID!
   parent: Step!
   path(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   resultParent: TestResult!
   start: DateTime!
   status: ResultStatus!
   time: TimeResult
}

input StepResultCreateInput {
   end: DateTime
   id: ID
   parent: StepCreateOneWithoutResultsInput!
   path: MenuCreateManyInput
   resultParent: TestResultCreateOneWithoutStepsInput!
   start: DateTime!
   status: ResultStatus
   time: TimeResultCreateOneInput
}

input StepResultCreateManyWithoutParentInput {
   connect: [StepResultWhereUniqueInput!]
   create: [StepResultCreateWithoutParentInput!]
}

input StepResultCreateManyWithoutResultParentInput {
   connect: [StepResultWhereUniqueInput!]
   create: [StepResultCreateWithoutResultParentInput!]
}

input StepResultCreateWithoutParentInput {
   end: DateTime
   id: ID
   path: MenuCreateManyInput
   resultParent: TestResultCreateOneWithoutStepsInput!
   start: DateTime!
   status: ResultStatus
   time: TimeResultCreateOneInput
}

input StepResultCreateWithoutResultParentInput {
   end: DateTime
   id: ID
   parent: StepCreateOneWithoutResultsInput!
   path: MenuCreateManyInput
   start: DateTime!
   status: ResultStatus
   time: TimeResultCreateOneInput
}

enum StepResultOrderByInput {
   createdAt_ASC
   createdAt_DESC
   end_ASC
   end_DESC
   id_ASC
   id_DESC
   start_ASC
   start_DESC
   status_ASC
   status_DESC
   updatedAt_ASC
   updatedAt_DESC
}

input StepResultScalarWhereInput {
   AND: [StepResultScalarWhereInput!]
   end: DateTime
   end_gt: DateTime
   end_gte: DateTime
   end_in: [DateTime!]
   end_lt: DateTime
   end_lte: DateTime
   end_not: DateTime
   end_not_in: [DateTime!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [StepResultScalarWhereInput!]
   OR: [StepResultScalarWhereInput!]
   start: DateTime
   start_gt: DateTime
   start_gte: DateTime
   start_in: [DateTime!]
   start_lt: DateTime
   start_lte: DateTime
   start_not: DateTime
   start_not_in: [DateTime!]
   status: ResultStatus
   status_in: [ResultStatus!]
   status_not: ResultStatus
   status_not_in: [ResultStatus!]
}

input StepResultUpdateInput {
   end: DateTime
   parent: StepUpdateOneRequiredWithoutResultsInput
   path: MenuUpdateManyInput
   resultParent: TestResultUpdateOneRequiredWithoutStepsInput
   start: DateTime
   status: ResultStatus
   time: TimeResultUpdateOneInput
}

input StepResultUpdateManyDataInput {
   end: DateTime
   start: DateTime
   status: ResultStatus
}

input StepResultUpdateManyWithoutParentInput {
   connect: [StepResultWhereUniqueInput!]
   create: [StepResultCreateWithoutParentInput!]
   delete: [StepResultWhereUniqueInput!]
   deleteMany: [StepResultScalarWhereInput!]
   disconnect: [StepResultWhereUniqueInput!]
   set: [StepResultWhereUniqueInput!]
   update: [StepResultUpdateWithWhereUniqueWithoutParentInput!]
   updateMany: [StepResultUpdateManyWithWhereNestedInput!]
   upsert: [StepResultUpsertWithWhereUniqueWithoutParentInput!]
}

input StepResultUpdateManyWithoutResultParentInput {
   connect: [StepResultWhereUniqueInput!]
   create: [StepResultCreateWithoutResultParentInput!]
   delete: [StepResultWhereUniqueInput!]
   deleteMany: [StepResultScalarWhereInput!]
   disconnect: [StepResultWhereUniqueInput!]
   set: [StepResultWhereUniqueInput!]
   update: [StepResultUpdateWithWhereUniqueWithoutResultParentInput!]
   updateMany: [StepResultUpdateManyWithWhereNestedInput!]
   upsert: [StepResultUpsertWithWhereUniqueWithoutResultParentInput!]
}

input StepResultUpdateManyWithWhereNestedInput {
   data: StepResultUpdateManyDataInput!
   where: StepResultScalarWhereInput!
}

input StepResultUpdateWithoutParentDataInput {
   end: DateTime
   path: MenuUpdateManyInput
   resultParent: TestResultUpdateOneRequiredWithoutStepsInput
   start: DateTime
   status: ResultStatus
   time: TimeResultUpdateOneInput
}

input StepResultUpdateWithoutResultParentDataInput {
   end: DateTime
   parent: StepUpdateOneRequiredWithoutResultsInput
   path: MenuUpdateManyInput
   start: DateTime
   status: ResultStatus
   time: TimeResultUpdateOneInput
}

input StepResultUpdateWithWhereUniqueWithoutParentInput {
   data: StepResultUpdateWithoutParentDataInput!
   where: StepResultWhereUniqueInput!
}

input StepResultUpdateWithWhereUniqueWithoutResultParentInput {
   data: StepResultUpdateWithoutResultParentDataInput!
   where: StepResultWhereUniqueInput!
}

input StepResultUpsertWithWhereUniqueWithoutParentInput {
   create: StepResultCreateWithoutParentInput!
   update: StepResultUpdateWithoutParentDataInput!
   where: StepResultWhereUniqueInput!
}

input StepResultUpsertWithWhereUniqueWithoutResultParentInput {
   create: StepResultCreateWithoutResultParentInput!
   update: StepResultUpdateWithoutResultParentDataInput!
   where: StepResultWhereUniqueInput!
}

input StepResultWhereInput {
   AND: [StepResultWhereInput!]
   end: DateTime
   end_gt: DateTime
   end_gte: DateTime
   end_in: [DateTime!]
   end_lt: DateTime
   end_lte: DateTime
   end_not: DateTime
   end_not_in: [DateTime!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [StepResultWhereInput!]
   OR: [StepResultWhereInput!]
   parent: StepWhereInput
   path_every: MenuWhereInput
   path_none: MenuWhereInput
   path_some: MenuWhereInput
   resultParent: TestResultWhereInput
   start: DateTime
   start_gt: DateTime
   start_gte: DateTime
   start_in: [DateTime!]
   start_lt: DateTime
   start_lte: DateTime
   start_not: DateTime
   start_not_in: [DateTime!]
   status: ResultStatus
   status_in: [ResultStatus!]
   status_not: ResultStatus
   status_not_in: [ResultStatus!]
   time: TimeResultWhereInput
}

input StepResultWhereUniqueInput {
   id: ID
}

input StepScalarWhereInput {
   AND: [StepScalarWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [StepScalarWhereInput!]
   OR: [StepScalarWhereInput!]
   question: String
   question_contains: String
   question_ends_with: String
   question_gt: String
   question_gte: String
   question_in: [String!]
   question_lt: String
   question_lte: String
   question_not: String
   question_not_contains: String
   question_not_ends_with: String
   question_not_in: [String!]
   question_not_starts_with: String
   question_starts_with: String
}

input StepUpdateDataInput {
   path: MenuUpdateManyInput
   question: String
   results: StepResultUpdateManyWithoutParentInput
   target: MenuUpdateOneRequiredInput
}

input StepUpdateManyDataInput {
   question: String
}

input StepUpdateManyInput {
   connect: [StepWhereUniqueInput!]
   create: [StepCreateInput!]
   delete: [StepWhereUniqueInput!]
   deleteMany: [StepScalarWhereInput!]
   disconnect: [StepWhereUniqueInput!]
   set: [StepWhereUniqueInput!]
   update: [StepUpdateWithWhereUniqueNestedInput!]
   updateMany: [StepUpdateManyWithWhereNestedInput!]
   upsert: [StepUpsertWithWhereUniqueNestedInput!]
}

input StepUpdateManyWithWhereNestedInput {
   data: StepUpdateManyDataInput!
   where: StepScalarWhereInput!
}

input StepUpdateOneRequiredWithoutResultsInput {
   connect: StepWhereUniqueInput
   create: StepCreateWithoutResultsInput
   update: StepUpdateWithoutResultsDataInput
   upsert: StepUpsertWithoutResultsInput
}

input StepUpdateWithoutResultsDataInput {
   path: MenuUpdateManyInput
   question: String
   target: MenuUpdateOneRequiredInput
}

input StepUpdateWithWhereUniqueNestedInput {
   data: StepUpdateDataInput!
   where: StepWhereUniqueInput!
}

input StepUpsertWithoutResultsInput {
   create: StepCreateWithoutResultsInput!
   update: StepUpdateWithoutResultsDataInput!
}

input StepUpsertWithWhereUniqueNestedInput {
   create: StepCreateInput!
   update: StepUpdateDataInput!
   where: StepWhereUniqueInput!
}

input StepWhereInput {
   AND: [StepWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [StepWhereInput!]
   OR: [StepWhereInput!]
   path_every: MenuWhereInput
   path_none: MenuWhereInput
   path_some: MenuWhereInput
   question: String
   question_contains: String
   question_ends_with: String
   question_gt: String
   question_gte: String
   question_in: [String!]
   question_lt: String
   question_lte: String
   question_not: String
   question_not_contains: String
   question_not_ends_with: String
   question_not_in: [String!]
   question_not_starts_with: String
   question_starts_with: String
   results_every: StepResultWhereInput
   results_none: StepResultWhereInput
   results_some: StepResultWhereInput
   target: MenuWhereInput
}

input StepWhereUniqueInput {
   id: ID
}

type Test {
   id: ID!
   menus(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   results(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: TestResultOrderByInput
      skip: Int
      where: TestResultWhereInput
   ): [TestResult!]
   steps(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepOrderByInput
      skip: Int
      where: StepWhereInput
   ): [Step!]
   title: String!
}

input TestCreateOneWithoutResultsInput {
   connect: TestWhereUniqueInput
   create: TestCreateWithoutResultsInput
}

input TestCreateWithoutResultsInput {
   id: ID
   menus: MenuCreateManyInput
   steps: StepCreateManyInput
   title: String!
}

enum TestOrderByInput {
   createdAt_ASC
   createdAt_DESC
   id_ASC
   id_DESC
   title_ASC
   title_DESC
   updatedAt_ASC
   updatedAt_DESC
}

type TestResult {
   end: DateTime
   id: ID!
   parent: Test!
   start: DateTime!
   status: ResultStatus!
   steps(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepResultOrderByInput
      skip: Int
      where: StepResultWhereInput
   ): [StepResult!]
   time: TimeResult
}

input TestResultCreateInput {
   end: DateTime
   id: ID
   parent: TestCreateOneWithoutResultsInput!
   start: DateTime!
   status: ResultStatus
   steps: StepResultCreateManyWithoutResultParentInput
   time: TimeResultCreateOneInput
}

input TestResultCreateOneWithoutStepsInput {
   connect: TestResultWhereUniqueInput
   create: TestResultCreateWithoutStepsInput
}

input TestResultCreateWithoutStepsInput {
   end: DateTime
   id: ID
   parent: TestCreateOneWithoutResultsInput!
   start: DateTime!
   status: ResultStatus
   time: TimeResultCreateOneInput
}

enum TestResultOrderByInput {
   createdAt_ASC
   createdAt_DESC
   end_ASC
   end_DESC
   id_ASC
   id_DESC
   start_ASC
   start_DESC
   status_ASC
   status_DESC
   updatedAt_ASC
   updatedAt_DESC
}

input TestResultUpdateInput {
   end: DateTime
   parent: TestUpdateOneRequiredWithoutResultsInput
   start: DateTime
   status: ResultStatus
   steps: StepResultUpdateManyWithoutResultParentInput
   time: TimeResultUpdateOneInput
}

input TestResultUpdateOneRequiredWithoutStepsInput {
   connect: TestResultWhereUniqueInput
   create: TestResultCreateWithoutStepsInput
   update: TestResultUpdateWithoutStepsDataInput
   upsert: TestResultUpsertWithoutStepsInput
}

input TestResultUpdateWithoutStepsDataInput {
   end: DateTime
   parent: TestUpdateOneRequiredWithoutResultsInput
   start: DateTime
   status: ResultStatus
   time: TimeResultUpdateOneInput
}

input TestResultUpsertWithoutStepsInput {
   create: TestResultCreateWithoutStepsInput!
   update: TestResultUpdateWithoutStepsDataInput!
}

input TestResultWhereInput {
   AND: [TestResultWhereInput!]
   end: DateTime
   end_gt: DateTime
   end_gte: DateTime
   end_in: [DateTime!]
   end_lt: DateTime
   end_lte: DateTime
   end_not: DateTime
   end_not_in: [DateTime!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [TestResultWhereInput!]
   OR: [TestResultWhereInput!]
   parent: TestWhereInput
   start: DateTime
   start_gt: DateTime
   start_gte: DateTime
   start_in: [DateTime!]
   start_lt: DateTime
   start_lte: DateTime
   start_not: DateTime
   start_not_in: [DateTime!]
   status: ResultStatus
   status_in: [ResultStatus!]
   status_not: ResultStatus
   status_not_in: [ResultStatus!]
   steps_every: StepResultWhereInput
   steps_none: StepResultWhereInput
   steps_some: StepResultWhereInput
   time: TimeResultWhereInput
}

input TestResultWhereUniqueInput {
   id: ID
}

input TestUpdateOneRequiredWithoutResultsInput {
   connect: TestWhereUniqueInput
   create: TestCreateWithoutResultsInput
   update: TestUpdateWithoutResultsDataInput
   upsert: TestUpsertWithoutResultsInput
}

input TestUpdateWithoutResultsDataInput {
   menus: MenuUpdateManyInput
   steps: StepUpdateManyInput
   title: String
}

input TestUpsertWithoutResultsInput {
   create: TestCreateWithoutResultsInput!
   update: TestUpdateWithoutResultsDataInput!
}

input TestWhereInput {
   AND: [TestWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   menus_every: MenuWhereInput
   menus_none: MenuWhereInput
   menus_some: MenuWhereInput
   NOT: [TestWhereInput!]
   OR: [TestWhereInput!]
   results_every: TestResultWhereInput
   results_none: TestResultWhereInput
   results_some: TestResultWhereInput
   steps_every: StepWhereInput
   steps_none: StepWhereInput
   steps_some: StepWhereInput
   title: String
   title_contains: String
   title_ends_with: String
   title_gt: String
   title_gte: String
   title_in: [String!]
   title_lt: String
   title_lte: String
   title_not: String
   title_not_contains: String
   title_not_ends_with: String
   title_not_in: [String!]
   title_not_starts_with: String
   title_starts_with: String
}

input TestWhereUniqueInput {
   id: ID
}

type TimeResult {
   id: ID!
   int: Int!
   text: String!
}

input TimeResultCreateInput {
   id: ID
   int: Int!
   text: String!
}

input TimeResultCreateOneInput {
   connect: TimeResultWhereUniqueInput
   create: TimeResultCreateInput
}

input TimeResultUpdateDataInput {
   int: Int
   text: String
}

input TimeResultUpdateOneInput {
   connect: TimeResultWhereUniqueInput
   create: TimeResultCreateInput
   delete: Boolean
   disconnect: Boolean
   update: TimeResultUpdateDataInput
   upsert: TimeResultUpsertNestedInput
}

input TimeResultUpsertNestedInput {
   create: TimeResultCreateInput!
   update: TimeResultUpdateDataInput!
}

input TimeResultWhereInput {
   AND: [TimeResultWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   int: Int
   int_gt: Int
   int_gte: Int
   int_in: [Int!]
   int_lt: Int
   int_lte: Int
   int_not: Int
   int_not_in: [Int!]
   NOT: [TimeResultWhereInput!]
   OR: [TimeResultWhereInput!]
   text: String
   text_contains: String
   text_ends_with: String
   text_gt: String
   text_gte: String
   text_in: [String!]
   text_lt: String
   text_lte: String
   text_not: String
   text_not_contains: String
   text_not_ends_with: String
   text_not_in: [String!]
   text_not_starts_with: String
   text_starts_with: String
}

input TimeResultWhereUniqueInput {
   id: ID
}

type View {
   company: Company!
   id: ID!
   menus(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   steps(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepOrderByInput
      skip: Int
      where: StepWhereInput
   ): [Step!]
   tests(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: TestOrderByInput
      skip: Int
      where: TestWhereInput
   ): [Test!]
   welcome: Welcome!
}

enum ViewOrderByInput {
   createdAt_ASC
   createdAt_DESC
   id_ASC
   id_DESC
   updatedAt_ASC
   updatedAt_DESC
}

input ViewWhereInput {
   AND: [ViewWhereInput!]
   company: CompanyWhereInput
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   menus_every: MenuWhereInput
   menus_none: MenuWhereInput
   menus_some: MenuWhereInput
   NOT: [ViewWhereInput!]
   OR: [ViewWhereInput!]
   steps_every: StepWhereInput
   steps_none: StepWhereInput
   steps_some: StepWhereInput
   tests_every: TestWhereInput
   tests_none: TestWhereInput
   tests_some: TestWhereInput
   welcome: WelcomeWhereInput
}

type Welcome {
   id: ID!
   message: String!
   title: String!
}

input WelcomeWhereInput {
   AND: [WelcomeWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   message: String
   message_contains: String
   message_ends_with: String
   message_gt: String
   message_gte: String
   message_in: [String!]
   message_lt: String
   message_lte: String
   message_not: String
   message_not_contains: String
   message_not_ends_with: String
   message_not_in: [String!]
   message_not_starts_with: String
   message_starts_with: String
   NOT: [WelcomeWhereInput!]
   OR: [WelcomeWhereInput!]
   title: String
   title_contains: String
   title_ends_with: String
   title_gt: String
   title_gte: String
   title_in: [String!]
   title_lt: String
   title_lte: String
   title_not: String
   title_not_contains: String
   title_not_ends_with: String
   title_not_in: [String!]
   title_not_starts_with: String
   title_starts_with: String
}
