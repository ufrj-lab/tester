### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly

type Company {
  abbr: String
  id: ID!
  name: String!
  tests(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: TestOrderByInput
    skip: Int
    where: TestWhereInput
  ): [Test!]
  welcome: Message!
}

input CompanyCreateOneWithoutTestsInput {
  connect: CompanyWhereUniqueInput
  create: CompanyCreateWithoutTestsInput
}

input CompanyCreateWithoutTestsInput {
  abbr: String
  id: ID
  name: String!
  welcome: MessageCreateOneInput!
}

input CompanyUpdateOneRequiredWithoutTestsInput {
  connect: CompanyWhereUniqueInput
  create: CompanyCreateWithoutTestsInput
  update: CompanyUpdateWithoutTestsDataInput
  upsert: CompanyUpsertWithoutTestsInput
}

input CompanyUpdateWithoutTestsDataInput {
  abbr: String
  name: String
  welcome: MessageUpdateOneRequiredInput
}

input CompanyUpsertWithoutTestsInput {
  create: CompanyCreateWithoutTestsInput!
  update: CompanyUpdateWithoutTestsDataInput!
}

input CompanyWhereInput {
  abbr: String
  abbr_contains: String
  abbr_ends_with: String
  abbr_gt: String
  abbr_gte: String
  abbr_in: [String!]
  abbr_lt: String
  abbr_lte: String
  abbr_not: String
  abbr_not_contains: String
  abbr_not_ends_with: String
  abbr_not_in: [String!]
  abbr_not_starts_with: String
  abbr_starts_with: String
  AND: [CompanyWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  tests_some: TestWhereInput
  welcome: MessageWhereInput
}

input CompanyWhereUniqueInput {
  id: ID
  name: String
}

scalar DateTime

type Key {
  id: ID!
  languages(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: KeyLanguageOrderByInput
    skip: Int
    where: KeyLanguageWhereInput
  ): [KeyLanguage!]
  stepResultStatus(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: KeyStepResultStatusOrderByInput
    skip: Int
    where: KeyStepResultStatusWhereInput
  ): [KeyStepResultStatus!]
  testResultStatus(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: KeyTestResultStatusOrderByInput
    skip: Int
    where: KeyTestResultStatusWhereInput
  ): [KeyTestResultStatus!]
  userTypes(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: KeyUserTypeOrderByInput
    skip: Int
    where: KeyUserTypeWhereInput
  ): [KeyUserType!]
}

input KeyCreateInput {
  id: ID
  languages: KeyLanguageCreateManyInput
  stepResultStatus: KeyStepResultStatusCreateManyInput
  testResultStatus: KeyTestResultStatusCreateManyInput
  userTypes: KeyUserTypeCreateManyInput
}

input KeyCreateOneInput {
  connect: KeyWhereUniqueInput
  create: KeyCreateInput
}

type KeyLanguage {
  id: ID!
  key: String!
}

input KeyLanguageCreateInput {
  id: ID
  key: String!
}

input KeyLanguageCreateManyInput {
  connect: [KeyLanguageWhereUniqueInput!]
  create: [KeyLanguageCreateInput!]
}

enum KeyLanguageOrderByInput {
  id_ASC
  id_DESC
  key_ASC
  key_DESC
}

input KeyLanguageScalarWhereInput {
  AND: [KeyLanguageScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [KeyLanguageScalarWhereInput!]
  OR: [KeyLanguageScalarWhereInput!]
}

input KeyLanguageUpdateDataInput {
  key: String
}

input KeyLanguageUpdateManyDataInput {
  key: String
}

input KeyLanguageUpdateManyInput {
  connect: [KeyLanguageWhereUniqueInput!]
  create: [KeyLanguageCreateInput!]
  delete: [KeyLanguageWhereUniqueInput!]
  deleteMany: [KeyLanguageScalarWhereInput!]
  disconnect: [KeyLanguageWhereUniqueInput!]
  set: [KeyLanguageWhereUniqueInput!]
  update: [KeyLanguageUpdateWithWhereUniqueNestedInput!]
  updateMany: [KeyLanguageUpdateManyWithWhereNestedInput!]
  upsert: [KeyLanguageUpsertWithWhereUniqueNestedInput!]
}

input KeyLanguageUpdateManyWithWhereNestedInput {
  data: KeyLanguageUpdateManyDataInput!
  where: KeyLanguageScalarWhereInput!
}

input KeyLanguageUpdateWithWhereUniqueNestedInput {
  data: KeyLanguageUpdateDataInput!
  where: KeyLanguageWhereUniqueInput!
}

input KeyLanguageUpsertWithWhereUniqueNestedInput {
  create: KeyLanguageCreateInput!
  update: KeyLanguageUpdateDataInput!
  where: KeyLanguageWhereUniqueInput!
}

input KeyLanguageWhereInput {
  AND: [KeyLanguageWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
}

input KeyLanguageWhereUniqueInput {
  id: ID
  key: String
}

type KeyStepResultStatus {
  id: ID!
  key: String!
}

input KeyStepResultStatusCreateInput {
  id: ID
  key: String!
}

input KeyStepResultStatusCreateManyInput {
  connect: [KeyStepResultStatusWhereUniqueInput!]
  create: [KeyStepResultStatusCreateInput!]
}

input KeyStepResultStatusCreateOneInput {
  connect: KeyStepResultStatusWhereUniqueInput
  create: KeyStepResultStatusCreateInput
}

enum KeyStepResultStatusOrderByInput {
  id_ASC
  id_DESC
  key_ASC
  key_DESC
}

input KeyStepResultStatusScalarWhereInput {
  AND: [KeyStepResultStatusScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [KeyStepResultStatusScalarWhereInput!]
  OR: [KeyStepResultStatusScalarWhereInput!]
}

input KeyStepResultStatusUpdateDataInput {
  key: String
}

input KeyStepResultStatusUpdateManyDataInput {
  key: String
}

input KeyStepResultStatusUpdateManyInput {
  connect: [KeyStepResultStatusWhereUniqueInput!]
  create: [KeyStepResultStatusCreateInput!]
  delete: [KeyStepResultStatusWhereUniqueInput!]
  deleteMany: [KeyStepResultStatusScalarWhereInput!]
  disconnect: [KeyStepResultStatusWhereUniqueInput!]
  set: [KeyStepResultStatusWhereUniqueInput!]
  update: [KeyStepResultStatusUpdateWithWhereUniqueNestedInput!]
  updateMany: [KeyStepResultStatusUpdateManyWithWhereNestedInput!]
  upsert: [KeyStepResultStatusUpsertWithWhereUniqueNestedInput!]
}

input KeyStepResultStatusUpdateManyWithWhereNestedInput {
  data: KeyStepResultStatusUpdateManyDataInput!
  where: KeyStepResultStatusScalarWhereInput!
}

input KeyStepResultStatusUpdateOneRequiredInput {
  connect: KeyStepResultStatusWhereUniqueInput
  create: KeyStepResultStatusCreateInput
  update: KeyStepResultStatusUpdateDataInput
  upsert: KeyStepResultStatusUpsertNestedInput
}

input KeyStepResultStatusUpdateWithWhereUniqueNestedInput {
  data: KeyStepResultStatusUpdateDataInput!
  where: KeyStepResultStatusWhereUniqueInput!
}

input KeyStepResultStatusUpsertNestedInput {
  create: KeyStepResultStatusCreateInput!
  update: KeyStepResultStatusUpdateDataInput!
}

input KeyStepResultStatusUpsertWithWhereUniqueNestedInput {
  create: KeyStepResultStatusCreateInput!
  update: KeyStepResultStatusUpdateDataInput!
  where: KeyStepResultStatusWhereUniqueInput!
}

input KeyStepResultStatusWhereInput {
  AND: [KeyStepResultStatusWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
}

input KeyStepResultStatusWhereUniqueInput {
  id: ID
  key: String
}

type KeyTestResultStatus {
  id: ID!
  key: String!
}

input KeyTestResultStatusCreateInput {
  id: ID
  key: String!
}

input KeyTestResultStatusCreateManyInput {
  connect: [KeyTestResultStatusWhereUniqueInput!]
  create: [KeyTestResultStatusCreateInput!]
}

input KeyTestResultStatusCreateOneInput {
  connect: KeyTestResultStatusWhereUniqueInput
  create: KeyTestResultStatusCreateInput
}

enum KeyTestResultStatusOrderByInput {
  id_ASC
  id_DESC
  key_ASC
  key_DESC
}

input KeyTestResultStatusScalarWhereInput {
  AND: [KeyTestResultStatusScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [KeyTestResultStatusScalarWhereInput!]
  OR: [KeyTestResultStatusScalarWhereInput!]
}

input KeyTestResultStatusUpdateDataInput {
  key: String
}

input KeyTestResultStatusUpdateManyDataInput {
  key: String
}

input KeyTestResultStatusUpdateManyInput {
  connect: [KeyTestResultStatusWhereUniqueInput!]
  create: [KeyTestResultStatusCreateInput!]
  delete: [KeyTestResultStatusWhereUniqueInput!]
  deleteMany: [KeyTestResultStatusScalarWhereInput!]
  disconnect: [KeyTestResultStatusWhereUniqueInput!]
  set: [KeyTestResultStatusWhereUniqueInput!]
  update: [KeyTestResultStatusUpdateWithWhereUniqueNestedInput!]
  updateMany: [KeyTestResultStatusUpdateManyWithWhereNestedInput!]
  upsert: [KeyTestResultStatusUpsertWithWhereUniqueNestedInput!]
}

input KeyTestResultStatusUpdateManyWithWhereNestedInput {
  data: KeyTestResultStatusUpdateManyDataInput!
  where: KeyTestResultStatusScalarWhereInput!
}

input KeyTestResultStatusUpdateOneRequiredInput {
  connect: KeyTestResultStatusWhereUniqueInput
  create: KeyTestResultStatusCreateInput
  update: KeyTestResultStatusUpdateDataInput
  upsert: KeyTestResultStatusUpsertNestedInput
}

input KeyTestResultStatusUpdateWithWhereUniqueNestedInput {
  data: KeyTestResultStatusUpdateDataInput!
  where: KeyTestResultStatusWhereUniqueInput!
}

input KeyTestResultStatusUpsertNestedInput {
  create: KeyTestResultStatusCreateInput!
  update: KeyTestResultStatusUpdateDataInput!
}

input KeyTestResultStatusUpsertWithWhereUniqueNestedInput {
  create: KeyTestResultStatusCreateInput!
  update: KeyTestResultStatusUpdateDataInput!
  where: KeyTestResultStatusWhereUniqueInput!
}

input KeyTestResultStatusWhereInput {
  AND: [KeyTestResultStatusWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
}

input KeyTestResultStatusWhereUniqueInput {
  id: ID
  key: String
}

input KeyUpdateDataInput {
  languages: KeyLanguageUpdateManyInput
  stepResultStatus: KeyStepResultStatusUpdateManyInput
  testResultStatus: KeyTestResultStatusUpdateManyInput
  userTypes: KeyUserTypeUpdateManyInput
}

input KeyUpdateOneRequiredInput {
  connect: KeyWhereUniqueInput
  create: KeyCreateInput
  update: KeyUpdateDataInput
  upsert: KeyUpsertNestedInput
}

input KeyUpsertNestedInput {
  create: KeyCreateInput!
  update: KeyUpdateDataInput!
}

type KeyUserType {
  id: ID!
  key: String!
}

input KeyUserTypeCreateInput {
  id: ID
  key: String!
}

input KeyUserTypeCreateManyInput {
  connect: [KeyUserTypeWhereUniqueInput!]
  create: [KeyUserTypeCreateInput!]
}

enum KeyUserTypeOrderByInput {
  id_ASC
  id_DESC
  key_ASC
  key_DESC
}

input KeyUserTypeScalarWhereInput {
  AND: [KeyUserTypeScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
  NOT: [KeyUserTypeScalarWhereInput!]
  OR: [KeyUserTypeScalarWhereInput!]
}

input KeyUserTypeUpdateDataInput {
  key: String
}

input KeyUserTypeUpdateManyDataInput {
  key: String
}

input KeyUserTypeUpdateManyInput {
  connect: [KeyUserTypeWhereUniqueInput!]
  create: [KeyUserTypeCreateInput!]
  delete: [KeyUserTypeWhereUniqueInput!]
  deleteMany: [KeyUserTypeScalarWhereInput!]
  disconnect: [KeyUserTypeWhereUniqueInput!]
  set: [KeyUserTypeWhereUniqueInput!]
  update: [KeyUserTypeUpdateWithWhereUniqueNestedInput!]
  updateMany: [KeyUserTypeUpdateManyWithWhereNestedInput!]
  upsert: [KeyUserTypeUpsertWithWhereUniqueNestedInput!]
}

input KeyUserTypeUpdateManyWithWhereNestedInput {
  data: KeyUserTypeUpdateManyDataInput!
  where: KeyUserTypeScalarWhereInput!
}

input KeyUserTypeUpdateWithWhereUniqueNestedInput {
  data: KeyUserTypeUpdateDataInput!
  where: KeyUserTypeWhereUniqueInput!
}

input KeyUserTypeUpsertWithWhereUniqueNestedInput {
  create: KeyUserTypeCreateInput!
  update: KeyUserTypeUpdateDataInput!
  where: KeyUserTypeWhereUniqueInput!
}

input KeyUserTypeWhereInput {
  AND: [KeyUserTypeWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  key: String
  key_contains: String
  key_ends_with: String
  key_gt: String
  key_gte: String
  key_in: [String!]
  key_lt: String
  key_lte: String
  key_not: String
  key_not_contains: String
  key_not_ends_with: String
  key_not_in: [String!]
  key_not_starts_with: String
  key_starts_with: String
}

input KeyUserTypeWhereUniqueInput {
  id: ID
  key: String
}

input KeyWhereInput {
  AND: [KeyWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  languages_some: KeyLanguageWhereInput
  stepResultStatus_some: KeyStepResultStatusWhereInput
  testResultStatus_some: KeyTestResultStatusWhereInput
  userTypes_some: KeyUserTypeWhereInput
}

input KeyWhereUniqueInput {
  id: ID
}

type Menu {
  id: ID!
  items(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MenuOrderByInput
    skip: Int
    where: MenuWhereInput
  ): [Menu!]
  menus(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MenuOrderByInput
    skip: Int
    where: MenuWhereInput
  ): [Menu!]
  name: MultiLanguageContent!
  order: Int
  root: Boolean!
}

input MenuCreateInput {
  id: ID
  items: MenuCreateManyWithoutMenusInput
  menus: MenuCreateManyWithoutItemsInput
  name: MultiLanguageContentCreateOneInput!
  order: Int
  root: Boolean
}

input MenuCreateManyInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateInput!]
}

input MenuCreateManyWithoutItemsInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateWithoutItemsInput!]
}

input MenuCreateManyWithoutMenusInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateWithoutMenusInput!]
}

input MenuCreateWithoutItemsInput {
  id: ID
  menus: MenuCreateManyWithoutItemsInput
  name: MultiLanguageContentCreateOneInput!
  order: Int
  root: Boolean
}

input MenuCreateWithoutMenusInput {
  id: ID
  items: MenuCreateManyWithoutMenusInput
  name: MultiLanguageContentCreateOneInput!
  order: Int
  root: Boolean
}

enum MenuOrderByInput {
  id_ASC
  id_DESC
  order_ASC
  order_DESC
  root_ASC
  root_DESC
}

input MenuScalarWhereInput {
  AND: [MenuScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [MenuScalarWhereInput!]
  OR: [MenuScalarWhereInput!]
  order: Int
  order_gt: Int
  order_gte: Int
  order_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_not: Int
  order_not_in: [Int!]
  root: Boolean
  root_not: Boolean
}

input MenuUpdateDataInput {
  items: MenuUpdateManyWithoutMenusInput
  menus: MenuUpdateManyWithoutItemsInput
  name: MultiLanguageContentUpdateOneRequiredInput
  order: Int
  root: Boolean
}

input MenuUpdateManyDataInput {
  order: Int
  root: Boolean
}

input MenuUpdateManyInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateInput!]
  delete: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  disconnect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueNestedInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueNestedInput!]
}

input MenuUpdateManyWithoutItemsInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateWithoutItemsInput!]
  delete: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  disconnect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutItemsInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutItemsInput!]
}

input MenuUpdateManyWithoutMenusInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateWithoutMenusInput!]
  delete: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  disconnect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutMenusInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutMenusInput!]
}

input MenuUpdateManyWithWhereNestedInput {
  data: MenuUpdateManyDataInput!
  where: MenuScalarWhereInput!
}

input MenuUpdateWithoutItemsDataInput {
  menus: MenuUpdateManyWithoutItemsInput
  name: MultiLanguageContentUpdateOneRequiredInput
  order: Int
  root: Boolean
}

input MenuUpdateWithoutMenusDataInput {
  items: MenuUpdateManyWithoutMenusInput
  name: MultiLanguageContentUpdateOneRequiredInput
  order: Int
  root: Boolean
}

input MenuUpdateWithWhereUniqueNestedInput {
  data: MenuUpdateDataInput!
  where: MenuWhereUniqueInput!
}

input MenuUpdateWithWhereUniqueWithoutItemsInput {
  data: MenuUpdateWithoutItemsDataInput!
  where: MenuWhereUniqueInput!
}

input MenuUpdateWithWhereUniqueWithoutMenusInput {
  data: MenuUpdateWithoutMenusDataInput!
  where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueNestedInput {
  create: MenuCreateInput!
  update: MenuUpdateDataInput!
  where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueWithoutItemsInput {
  create: MenuCreateWithoutItemsInput!
  update: MenuUpdateWithoutItemsDataInput!
  where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueWithoutMenusInput {
  create: MenuCreateWithoutMenusInput!
  update: MenuUpdateWithoutMenusDataInput!
  where: MenuWhereUniqueInput!
}

input MenuWhereInput {
  AND: [MenuWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  items_some: MenuWhereInput
  menus_some: MenuWhereInput
  name: MultiLanguageContentWhereInput
  order: Int
  order_gt: Int
  order_gte: Int
  order_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_not: Int
  order_not_in: [Int!]
  root: Boolean
  root_not: Boolean
}

input MenuWhereUniqueInput {
  id: ID
}

type Message {
  id: ID!
  message: MultiLanguageContent!
  title: MultiLanguageContent!
}

input MessageCreateInput {
  id: ID
  message: MultiLanguageContentCreateOneInput!
  title: MultiLanguageContentCreateOneInput!
}

input MessageCreateOneInput {
  connect: MessageWhereUniqueInput
  create: MessageCreateInput
}

input MessageUpdateDataInput {
  message: MultiLanguageContentUpdateOneRequiredInput
  title: MultiLanguageContentUpdateOneRequiredInput
}

input MessageUpdateOneRequiredInput {
  connect: MessageWhereUniqueInput
  create: MessageCreateInput
  update: MessageUpdateDataInput
  upsert: MessageUpsertNestedInput
}

input MessageUpsertNestedInput {
  create: MessageCreateInput!
  update: MessageUpdateDataInput!
}

input MessageWhereInput {
  AND: [MessageWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  message: MultiLanguageContentWhereInput
  title: MultiLanguageContentWhereInput
}

input MessageWhereUniqueInput {
  id: ID
}

type MultiLanguageContent {
  en: String
  id: ID!
  pt: String!
}

input MultiLanguageContentCreateInput {
  en: String
  id: ID
  pt: String!
}

input MultiLanguageContentCreateOneInput {
  connect: MultiLanguageContentWhereUniqueInput
  create: MultiLanguageContentCreateInput
}

input MultiLanguageContentUpdateDataInput {
  en: String
  pt: String
}

input MultiLanguageContentUpdateOneRequiredInput {
  connect: MultiLanguageContentWhereUniqueInput
  create: MultiLanguageContentCreateInput
  update: MultiLanguageContentUpdateDataInput
  upsert: MultiLanguageContentUpsertNestedInput
}

input MultiLanguageContentUpsertNestedInput {
  create: MultiLanguageContentCreateInput!
  update: MultiLanguageContentUpdateDataInput!
}

input MultiLanguageContentWhereInput {
  AND: [MultiLanguageContentWhereInput!]
  en: String
  en_contains: String
  en_ends_with: String
  en_gt: String
  en_gte: String
  en_in: [String!]
  en_lt: String
  en_lte: String
  en_not: String
  en_not_contains: String
  en_not_ends_with: String
  en_not_in: [String!]
  en_not_starts_with: String
  en_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  pt: String
  pt_contains: String
  pt_ends_with: String
  pt_gt: String
  pt_gte: String
  pt_in: [String!]
  pt_lt: String
  pt_lte: String
  pt_not: String
  pt_not_contains: String
  pt_not_ends_with: String
  pt_not_in: [String!]
  pt_not_starts_with: String
  pt_starts_with: String
}

input MultiLanguageContentWhereUniqueInput {
  id: ID
}

type Mutation {
  createStepResult(data: StepResultCreateInput!): StepResult!
  createTestResult(data: TestResultCreateInput!): TestResult!
  updateTestResult(
    data: TestResultUpdateInput!
    where: TestResultWhereUniqueInput!
  ): TestResult
}

type Path {
  id: ID!
  items(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MenuOrderByInput
    skip: Int
    where: MenuWhereInput
  ): [Menu!]
}

input PathCreateInput {
  id: ID
  items: MenuCreateManyInput
}

input PathCreateManyInput {
  connect: [PathWhereUniqueInput!]
  create: [PathCreateInput!]
}

enum PathOrderByInput {
  id_ASC
  id_DESC
}

input PathScalarWhereInput {
  AND: [PathScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [PathScalarWhereInput!]
  OR: [PathScalarWhereInput!]
}

input PathUpdateDataInput {
  items: MenuUpdateManyInput
}

input PathUpdateManyInput {
  connect: [PathWhereUniqueInput!]
  create: [PathCreateInput!]
  delete: [PathWhereUniqueInput!]
  deleteMany: [PathScalarWhereInput!]
  disconnect: [PathWhereUniqueInput!]
  set: [PathWhereUniqueInput!]
  update: [PathUpdateWithWhereUniqueNestedInput!]
  upsert: [PathUpsertWithWhereUniqueNestedInput!]
}

input PathUpdateWithWhereUniqueNestedInput {
  data: PathUpdateDataInput!
  where: PathWhereUniqueInput!
}

input PathUpsertWithWhereUniqueNestedInput {
  create: PathCreateInput!
  update: PathUpdateDataInput!
  where: PathWhereUniqueInput!
}

input PathWhereInput {
  AND: [PathWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  items_some: MenuWhereInput
}

input PathWhereUniqueInput {
  id: ID
}

type Query {
  results(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: TestResultOrderByInput
    skip: Int
    where: TestResultWhereInput
  ): [TestResult!]!
  test(where: TestWhereUniqueInput!): Test
}

type Step {
  id: ID!
  paths(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PathOrderByInput
    skip: Int
    where: PathWhereInput
  ): [Path!]
  question: MultiLanguageContent!
  results(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: StepResultOrderByInput
    skip: Int
    where: StepResultWhereInput
  ): [StepResult!]
  targets(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MenuOrderByInput
    skip: Int
    where: MenuWhereInput
  ): [Menu!]
  type(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: KeyUserTypeOrderByInput
    skip: Int
    where: KeyUserTypeWhereInput
  ): [KeyUserType!]
}

input StepCreateInput {
  id: ID
  paths: PathCreateManyInput
  question: MultiLanguageContentCreateOneInput!
  results: StepResultCreateManyWithoutParentInput
  targets: MenuCreateManyInput
  type: KeyUserTypeCreateManyInput
}

input StepCreateManyInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateInput!]
}

input StepCreateOneWithoutResultsInput {
  connect: StepWhereUniqueInput
  create: StepCreateWithoutResultsInput
}

input StepCreateWithoutResultsInput {
  id: ID
  paths: PathCreateManyInput
  question: MultiLanguageContentCreateOneInput!
  targets: MenuCreateManyInput
  type: KeyUserTypeCreateManyInput
}

enum StepOrderByInput {
  id_ASC
  id_DESC
}

type StepResult {
  end: DateTime!
  id: ID!
  parent: Step!
  path(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MenuOrderByInput
    skip: Int
    where: MenuWhereInput
  ): [Menu!]
  result: TestResult!
  start: DateTime!
  status: KeyStepResultStatus!
  time: Int!
}

input StepResultCreateInput {
  end: DateTime!
  id: ID
  parent: StepCreateOneWithoutResultsInput!
  path: MenuCreateManyInput
  result: TestResultCreateOneWithoutStepsInput!
  start: DateTime!
  status: KeyStepResultStatusCreateOneInput!
  time: Int!
}

input StepResultCreateManyWithoutParentInput {
  connect: [StepResultWhereUniqueInput!]
  create: [StepResultCreateWithoutParentInput!]
}

input StepResultCreateManyWithoutResultInput {
  connect: [StepResultWhereUniqueInput!]
  create: [StepResultCreateWithoutResultInput!]
}

input StepResultCreateWithoutParentInput {
  end: DateTime!
  id: ID
  path: MenuCreateManyInput
  result: TestResultCreateOneWithoutStepsInput!
  start: DateTime!
  status: KeyStepResultStatusCreateOneInput!
  time: Int!
}

input StepResultCreateWithoutResultInput {
  end: DateTime!
  id: ID
  parent: StepCreateOneWithoutResultsInput!
  path: MenuCreateManyInput
  start: DateTime!
  status: KeyStepResultStatusCreateOneInput!
  time: Int!
}

enum StepResultOrderByInput {
  end_ASC
  end_DESC
  id_ASC
  id_DESC
  start_ASC
  start_DESC
  time_ASC
  time_DESC
}

input StepResultScalarWhereInput {
  AND: [StepResultScalarWhereInput!]
  end: DateTime
  end_gt: DateTime
  end_gte: DateTime
  end_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_not: DateTime
  end_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [StepResultScalarWhereInput!]
  OR: [StepResultScalarWhereInput!]
  start: DateTime
  start_gt: DateTime
  start_gte: DateTime
  start_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_not: DateTime
  start_not_in: [DateTime!]
  time: Int
  time_gt: Int
  time_gte: Int
  time_in: [Int!]
  time_lt: Int
  time_lte: Int
  time_not: Int
  time_not_in: [Int!]
}

input StepResultUpdateManyDataInput {
  end: DateTime
  start: DateTime
  time: Int
}

input StepResultUpdateManyWithoutParentInput {
  connect: [StepResultWhereUniqueInput!]
  create: [StepResultCreateWithoutParentInput!]
  delete: [StepResultWhereUniqueInput!]
  deleteMany: [StepResultScalarWhereInput!]
  disconnect: [StepResultWhereUniqueInput!]
  set: [StepResultWhereUniqueInput!]
  update: [StepResultUpdateWithWhereUniqueWithoutParentInput!]
  updateMany: [StepResultUpdateManyWithWhereNestedInput!]
  upsert: [StepResultUpsertWithWhereUniqueWithoutParentInput!]
}

input StepResultUpdateManyWithoutResultInput {
  connect: [StepResultWhereUniqueInput!]
  create: [StepResultCreateWithoutResultInput!]
  delete: [StepResultWhereUniqueInput!]
  deleteMany: [StepResultScalarWhereInput!]
  disconnect: [StepResultWhereUniqueInput!]
  set: [StepResultWhereUniqueInput!]
  update: [StepResultUpdateWithWhereUniqueWithoutResultInput!]
  updateMany: [StepResultUpdateManyWithWhereNestedInput!]
  upsert: [StepResultUpsertWithWhereUniqueWithoutResultInput!]
}

input StepResultUpdateManyWithWhereNestedInput {
  data: StepResultUpdateManyDataInput!
  where: StepResultScalarWhereInput!
}

input StepResultUpdateWithoutParentDataInput {
  end: DateTime
  path: MenuUpdateManyInput
  result: TestResultUpdateOneRequiredWithoutStepsInput
  start: DateTime
  status: KeyStepResultStatusUpdateOneRequiredInput
  time: Int
}

input StepResultUpdateWithoutResultDataInput {
  end: DateTime
  parent: StepUpdateOneRequiredWithoutResultsInput
  path: MenuUpdateManyInput
  start: DateTime
  status: KeyStepResultStatusUpdateOneRequiredInput
  time: Int
}

input StepResultUpdateWithWhereUniqueWithoutParentInput {
  data: StepResultUpdateWithoutParentDataInput!
  where: StepResultWhereUniqueInput!
}

input StepResultUpdateWithWhereUniqueWithoutResultInput {
  data: StepResultUpdateWithoutResultDataInput!
  where: StepResultWhereUniqueInput!
}

input StepResultUpsertWithWhereUniqueWithoutParentInput {
  create: StepResultCreateWithoutParentInput!
  update: StepResultUpdateWithoutParentDataInput!
  where: StepResultWhereUniqueInput!
}

input StepResultUpsertWithWhereUniqueWithoutResultInput {
  create: StepResultCreateWithoutResultInput!
  update: StepResultUpdateWithoutResultDataInput!
  where: StepResultWhereUniqueInput!
}

input StepResultWhereInput {
  AND: [StepResultWhereInput!]
  end: DateTime
  end_gt: DateTime
  end_gte: DateTime
  end_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_not: DateTime
  end_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  parent: StepWhereInput
  path_some: MenuWhereInput
  result: TestResultWhereInput
  start: DateTime
  start_gt: DateTime
  start_gte: DateTime
  start_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_not: DateTime
  start_not_in: [DateTime!]
  status: KeyStepResultStatusWhereInput
  time: Int
  time_gt: Int
  time_gte: Int
  time_in: [Int!]
  time_lt: Int
  time_lte: Int
  time_not: Int
  time_not_in: [Int!]
}

input StepResultWhereUniqueInput {
  id: ID
}

input StepScalarWhereInput {
  AND: [StepScalarWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [StepScalarWhereInput!]
  OR: [StepScalarWhereInput!]
}

input StepUpdateDataInput {
  paths: PathUpdateManyInput
  question: MultiLanguageContentUpdateOneRequiredInput
  results: StepResultUpdateManyWithoutParentInput
  targets: MenuUpdateManyInput
  type: KeyUserTypeUpdateManyInput
}

input StepUpdateManyInput {
  connect: [StepWhereUniqueInput!]
  create: [StepCreateInput!]
  delete: [StepWhereUniqueInput!]
  deleteMany: [StepScalarWhereInput!]
  disconnect: [StepWhereUniqueInput!]
  set: [StepWhereUniqueInput!]
  update: [StepUpdateWithWhereUniqueNestedInput!]
  upsert: [StepUpsertWithWhereUniqueNestedInput!]
}

input StepUpdateOneRequiredWithoutResultsInput {
  connect: StepWhereUniqueInput
  create: StepCreateWithoutResultsInput
  update: StepUpdateWithoutResultsDataInput
  upsert: StepUpsertWithoutResultsInput
}

input StepUpdateWithoutResultsDataInput {
  paths: PathUpdateManyInput
  question: MultiLanguageContentUpdateOneRequiredInput
  targets: MenuUpdateManyInput
  type: KeyUserTypeUpdateManyInput
}

input StepUpdateWithWhereUniqueNestedInput {
  data: StepUpdateDataInput!
  where: StepWhereUniqueInput!
}

input StepUpsertWithoutResultsInput {
  create: StepCreateWithoutResultsInput!
  update: StepUpdateWithoutResultsDataInput!
}

input StepUpsertWithWhereUniqueNestedInput {
  create: StepCreateInput!
  update: StepUpdateDataInput!
  where: StepWhereUniqueInput!
}

input StepWhereInput {
  AND: [StepWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  paths_some: PathWhereInput
  question: MultiLanguageContentWhereInput
  results_some: StepResultWhereInput
  targets_some: MenuWhereInput
  type_some: KeyUserTypeWhereInput
}

input StepWhereUniqueInput {
  id: ID
}

type Test {
  company: Company!
  id: ID!
  instruction: Message!
  keys: Key!
  languages(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: KeyLanguageOrderByInput
    skip: Int
    where: KeyLanguageWhereInput
  ): [KeyLanguage!]
  menus(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MenuOrderByInput
    skip: Int
    where: MenuWhereInput
  ): [Menu!]
  publics(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: KeyUserTypeOrderByInput
    skip: Int
    where: KeyUserTypeWhereInput
  ): [KeyUserType!]
  results(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: TestResultOrderByInput
    skip: Int
    where: TestResultWhereInput
  ): [TestResult!]
  steps(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: StepOrderByInput
    skip: Int
    where: StepWhereInput
  ): [Step!]
  title: MultiLanguageContent!
}

input TestCreateOneWithoutResultsInput {
  connect: TestWhereUniqueInput
  create: TestCreateWithoutResultsInput
}

input TestCreateWithoutResultsInput {
  company: CompanyCreateOneWithoutTestsInput!
  id: ID
  instruction: MessageCreateOneInput!
  keys: KeyCreateOneInput!
  languages: KeyLanguageCreateManyInput
  menus: MenuCreateManyInput
  publics: KeyUserTypeCreateManyInput
  steps: StepCreateManyInput
  title: MultiLanguageContentCreateOneInput!
}

enum TestOrderByInput {
  id_ASC
  id_DESC
}

type TestResult {
  end: DateTime
  id: ID!
  parent: Test!
  start: DateTime!
  status: KeyTestResultStatus!
  steps(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: StepResultOrderByInput
    skip: Int
    where: StepResultWhereInput
  ): [StepResult!]
  time: Int
}

input TestResultCreateInput {
  end: DateTime
  id: ID
  parent: TestCreateOneWithoutResultsInput!
  start: DateTime!
  status: KeyTestResultStatusCreateOneInput!
  steps: StepResultCreateManyWithoutResultInput
  time: Int
}

input TestResultCreateOneWithoutStepsInput {
  connect: TestResultWhereUniqueInput
  create: TestResultCreateWithoutStepsInput
}

input TestResultCreateWithoutStepsInput {
  end: DateTime
  id: ID
  parent: TestCreateOneWithoutResultsInput!
  start: DateTime!
  status: KeyTestResultStatusCreateOneInput!
  time: Int
}

enum TestResultOrderByInput {
  end_ASC
  end_DESC
  id_ASC
  id_DESC
  start_ASC
  start_DESC
  time_ASC
  time_DESC
}

input TestResultUpdateInput {
  end: DateTime
  parent: TestUpdateOneRequiredWithoutResultsInput
  start: DateTime
  status: KeyTestResultStatusUpdateOneRequiredInput
  steps: StepResultUpdateManyWithoutResultInput
  time: Int
}

input TestResultUpdateOneRequiredWithoutStepsInput {
  connect: TestResultWhereUniqueInput
  create: TestResultCreateWithoutStepsInput
  update: TestResultUpdateWithoutStepsDataInput
  upsert: TestResultUpsertWithoutStepsInput
}

input TestResultUpdateWithoutStepsDataInput {
  end: DateTime
  parent: TestUpdateOneRequiredWithoutResultsInput
  start: DateTime
  status: KeyTestResultStatusUpdateOneRequiredInput
  time: Int
}

input TestResultUpsertWithoutStepsInput {
  create: TestResultCreateWithoutStepsInput!
  update: TestResultUpdateWithoutStepsDataInput!
}

input TestResultWhereInput {
  AND: [TestResultWhereInput!]
  end: DateTime
  end_gt: DateTime
  end_gte: DateTime
  end_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_not: DateTime
  end_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  parent: TestWhereInput
  start: DateTime
  start_gt: DateTime
  start_gte: DateTime
  start_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_not: DateTime
  start_not_in: [DateTime!]
  status: KeyTestResultStatusWhereInput
  steps_some: StepResultWhereInput
  time: Int
  time_gt: Int
  time_gte: Int
  time_in: [Int!]
  time_lt: Int
  time_lte: Int
  time_not: Int
  time_not_in: [Int!]
}

input TestResultWhereUniqueInput {
  id: ID
}

input TestUpdateOneRequiredWithoutResultsInput {
  connect: TestWhereUniqueInput
  create: TestCreateWithoutResultsInput
  update: TestUpdateWithoutResultsDataInput
  upsert: TestUpsertWithoutResultsInput
}

input TestUpdateWithoutResultsDataInput {
  company: CompanyUpdateOneRequiredWithoutTestsInput
  instruction: MessageUpdateOneRequiredInput
  keys: KeyUpdateOneRequiredInput
  languages: KeyLanguageUpdateManyInput
  menus: MenuUpdateManyInput
  publics: KeyUserTypeUpdateManyInput
  steps: StepUpdateManyInput
  title: MultiLanguageContentUpdateOneRequiredInput
}

input TestUpsertWithoutResultsInput {
  create: TestCreateWithoutResultsInput!
  update: TestUpdateWithoutResultsDataInput!
}

input TestWhereInput {
  AND: [TestWhereInput!]
  company: CompanyWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  instruction: MessageWhereInput
  keys: KeyWhereInput
  languages_some: KeyLanguageWhereInput
  menus_some: MenuWhereInput
  publics_some: KeyUserTypeWhereInput
  results_some: TestResultWhereInput
  steps_some: StepWhereInput
  title: MultiLanguageContentWhereInput
}

input TestWhereUniqueInput {
  id: ID
}
