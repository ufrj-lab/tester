### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly

type Company {
   abbr: String
   id: ID!
   logo: String
   name: String!
}

input CompanyWhereInput {
   abbr: String
   abbr_contains: String
   abbr_ends_with: String
   abbr_gt: String
   abbr_gte: String
   abbr_in: [String!]
   abbr_lt: String
   abbr_lte: String
   abbr_not: String
   abbr_not_contains: String
   abbr_not_ends_with: String
   abbr_not_in: [String!]
   abbr_not_starts_with: String
   abbr_starts_with: String
   AND: [CompanyWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   logo: String
   logo_contains: String
   logo_ends_with: String
   logo_gt: String
   logo_gte: String
   logo_in: [String!]
   logo_lt: String
   logo_lte: String
   logo_not: String
   logo_not_contains: String
   logo_not_ends_with: String
   logo_not_in: [String!]
   logo_not_starts_with: String
   logo_starts_with: String
   name: String
   name_contains: String
   name_ends_with: String
   name_gt: String
   name_gte: String
   name_in: [String!]
   name_lt: String
   name_lte: String
   name_not: String
   name_not_contains: String
   name_not_ends_with: String
   name_not_in: [String!]
   name_not_starts_with: String
   name_starts_with: String
}

scalar DateTime

type KeyResultStatus {
   id: ID!
   key: String!
   results(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: TestResultOrderByInput
      skip: Int
      where: TestResultWhereInput
   ): [TestResult!]
}

input KeyResultStatusCreateInput {
   id: ID
   key: String!
   results: TestResultCreateManyWithoutStatusInput
}

input KeyResultStatusCreateOneInput {
   connect: KeyResultStatusWhereUniqueInput
   create: KeyResultStatusCreateInput
}

input KeyResultStatusCreateOneWithoutResultsInput {
   connect: KeyResultStatusWhereUniqueInput
   create: KeyResultStatusCreateWithoutResultsInput
}

input KeyResultStatusCreateWithoutResultsInput {
   id: ID
   key: String!
}

enum KeyResultStatusOrderByInput {
   id_ASC
   id_DESC
   key_ASC
   key_DESC
}

input KeyResultStatusUpdateDataInput {
   key: String
   results: TestResultUpdateManyWithoutStatusInput
}

input KeyResultStatusUpdateOneRequiredInput {
   connect: KeyResultStatusWhereUniqueInput
   create: KeyResultStatusCreateInput
   update: KeyResultStatusUpdateDataInput
   upsert: KeyResultStatusUpsertNestedInput
}

input KeyResultStatusUpdateOneRequiredWithoutResultsInput {
   connect: KeyResultStatusWhereUniqueInput
   create: KeyResultStatusCreateWithoutResultsInput
   update: KeyResultStatusUpdateWithoutResultsDataInput
   upsert: KeyResultStatusUpsertWithoutResultsInput
}

input KeyResultStatusUpdateWithoutResultsDataInput {
   key: String
}

input KeyResultStatusUpsertNestedInput {
   create: KeyResultStatusCreateInput!
   update: KeyResultStatusUpdateDataInput!
}

input KeyResultStatusUpsertWithoutResultsInput {
   create: KeyResultStatusCreateWithoutResultsInput!
   update: KeyResultStatusUpdateWithoutResultsDataInput!
}

input KeyResultStatusWhereInput {
   AND: [KeyResultStatusWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   key: String
   key_contains: String
   key_ends_with: String
   key_gt: String
   key_gte: String
   key_in: [String!]
   key_lt: String
   key_lte: String
   key_not: String
   key_not_contains: String
   key_not_ends_with: String
   key_not_in: [String!]
   key_not_starts_with: String
   key_starts_with: String
   results_some: TestResultWhereInput
}

input KeyResultStatusWhereUniqueInput {
   id: ID
   key: String
}

type Keys {
   id: ID!
   resultStatus(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: KeyResultStatusOrderByInput
      skip: Int
      where: KeyResultStatusWhereInput
   ): [KeyResultStatus!]
   userType(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: KeyUserTypeOrderByInput
      skip: Int
      where: KeyUserTypeWhereInput
   ): [KeyUserType!]
}

enum KeysOrderByInput {
   id_ASC
   id_DESC
}

input KeysWhereInput {
   AND: [KeysWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   resultStatus_some: KeyResultStatusWhereInput
   userType_some: KeyUserTypeWhereInput
}

type KeyUserType {
   id: ID!
   key: String!
   steps(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepOrderByInput
      skip: Int
      where: StepWhereInput
   ): [Step!]
}

input KeyUserTypeCreateManyWithoutStepsInput {
   connect: [KeyUserTypeWhereUniqueInput!]
   create: [KeyUserTypeCreateWithoutStepsInput!]
}

input KeyUserTypeCreateWithoutStepsInput {
   id: ID
   key: String!
}

enum KeyUserTypeOrderByInput {
   id_ASC
   id_DESC
   key_ASC
   key_DESC
}

input KeyUserTypeScalarWhereInput {
   AND: [KeyUserTypeScalarWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   key: String
   key_contains: String
   key_ends_with: String
   key_gt: String
   key_gte: String
   key_in: [String!]
   key_lt: String
   key_lte: String
   key_not: String
   key_not_contains: String
   key_not_ends_with: String
   key_not_in: [String!]
   key_not_starts_with: String
   key_starts_with: String
   NOT: [KeyUserTypeScalarWhereInput!]
   OR: [KeyUserTypeScalarWhereInput!]
}

input KeyUserTypeUpdateManyDataInput {
   key: String
}

input KeyUserTypeUpdateManyWithoutStepsInput {
   connect: [KeyUserTypeWhereUniqueInput!]
   create: [KeyUserTypeCreateWithoutStepsInput!]
   delete: [KeyUserTypeWhereUniqueInput!]
   deleteMany: [KeyUserTypeScalarWhereInput!]
   disconnect: [KeyUserTypeWhereUniqueInput!]
   set: [KeyUserTypeWhereUniqueInput!]
   update: [KeyUserTypeUpdateWithWhereUniqueWithoutStepsInput!]
   updateMany: [KeyUserTypeUpdateManyWithWhereNestedInput!]
   upsert: [KeyUserTypeUpsertWithWhereUniqueWithoutStepsInput!]
}

input KeyUserTypeUpdateManyWithWhereNestedInput {
   data: KeyUserTypeUpdateManyDataInput!
   where: KeyUserTypeScalarWhereInput!
}

input KeyUserTypeUpdateWithoutStepsDataInput {
   key: String
}

input KeyUserTypeUpdateWithWhereUniqueWithoutStepsInput {
   data: KeyUserTypeUpdateWithoutStepsDataInput!
   where: KeyUserTypeWhereUniqueInput!
}

input KeyUserTypeUpsertWithWhereUniqueWithoutStepsInput {
   create: KeyUserTypeCreateWithoutStepsInput!
   update: KeyUserTypeUpdateWithoutStepsDataInput!
   where: KeyUserTypeWhereUniqueInput!
}

input KeyUserTypeWhereInput {
   AND: [KeyUserTypeWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   key: String
   key_contains: String
   key_ends_with: String
   key_gt: String
   key_gte: String
   key_in: [String!]
   key_lt: String
   key_lte: String
   key_not: String
   key_not_contains: String
   key_not_ends_with: String
   key_not_in: [String!]
   key_not_starts_with: String
   key_starts_with: String
   steps_some: StepWhereInput
}

input KeyUserTypeWhereUniqueInput {
   id: ID
   key: String
}

type Menu {
   id: ID!
   items(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   menus(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   name: String!
   root: Boolean!
}

input MenuCreateInput {
   id: ID
   items: MenuCreateManyWithoutMenusInput
   menus: MenuCreateManyWithoutItemsInput
   name: String!
   root: Boolean
}

input MenuCreateManyInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateInput!]
}

input MenuCreateManyWithoutItemsInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateWithoutItemsInput!]
}

input MenuCreateManyWithoutMenusInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateWithoutMenusInput!]
}

input MenuCreateWithoutItemsInput {
   id: ID
   menus: MenuCreateManyWithoutItemsInput
   name: String!
   root: Boolean
}

input MenuCreateWithoutMenusInput {
   id: ID
   items: MenuCreateManyWithoutMenusInput
   name: String!
   root: Boolean
}

enum MenuOrderByInput {
   id_ASC
   id_DESC
   name_ASC
   name_DESC
   root_ASC
   root_DESC
}

input MenuScalarWhereInput {
   AND: [MenuScalarWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   name: String
   name_contains: String
   name_ends_with: String
   name_gt: String
   name_gte: String
   name_in: [String!]
   name_lt: String
   name_lte: String
   name_not: String
   name_not_contains: String
   name_not_ends_with: String
   name_not_in: [String!]
   name_not_starts_with: String
   name_starts_with: String
   NOT: [MenuScalarWhereInput!]
   OR: [MenuScalarWhereInput!]
   root: Boolean
   root_not: Boolean
}

input MenuUpdateDataInput {
   items: MenuUpdateManyWithoutMenusInput
   menus: MenuUpdateManyWithoutItemsInput
   name: String
   root: Boolean
}

input MenuUpdateManyDataInput {
   name: String
   root: Boolean
}

input MenuUpdateManyInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateInput!]
   delete: [MenuWhereUniqueInput!]
   deleteMany: [MenuScalarWhereInput!]
   disconnect: [MenuWhereUniqueInput!]
   set: [MenuWhereUniqueInput!]
   update: [MenuUpdateWithWhereUniqueNestedInput!]
   updateMany: [MenuUpdateManyWithWhereNestedInput!]
   upsert: [MenuUpsertWithWhereUniqueNestedInput!]
}

input MenuUpdateManyWithoutItemsInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateWithoutItemsInput!]
   delete: [MenuWhereUniqueInput!]
   deleteMany: [MenuScalarWhereInput!]
   disconnect: [MenuWhereUniqueInput!]
   set: [MenuWhereUniqueInput!]
   update: [MenuUpdateWithWhereUniqueWithoutItemsInput!]
   updateMany: [MenuUpdateManyWithWhereNestedInput!]
   upsert: [MenuUpsertWithWhereUniqueWithoutItemsInput!]
}

input MenuUpdateManyWithoutMenusInput {
   connect: [MenuWhereUniqueInput!]
   create: [MenuCreateWithoutMenusInput!]
   delete: [MenuWhereUniqueInput!]
   deleteMany: [MenuScalarWhereInput!]
   disconnect: [MenuWhereUniqueInput!]
   set: [MenuWhereUniqueInput!]
   update: [MenuUpdateWithWhereUniqueWithoutMenusInput!]
   updateMany: [MenuUpdateManyWithWhereNestedInput!]
   upsert: [MenuUpsertWithWhereUniqueWithoutMenusInput!]
}

input MenuUpdateManyWithWhereNestedInput {
   data: MenuUpdateManyDataInput!
   where: MenuScalarWhereInput!
}

input MenuUpdateWithoutItemsDataInput {
   menus: MenuUpdateManyWithoutItemsInput
   name: String
   root: Boolean
}

input MenuUpdateWithoutMenusDataInput {
   items: MenuUpdateManyWithoutMenusInput
   name: String
   root: Boolean
}

input MenuUpdateWithWhereUniqueNestedInput {
   data: MenuUpdateDataInput!
   where: MenuWhereUniqueInput!
}

input MenuUpdateWithWhereUniqueWithoutItemsInput {
   data: MenuUpdateWithoutItemsDataInput!
   where: MenuWhereUniqueInput!
}

input MenuUpdateWithWhereUniqueWithoutMenusInput {
   data: MenuUpdateWithoutMenusDataInput!
   where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueNestedInput {
   create: MenuCreateInput!
   update: MenuUpdateDataInput!
   where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueWithoutItemsInput {
   create: MenuCreateWithoutItemsInput!
   update: MenuUpdateWithoutItemsDataInput!
   where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueWithoutMenusInput {
   create: MenuCreateWithoutMenusInput!
   update: MenuUpdateWithoutMenusDataInput!
   where: MenuWhereUniqueInput!
}

input MenuWhereInput {
   AND: [MenuWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   items_some: MenuWhereInput
   menus_some: MenuWhereInput
   name: String
   name_contains: String
   name_ends_with: String
   name_gt: String
   name_gte: String
   name_in: [String!]
   name_lt: String
   name_lte: String
   name_not: String
   name_not_contains: String
   name_not_ends_with: String
   name_not_in: [String!]
   name_not_starts_with: String
   name_starts_with: String
   root: Boolean
   root_not: Boolean
}

input MenuWhereUniqueInput {
   id: ID
}

type Mutation {
   createStepResult(data: StepResultCreateInput!): StepResult!
   createTestResult(data: TestResultCreateInput!): TestResult!
   updateStepResult(
      data: StepResultUpdateInput!
      where: StepResultWhereUniqueInput!
   ): StepResult
   updateTestResult(
      data: TestResultUpdateInput!
      where: TestResultWhereUniqueInput!
   ): TestResult
}

type Path {
   id: ID!
   parent: Step!
   paths(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
}

input PathCreateManyWithoutParentInput {
   connect: [PathWhereUniqueInput!]
   create: [PathCreateWithoutParentInput!]
}

input PathCreateWithoutParentInput {
   id: ID
   paths: MenuCreateManyInput
}

enum PathOrderByInput {
   id_ASC
   id_DESC
}

input PathScalarWhereInput {
   AND: [PathScalarWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [PathScalarWhereInput!]
   OR: [PathScalarWhereInput!]
}

input PathUpdateManyWithoutParentInput {
   connect: [PathWhereUniqueInput!]
   create: [PathCreateWithoutParentInput!]
   delete: [PathWhereUniqueInput!]
   deleteMany: [PathScalarWhereInput!]
   disconnect: [PathWhereUniqueInput!]
   set: [PathWhereUniqueInput!]
   update: [PathUpdateWithWhereUniqueWithoutParentInput!]
   upsert: [PathUpsertWithWhereUniqueWithoutParentInput!]
}

input PathUpdateWithoutParentDataInput {
   paths: MenuUpdateManyInput
}

input PathUpdateWithWhereUniqueWithoutParentInput {
   data: PathUpdateWithoutParentDataInput!
   where: PathWhereUniqueInput!
}

input PathUpsertWithWhereUniqueWithoutParentInput {
   create: PathCreateWithoutParentInput!
   update: PathUpdateWithoutParentDataInput!
   where: PathWhereUniqueInput!
}

input PathWhereInput {
   AND: [PathWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   parent: StepWhereInput
   paths_some: MenuWhereInput
}

input PathWhereUniqueInput {
   id: ID
}

type Query {
   keys(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: KeysOrderByInput
      skip: Int
      where: KeysWhereInput
   ): [Keys!]!
   results(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: TestResultOrderByInput
      skip: Int
      where: TestResultWhereInput
   ): [TestResult!]!
   test(where: TestWhereUniqueInput!): Test
   views(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: ViewOrderByInput
      skip: Int
      where: ViewWhereInput
   ): [View!]!
}

type Step {
   id: ID!
   parent: Test
   paths(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: PathOrderByInput
      skip: Int
      where: PathWhereInput
   ): [Path!]
   question: String!
   results(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepResultOrderByInput
      skip: Int
      where: StepResultWhereInput
   ): [StepResult!]
   targets(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   type(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: KeyUserTypeOrderByInput
      skip: Int
      where: KeyUserTypeWhereInput
   ): [KeyUserType!]
}

input StepCreateManyWithoutParentInput {
   connect: [StepWhereUniqueInput!]
   create: [StepCreateWithoutParentInput!]
}

input StepCreateOneWithoutResultsInput {
   connect: StepWhereUniqueInput
   create: StepCreateWithoutResultsInput
}

input StepCreateWithoutParentInput {
   id: ID
   paths: PathCreateManyWithoutParentInput
   question: String!
   results: StepResultCreateManyWithoutParentInput
   targets: MenuCreateManyInput
   type: KeyUserTypeCreateManyWithoutStepsInput
}

input StepCreateWithoutResultsInput {
   id: ID
   parent: TestCreateOneWithoutStepsInput
   paths: PathCreateManyWithoutParentInput
   question: String!
   targets: MenuCreateManyInput
   type: KeyUserTypeCreateManyWithoutStepsInput
}

enum StepOrderByInput {
   id_ASC
   id_DESC
   question_ASC
   question_DESC
}

type StepResult {
   end: DateTime
   id: ID!
   parent: Step!
   path(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   resultParent: TestResult!
   start: DateTime!
   status: KeyResultStatus!
   time: TimeResult
}

input StepResultCreateInput {
   end: DateTime
   id: ID
   parent: StepCreateOneWithoutResultsInput!
   path: MenuCreateManyInput
   resultParent: TestResultCreateOneWithoutStepsInput!
   start: DateTime!
   status: KeyResultStatusCreateOneInput!
   time: TimeResultCreateOneInput
}

input StepResultCreateManyWithoutParentInput {
   connect: [StepResultWhereUniqueInput!]
   create: [StepResultCreateWithoutParentInput!]
}

input StepResultCreateManyWithoutResultParentInput {
   connect: [StepResultWhereUniqueInput!]
   create: [StepResultCreateWithoutResultParentInput!]
}

input StepResultCreateWithoutParentInput {
   end: DateTime
   id: ID
   path: MenuCreateManyInput
   resultParent: TestResultCreateOneWithoutStepsInput!
   start: DateTime!
   status: KeyResultStatusCreateOneInput!
   time: TimeResultCreateOneInput
}

input StepResultCreateWithoutResultParentInput {
   end: DateTime
   id: ID
   parent: StepCreateOneWithoutResultsInput!
   path: MenuCreateManyInput
   start: DateTime!
   status: KeyResultStatusCreateOneInput!
   time: TimeResultCreateOneInput
}

enum StepResultOrderByInput {
   end_ASC
   end_DESC
   id_ASC
   id_DESC
   start_ASC
   start_DESC
}

input StepResultScalarWhereInput {
   AND: [StepResultScalarWhereInput!]
   end: DateTime
   end_gt: DateTime
   end_gte: DateTime
   end_in: [DateTime!]
   end_lt: DateTime
   end_lte: DateTime
   end_not: DateTime
   end_not_in: [DateTime!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [StepResultScalarWhereInput!]
   OR: [StepResultScalarWhereInput!]
   start: DateTime
   start_gt: DateTime
   start_gte: DateTime
   start_in: [DateTime!]
   start_lt: DateTime
   start_lte: DateTime
   start_not: DateTime
   start_not_in: [DateTime!]
}

input StepResultUpdateInput {
   end: DateTime
   parent: StepUpdateOneRequiredWithoutResultsInput
   path: MenuUpdateManyInput
   resultParent: TestResultUpdateOneRequiredWithoutStepsInput
   start: DateTime
   status: KeyResultStatusUpdateOneRequiredInput
   time: TimeResultUpdateOneInput
}

input StepResultUpdateManyDataInput {
   end: DateTime
   start: DateTime
}

input StepResultUpdateManyWithoutParentInput {
   connect: [StepResultWhereUniqueInput!]
   create: [StepResultCreateWithoutParentInput!]
   delete: [StepResultWhereUniqueInput!]
   deleteMany: [StepResultScalarWhereInput!]
   disconnect: [StepResultWhereUniqueInput!]
   set: [StepResultWhereUniqueInput!]
   update: [StepResultUpdateWithWhereUniqueWithoutParentInput!]
   updateMany: [StepResultUpdateManyWithWhereNestedInput!]
   upsert: [StepResultUpsertWithWhereUniqueWithoutParentInput!]
}

input StepResultUpdateManyWithoutResultParentInput {
   connect: [StepResultWhereUniqueInput!]
   create: [StepResultCreateWithoutResultParentInput!]
   delete: [StepResultWhereUniqueInput!]
   deleteMany: [StepResultScalarWhereInput!]
   disconnect: [StepResultWhereUniqueInput!]
   set: [StepResultWhereUniqueInput!]
   update: [StepResultUpdateWithWhereUniqueWithoutResultParentInput!]
   updateMany: [StepResultUpdateManyWithWhereNestedInput!]
   upsert: [StepResultUpsertWithWhereUniqueWithoutResultParentInput!]
}

input StepResultUpdateManyWithWhereNestedInput {
   data: StepResultUpdateManyDataInput!
   where: StepResultScalarWhereInput!
}

input StepResultUpdateWithoutParentDataInput {
   end: DateTime
   path: MenuUpdateManyInput
   resultParent: TestResultUpdateOneRequiredWithoutStepsInput
   start: DateTime
   status: KeyResultStatusUpdateOneRequiredInput
   time: TimeResultUpdateOneInput
}

input StepResultUpdateWithoutResultParentDataInput {
   end: DateTime
   parent: StepUpdateOneRequiredWithoutResultsInput
   path: MenuUpdateManyInput
   start: DateTime
   status: KeyResultStatusUpdateOneRequiredInput
   time: TimeResultUpdateOneInput
}

input StepResultUpdateWithWhereUniqueWithoutParentInput {
   data: StepResultUpdateWithoutParentDataInput!
   where: StepResultWhereUniqueInput!
}

input StepResultUpdateWithWhereUniqueWithoutResultParentInput {
   data: StepResultUpdateWithoutResultParentDataInput!
   where: StepResultWhereUniqueInput!
}

input StepResultUpsertWithWhereUniqueWithoutParentInput {
   create: StepResultCreateWithoutParentInput!
   update: StepResultUpdateWithoutParentDataInput!
   where: StepResultWhereUniqueInput!
}

input StepResultUpsertWithWhereUniqueWithoutResultParentInput {
   create: StepResultCreateWithoutResultParentInput!
   update: StepResultUpdateWithoutResultParentDataInput!
   where: StepResultWhereUniqueInput!
}

input StepResultWhereInput {
   AND: [StepResultWhereInput!]
   end: DateTime
   end_gt: DateTime
   end_gte: DateTime
   end_in: [DateTime!]
   end_lt: DateTime
   end_lte: DateTime
   end_not: DateTime
   end_not_in: [DateTime!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   parent: StepWhereInput
   path_some: MenuWhereInput
   resultParent: TestResultWhereInput
   start: DateTime
   start_gt: DateTime
   start_gte: DateTime
   start_in: [DateTime!]
   start_lt: DateTime
   start_lte: DateTime
   start_not: DateTime
   start_not_in: [DateTime!]
   status: KeyResultStatusWhereInput
   time: TimeResultWhereInput
}

input StepResultWhereUniqueInput {
   id: ID
}

input StepScalarWhereInput {
   AND: [StepScalarWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [StepScalarWhereInput!]
   OR: [StepScalarWhereInput!]
   question: String
   question_contains: String
   question_ends_with: String
   question_gt: String
   question_gte: String
   question_in: [String!]
   question_lt: String
   question_lte: String
   question_not: String
   question_not_contains: String
   question_not_ends_with: String
   question_not_in: [String!]
   question_not_starts_with: String
   question_starts_with: String
}

input StepUpdateManyDataInput {
   question: String
}

input StepUpdateManyWithoutParentInput {
   connect: [StepWhereUniqueInput!]
   create: [StepCreateWithoutParentInput!]
   delete: [StepWhereUniqueInput!]
   deleteMany: [StepScalarWhereInput!]
   disconnect: [StepWhereUniqueInput!]
   set: [StepWhereUniqueInput!]
   update: [StepUpdateWithWhereUniqueWithoutParentInput!]
   updateMany: [StepUpdateManyWithWhereNestedInput!]
   upsert: [StepUpsertWithWhereUniqueWithoutParentInput!]
}

input StepUpdateManyWithWhereNestedInput {
   data: StepUpdateManyDataInput!
   where: StepScalarWhereInput!
}

input StepUpdateOneRequiredWithoutResultsInput {
   connect: StepWhereUniqueInput
   create: StepCreateWithoutResultsInput
   update: StepUpdateWithoutResultsDataInput
   upsert: StepUpsertWithoutResultsInput
}

input StepUpdateWithoutParentDataInput {
   paths: PathUpdateManyWithoutParentInput
   question: String
   results: StepResultUpdateManyWithoutParentInput
   targets: MenuUpdateManyInput
   type: KeyUserTypeUpdateManyWithoutStepsInput
}

input StepUpdateWithoutResultsDataInput {
   parent: TestUpdateOneWithoutStepsInput
   paths: PathUpdateManyWithoutParentInput
   question: String
   targets: MenuUpdateManyInput
   type: KeyUserTypeUpdateManyWithoutStepsInput
}

input StepUpdateWithWhereUniqueWithoutParentInput {
   data: StepUpdateWithoutParentDataInput!
   where: StepWhereUniqueInput!
}

input StepUpsertWithoutResultsInput {
   create: StepCreateWithoutResultsInput!
   update: StepUpdateWithoutResultsDataInput!
}

input StepUpsertWithWhereUniqueWithoutParentInput {
   create: StepCreateWithoutParentInput!
   update: StepUpdateWithoutParentDataInput!
   where: StepWhereUniqueInput!
}

input StepWhereInput {
   AND: [StepWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   parent: TestWhereInput
   paths_some: PathWhereInput
   question: String
   question_contains: String
   question_ends_with: String
   question_gt: String
   question_gte: String
   question_in: [String!]
   question_lt: String
   question_lte: String
   question_not: String
   question_not_contains: String
   question_not_ends_with: String
   question_not_in: [String!]
   question_not_starts_with: String
   question_starts_with: String
   results_some: StepResultWhereInput
   targets_some: MenuWhereInput
   type_some: KeyUserTypeWhereInput
}

input StepWhereUniqueInput {
   id: ID
}

type Test {
   id: ID!
   menus(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   results(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: TestResultOrderByInput
      skip: Int
      where: TestResultWhereInput
   ): [TestResult!]
   steps(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepOrderByInput
      skip: Int
      where: StepWhereInput
   ): [Step!]
   title: String!
}

input TestCreateOneWithoutResultsInput {
   connect: TestWhereUniqueInput
   create: TestCreateWithoutResultsInput
}

input TestCreateOneWithoutStepsInput {
   connect: TestWhereUniqueInput
   create: TestCreateWithoutStepsInput
}

input TestCreateWithoutResultsInput {
   id: ID
   menus: MenuCreateManyInput
   steps: StepCreateManyWithoutParentInput
   title: String!
}

input TestCreateWithoutStepsInput {
   id: ID
   menus: MenuCreateManyInput
   results: TestResultCreateManyWithoutParentInput
   title: String!
}

enum TestOrderByInput {
   id_ASC
   id_DESC
   title_ASC
   title_DESC
}

type TestResult {
   end: DateTime
   id: ID!
   parent: Test!
   start: DateTime!
   status: KeyResultStatus!
   steps(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepResultOrderByInput
      skip: Int
      where: StepResultWhereInput
   ): [StepResult!]
   time: TimeResult
}

input TestResultCreateInput {
   end: DateTime
   id: ID
   parent: TestCreateOneWithoutResultsInput!
   start: DateTime!
   status: KeyResultStatusCreateOneWithoutResultsInput!
   steps: StepResultCreateManyWithoutResultParentInput
   time: TimeResultCreateOneInput
}

input TestResultCreateManyWithoutParentInput {
   connect: [TestResultWhereUniqueInput!]
   create: [TestResultCreateWithoutParentInput!]
}

input TestResultCreateManyWithoutStatusInput {
   connect: [TestResultWhereUniqueInput!]
   create: [TestResultCreateWithoutStatusInput!]
}

input TestResultCreateOneWithoutStepsInput {
   connect: TestResultWhereUniqueInput
   create: TestResultCreateWithoutStepsInput
}

input TestResultCreateWithoutParentInput {
   end: DateTime
   id: ID
   start: DateTime!
   status: KeyResultStatusCreateOneWithoutResultsInput!
   steps: StepResultCreateManyWithoutResultParentInput
   time: TimeResultCreateOneInput
}

input TestResultCreateWithoutStatusInput {
   end: DateTime
   id: ID
   parent: TestCreateOneWithoutResultsInput!
   start: DateTime!
   steps: StepResultCreateManyWithoutResultParentInput
   time: TimeResultCreateOneInput
}

input TestResultCreateWithoutStepsInput {
   end: DateTime
   id: ID
   parent: TestCreateOneWithoutResultsInput!
   start: DateTime!
   status: KeyResultStatusCreateOneWithoutResultsInput!
   time: TimeResultCreateOneInput
}

enum TestResultOrderByInput {
   end_ASC
   end_DESC
   id_ASC
   id_DESC
   start_ASC
   start_DESC
}

input TestResultScalarWhereInput {
   AND: [TestResultScalarWhereInput!]
   end: DateTime
   end_gt: DateTime
   end_gte: DateTime
   end_in: [DateTime!]
   end_lt: DateTime
   end_lte: DateTime
   end_not: DateTime
   end_not_in: [DateTime!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   NOT: [TestResultScalarWhereInput!]
   OR: [TestResultScalarWhereInput!]
   start: DateTime
   start_gt: DateTime
   start_gte: DateTime
   start_in: [DateTime!]
   start_lt: DateTime
   start_lte: DateTime
   start_not: DateTime
   start_not_in: [DateTime!]
}

input TestResultUpdateInput {
   end: DateTime
   parent: TestUpdateOneRequiredWithoutResultsInput
   start: DateTime
   status: KeyResultStatusUpdateOneRequiredWithoutResultsInput
   steps: StepResultUpdateManyWithoutResultParentInput
   time: TimeResultUpdateOneInput
}

input TestResultUpdateManyDataInput {
   end: DateTime
   start: DateTime
}

input TestResultUpdateManyWithoutParentInput {
   connect: [TestResultWhereUniqueInput!]
   create: [TestResultCreateWithoutParentInput!]
   delete: [TestResultWhereUniqueInput!]
   deleteMany: [TestResultScalarWhereInput!]
   disconnect: [TestResultWhereUniqueInput!]
   set: [TestResultWhereUniqueInput!]
   update: [TestResultUpdateWithWhereUniqueWithoutParentInput!]
   updateMany: [TestResultUpdateManyWithWhereNestedInput!]
   upsert: [TestResultUpsertWithWhereUniqueWithoutParentInput!]
}

input TestResultUpdateManyWithoutStatusInput {
   connect: [TestResultWhereUniqueInput!]
   create: [TestResultCreateWithoutStatusInput!]
   delete: [TestResultWhereUniqueInput!]
   deleteMany: [TestResultScalarWhereInput!]
   disconnect: [TestResultWhereUniqueInput!]
   set: [TestResultWhereUniqueInput!]
   update: [TestResultUpdateWithWhereUniqueWithoutStatusInput!]
   updateMany: [TestResultUpdateManyWithWhereNestedInput!]
   upsert: [TestResultUpsertWithWhereUniqueWithoutStatusInput!]
}

input TestResultUpdateManyWithWhereNestedInput {
   data: TestResultUpdateManyDataInput!
   where: TestResultScalarWhereInput!
}

input TestResultUpdateOneRequiredWithoutStepsInput {
   connect: TestResultWhereUniqueInput
   create: TestResultCreateWithoutStepsInput
   update: TestResultUpdateWithoutStepsDataInput
   upsert: TestResultUpsertWithoutStepsInput
}

input TestResultUpdateWithoutParentDataInput {
   end: DateTime
   start: DateTime
   status: KeyResultStatusUpdateOneRequiredWithoutResultsInput
   steps: StepResultUpdateManyWithoutResultParentInput
   time: TimeResultUpdateOneInput
}

input TestResultUpdateWithoutStatusDataInput {
   end: DateTime
   parent: TestUpdateOneRequiredWithoutResultsInput
   start: DateTime
   steps: StepResultUpdateManyWithoutResultParentInput
   time: TimeResultUpdateOneInput
}

input TestResultUpdateWithoutStepsDataInput {
   end: DateTime
   parent: TestUpdateOneRequiredWithoutResultsInput
   start: DateTime
   status: KeyResultStatusUpdateOneRequiredWithoutResultsInput
   time: TimeResultUpdateOneInput
}

input TestResultUpdateWithWhereUniqueWithoutParentInput {
   data: TestResultUpdateWithoutParentDataInput!
   where: TestResultWhereUniqueInput!
}

input TestResultUpdateWithWhereUniqueWithoutStatusInput {
   data: TestResultUpdateWithoutStatusDataInput!
   where: TestResultWhereUniqueInput!
}

input TestResultUpsertWithoutStepsInput {
   create: TestResultCreateWithoutStepsInput!
   update: TestResultUpdateWithoutStepsDataInput!
}

input TestResultUpsertWithWhereUniqueWithoutParentInput {
   create: TestResultCreateWithoutParentInput!
   update: TestResultUpdateWithoutParentDataInput!
   where: TestResultWhereUniqueInput!
}

input TestResultUpsertWithWhereUniqueWithoutStatusInput {
   create: TestResultCreateWithoutStatusInput!
   update: TestResultUpdateWithoutStatusDataInput!
   where: TestResultWhereUniqueInput!
}

input TestResultWhereInput {
   AND: [TestResultWhereInput!]
   end: DateTime
   end_gt: DateTime
   end_gte: DateTime
   end_in: [DateTime!]
   end_lt: DateTime
   end_lte: DateTime
   end_not: DateTime
   end_not_in: [DateTime!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   parent: TestWhereInput
   start: DateTime
   start_gt: DateTime
   start_gte: DateTime
   start_in: [DateTime!]
   start_lt: DateTime
   start_lte: DateTime
   start_not: DateTime
   start_not_in: [DateTime!]
   status: KeyResultStatusWhereInput
   steps_some: StepResultWhereInput
   time: TimeResultWhereInput
}

input TestResultWhereUniqueInput {
   id: ID
}

input TestUpdateOneRequiredWithoutResultsInput {
   connect: TestWhereUniqueInput
   create: TestCreateWithoutResultsInput
   update: TestUpdateWithoutResultsDataInput
   upsert: TestUpsertWithoutResultsInput
}

input TestUpdateOneWithoutStepsInput {
   connect: TestWhereUniqueInput
   create: TestCreateWithoutStepsInput
   delete: Boolean
   disconnect: Boolean
   update: TestUpdateWithoutStepsDataInput
   upsert: TestUpsertWithoutStepsInput
}

input TestUpdateWithoutResultsDataInput {
   menus: MenuUpdateManyInput
   steps: StepUpdateManyWithoutParentInput
   title: String
}

input TestUpdateWithoutStepsDataInput {
   menus: MenuUpdateManyInput
   results: TestResultUpdateManyWithoutParentInput
   title: String
}

input TestUpsertWithoutResultsInput {
   create: TestCreateWithoutResultsInput!
   update: TestUpdateWithoutResultsDataInput!
}

input TestUpsertWithoutStepsInput {
   create: TestCreateWithoutStepsInput!
   update: TestUpdateWithoutStepsDataInput!
}

input TestWhereInput {
   AND: [TestWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   menus_some: MenuWhereInput
   results_some: TestResultWhereInput
   steps_some: StepWhereInput
   title: String
   title_contains: String
   title_ends_with: String
   title_gt: String
   title_gte: String
   title_in: [String!]
   title_lt: String
   title_lte: String
   title_not: String
   title_not_contains: String
   title_not_ends_with: String
   title_not_in: [String!]
   title_not_starts_with: String
   title_starts_with: String
}

input TestWhereUniqueInput {
   id: ID
}

type TimeResult {
   id: ID!
   int: Int!
   text: String!
}

input TimeResultCreateInput {
   id: ID
   int: Int!
   text: String!
}

input TimeResultCreateOneInput {
   connect: TimeResultWhereUniqueInput
   create: TimeResultCreateInput
}

input TimeResultUpdateDataInput {
   int: Int
   text: String
}

input TimeResultUpdateOneInput {
   connect: TimeResultWhereUniqueInput
   create: TimeResultCreateInput
   delete: Boolean
   disconnect: Boolean
   update: TimeResultUpdateDataInput
   upsert: TimeResultUpsertNestedInput
}

input TimeResultUpsertNestedInput {
   create: TimeResultCreateInput!
   update: TimeResultUpdateDataInput!
}

input TimeResultWhereInput {
   AND: [TimeResultWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   int: Int
   int_gt: Int
   int_gte: Int
   int_in: [Int!]
   int_lt: Int
   int_lte: Int
   int_not: Int
   int_not_in: [Int!]
   text: String
   text_contains: String
   text_ends_with: String
   text_gt: String
   text_gte: String
   text_in: [String!]
   text_lt: String
   text_lte: String
   text_not: String
   text_not_contains: String
   text_not_ends_with: String
   text_not_in: [String!]
   text_not_starts_with: String
   text_starts_with: String
}

input TimeResultWhereUniqueInput {
   id: ID
}

type View {
   company: Company!
   id: ID!
   menus(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: MenuOrderByInput
      skip: Int
      where: MenuWhereInput
   ): [Menu!]
   steps(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: StepOrderByInput
      skip: Int
      where: StepWhereInput
   ): [Step!]
   tests(
      after: String
      before: String
      first: Int
      last: Int
      orderBy: TestOrderByInput
      skip: Int
      where: TestWhereInput
   ): [Test!]
   welcome: Welcome!
}

enum ViewOrderByInput {
   id_ASC
   id_DESC
}

input ViewWhereInput {
   AND: [ViewWhereInput!]
   company: CompanyWhereInput
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   menus_some: MenuWhereInput
   steps_some: StepWhereInput
   tests_some: TestWhereInput
   welcome: WelcomeWhereInput
}

type Welcome {
   id: ID!
   message: String!
   title: String!
}

input WelcomeWhereInput {
   AND: [WelcomeWhereInput!]
   id: ID
   id_contains: ID
   id_ends_with: ID
   id_gt: ID
   id_gte: ID
   id_in: [ID!]
   id_lt: ID
   id_lte: ID
   id_not: ID
   id_not_contains: ID
   id_not_ends_with: ID
   id_not_in: [ID!]
   id_not_starts_with: ID
   id_starts_with: ID
   message: String
   message_contains: String
   message_ends_with: String
   message_gt: String
   message_gte: String
   message_in: [String!]
   message_lt: String
   message_lte: String
   message_not: String
   message_not_contains: String
   message_not_ends_with: String
   message_not_in: [String!]
   message_not_starts_with: String
   message_starts_with: String
   title: String
   title_contains: String
   title_ends_with: String
   title_gt: String
   title_gte: String
   title_in: [String!]
   title_lt: String
   title_lte: String
   title_not: String
   title_not_contains: String
   title_not_ends_with: String
   title_not_in: [String!]
   title_not_starts_with: String
   title_starts_with: String
}
